---
title: Framework Design Guidelines 整理與心得 (2)
date: 2022-10-13 00:20:50
categories:
- Reading
- Framework Design Guidelines
tags:
---
這系列文章的目的是為了之後參考與快速回顧而基於 Framework Design Guidelines 這本書寫的整理與心得，這不是翻譯，所以內容都是閱讀理解後再梳理下來的，和書中語句必然不同，也只會保留我自已覺得需要的部分，並帶一些自己的想法與註解。  

本篇包含了第二章的部分。 

<!--more-->

## 框架設計基礎
成功的通用框架要能被各種技能背景的開發人員用來滿足各種需求，最難的是要兼顧功能性與簡易性，除此之外也要在不同程式語言與應用程式(Application) 的種類下都能有一致的程式設計模型 (Programming Model)。   

> [Programming Model](https://en.wikipedia.org/wiki/Programming_model) 不大好理解...  

+ **O 應該** 兼顧框架的功能性與易用性。  
  提供易於使用的簡單功能同時也經常會需要進階功能，其中取捨就是最難的部分，用 80/20 法則來說，把大部分的設計成本集中用在 20% 最重要/通用的 API。  

+ **O 應該** 了解並針對各種常見開發風格、需求與不同技術能力的使用者來設計，包含和設計者風格迥異但常見的情境，另一個角度來想，為你預期的受眾設計，而不是自己認為好用的設計。  
  > 這滿難的，還好目前做過的都是公司內部使用的套件，受眾都是工程師，還沒遇到設計出來沒人會用的事。  

+ **O 應該** 考慮不同的程式語言，了解並針對語言特性設計 API。  
  
### 漸進式 (Progressive) 框架 
如果一個平台有多個完全不同的框架，那使用者在轉換的過程轉換成本很高，要重學很多東西，理想上是提供一個非常通用的框架，讓入門容易且後面學習曲線比較平緩，一步一步順利的進階。

### 框架設計基本準則
#### 情境驅動原則
必需從一系列的使用情境和模擬使用的程式為起點來設計框架。  

+ **O 應該** 為每個主要的需求定義出最常使用的情境。  
  API 規格書應該要有一個章節來描述主要的使用情境(平均來說五到十個情境)，並且這個章節要在規格總綱後出現。  

+ **O 應該** 確保每個情境的粒度是適當的，也應該對應到使用者的使用情境，例如: "檔案讀取" 就是個適合的情境，但 "開啟檔案"、"讀取第一行"、"關閉檔案" 等就太瑣碎了。  

+ **O 應該** 在設計前寫呼叫端的程式，先考慮使用者的使用方式再開始實作。  
  如果先做功能，可能會使用一些設計方法 (例如物件導向設計)，但這些設計的優勢在於可維護性、可讀性等，可能適合在內部專案使用，但不適合用來設計對外公開的大型框架。   

+ **O 應該** 需要跨語言使用的話，至少用兩種以上的語言來模擬主要的使用情境，最好還是語法和風格都不同的語言，例如 (VB 和 C++)。  
  
+ **O 考慮** 用動態語言模擬主要的使用情境。  

+ **X 不應** "只"依賴主流的設計方法，主流方法例如物件導向設計的目標寫寫出好維護的程式，不是針對 API 的易用性，情境驅動加上經過幾次打草稿與易用性研究的步驟是比較理想的做法。  

**關於易用性**  
易用性這很主觀，對設計者來說自己的設計當然怎麼看怎麼簡單，但對使用者卻不一定。  

+ **O 應該** 為 API 的主要使用情境制定易用性研究機制。  
  這個機制應該要在開發週期前期儘早進行，因為易用性的問題要改容易造成重大變更。 多數使用者應該要能輕易上手主要的使用情境，否則就是 API 要重新設計了。   

#### 低進入門檻原則
框架必需提供低進入門檻讓普通使用者都能輕易上手。  

框架使用者都希望能快速入門，一開始沒設計好讓使用者不能快速上手的話可能使用者就不想用了，例如要能易於"聯想"，能大概猜的到主要功能在哪些命名空間下，也要有明確的錯誤訊息讓使用者知道要怎麼修改等等的。  

> 平常需要用套件的時候對這點很有感，門檻不夠低的話真的會直接放棄換一套。  

+ **O 應該** 確定主要功能的命名空間下只包含最常用的功能，進階功能應該出現在子命名空間中(Subnamespaces)，如果把常用的功能放在子命名空間中會有不易被使用者發現的缺點，例如: Anthony Moore 表示他們事後才想到 `StringBuilder` 應該在 `System` 命名空間下而不是現在的 `System。Text`，因為它比起其他 `System.Text` 下的類別常用太多且相似性太低。  
  > 這衍伸到之前遇到的兩難問題。  
  > 常用功能在命名空間 `Foo` 下，他們會依賴一些共用的核心功能在命名空間 `Foo.Core`，這樣 `Foo` 中的類別會依賴 `Foo.Core` 中的類別。  
  > 但從另外一個角度來說，常用功能在命名空間 `Foo` 下，進階功能延伸自常用功能所以放在命名空間 `Foo.Advance` 下，反而變成 `Foo.Advance` 中的類別會依賴 `Foo` 中的類別。  
  > 到目前我還不清楚應該要堅持某一種設計，還是兩種風格都可以... 

+ **O 應該** 提供簡單的多載，參數盡量少且最好都是原生型別(Primitive Types)。  
  > 這點我目前的偏好是，提供一個最多參數的多載滿足彈性，另外提供一個最簡單的多載滿足最簡易的情境，除此之外如果真的需要其他多載再另外考慮，而這些多載通常都會呼叫最多參數的那個多載，除了對外提供的參數外其他都會是預設。  
  > 當然，所有多載的預設值要一致。  

+ **X 不應**  在常用功能的類別中放特殊功能。  

Brad Abrams 表示，在設計 .NET Framework 的其中一個重要概念是，用減少功能或乾脆不做來提高成效 (More Productive) 因為這樣要處理的概念比較少。  

> 就是功能易加難維護，要加要謹慎的意思。  

+ **X 不應** 讓使用者在最簡單的情境中要初始化/操作超過一個類別。  
  > 最印象深刻的就是 `Stream`、`StreamReader`、`StreamWriter` 系列的類別，操作起來真的不方便。  

+ **X 不應** 讓使用者在簡單的情境中還要先寫一堆初始化的程式才能用，最好能用無參數建構子或是簡單參數的建構子就做完初始化。  
  ADO.NET 是典型難以入手的功能，連要完成最簡單的功能都需要操作 `DataSet`、`DataAdapter`、`SqlConnection`、`SqlCommand` 等物件。  

  > 以前用過幾次 ADO.NET，原來覺得用起來超繁瑣不是我的錯覺。

+ **O 應該** 盡量利用多載提供適當的的預設值，就算有一堆複雜的參數會影響運作結果，但只要能提供預設值，對使用者來說就不需要考慮那些參數，找幾個類別或是方法中有很多參數的與多載的情境就能體會出來。  
  當然預設值要合理，且使用者要能在不知道這些預設值的前提下使用，不能用有效能問題、安全風險、很大的副作用之類的參數當預設。  

+ **O 應該** 用拋出例外 (Exception) 來讓使用者知道不能這樣使用，例外內容要清楚描述為什麼不能這樣用，以及應該怎麼用等等的指導訊息。  
  > 這個我在設計上會更傾向在 API 的設計上就讓使用者無法用錯，例如: 避免提供要依序執行才會正確運作的 API，盡量支援輸入參數的所有邊際情境(不過也只是盡量，要完全讓使用者無法用錯還是很難)。  

#### 能自我描述的物件模型 (Self-Documenting Object Models)
在簡單的情境下，框架必需能在不用文件的前提下就能使用。  
當然文件還是很重要的，只是使用者可能瞄一下快速入門 (Quick Start) 部分就開始邊做邊學了，所以沒辦法假設使用者會先看完一大本文件再開始使用。

> 就跟家電說明書一樣，都是用到一半有問題才會翻出來看。  

+ **O 應該** 確保 API 很直覺到不需要看文件就能使用。  
  > 完全不看文件有點難，但至少要能讓使用者只看快速入門部分就能使用基本功能。  

+ **O 應該** 為所有 API 提供高品質的文件。  
  > 以 C# 搭配 Visual Studio 來說，有很多工具是可以從 XML 註解產生完整的 API 文件的，當然這只是查詢用的，常用功能的使用方式還是要另外寫快速入門文件說明。  

要讓框架能自我描述，要考量的面向很多，例如: 命名、參數設計、成員設計、拋出的例外訊息、註解等等。

##### 命名
框架設計者經常會把最常用、最直覺的名字拿來用在不那麼常用的情境上，而失去把它用在真正常用的情境的機會，舉例來說 `NtfsFile` 繼承抽象型別 `File`，這樣的設計在物件導向設計上是合理的，但如果有人想用檔案操作的功能又沒先弄清楚他們的繼承關係的話，可能會先試著用 `File` 然後才發現不能這樣用。  

命名要能清楚的標示出型別或方法的功能，如果能清楚命名的話即使名字看起來有點長也是划算的，另外通常簡單的概念比較容易命名，這也是"避免太複雜的概念"一般來說是個好的方向。  

總之，命名對於框架設計者來說是最重要的決定，因為當發布後要再改名就難上加難了。  

> 之前總會擔心命名太龜毛會不會被嫌，但大神都這樣說了，看來不影響時程的前提下嚴格一點還是好的。  

+ **O 應該** 將命名視為規格審查 (Specification Reviews) 中重要的一部分。  
  例如: 這個功能最常從哪個類別開始? 在使用這個情境的時候最常想到那些名字? 這個名字是最直覺的選擇嗎? 同樣的，套用到類別中其他成員的設計上也是如此。  

+ **X 不應** 為了簡短而犧牲命名的品質。  
  長一點的命名在現在開發工具提供的自動提示 (Intellisence) 功能下不會造成麻煩，甚至比較好找，還更好理解。  
  >  這部分的重點是 "命名時不要刻意縮減長度"，不是說名字長一點就是好的，命名還是要以適當為主。

+ **O 考慮** 在設計階段就讓了解使用者程度的專家 (User Education Exprerts) 進場，有助於釐清命名對使用者來說會不會很難理解。  

+ **O 考慮** 最好的名字留給最常用的情境。  
   Anthony Moore 表示，避免用太通用 (General) 的名字的幾個考量是，一來明確的名字能讓 API 更好理解閱讀，二來使用者看到太通用的名字會覺得這個功能非常通用，所以把太通用的名字給不夠通用的功能是不好的。  

##### 例外 (Exceptions)
例外在能自我描述的框架中扮演重要的角色，能透過例外訊息提供正確的使用提示。  

+ **O 應該** 在例外訊息中提供誤用的訊息。

> 包含怎麼錯的、為什麼這樣會錯、應該怎麼用、或可能的修改方案

##### 強型別
強型別是辨別 API 有多直覺的最重要指標，例如: `Class.MyProperty` 明顯比 `Class.Properties["MyProperty"]` 容易使用，又例如回傳 `string` 型別的值好過回傳 `object` 型別的值，雖然這種弱型別的設計有時是必要的，但終歸只是特例而不是通則。  

+ **O 應該** 盡可能提供強型別的 API。  
  不要僅依賴像是屬性包 (Property Bags) 這種弱型別 API，就算真的需要也應該額外為常用情境提供強型別的屬性，例如: 雖然可以透過 `Person.Properties["Address"]` 取得資料，但常用的幾項資訊仍要提供像 `Person.Name`、`Person.Age`、`Person.Address` 等的屬性 (Property)。  
  
> 雖然主題是強型別，但重點是易用性，所以思考方向是讓使用者好上手且容易使用，例如: 雖然 `int`、`string` 和 `enum` 都是強型別，但適合用 `enum` 時就不要用其他會產生 magic number / string 的型別。  

##### 一致性
和現有的 API 保持一致性也是非常重要的部分。  

> 這部分需要取捨，如果現有的 API 真的很糟，會需要綜合考量 "一致但很糟" 和 "改良過但不一致" 這兩者之間各自的優缺點以及對現有程式碼的影響再決定怎麼發展。  
> 如果把一致性當天條，那就表示不良的設計將永遠傳承難以汰換; 反之如果想改就改，最後整體設計會很凌亂，進而走向另一個極端。  

+ **O 應該** 確保和 .NET Framework 或是使用者習慣的框架保持高度一致性。  

##### 有限度的抽象化 (Limiting Abstractions)
常見的情境不應該過度抽象化，應該要和現有的功能互動來達到效果。 就像之前說的物件導向設計是為了好維護，而這樣會產生較多的抽象設計，當然這是合理的，畢竟維護成本是很高的，只是問題在於高度抽象的設計會讓使用者更難以快速入門，而在框架設計上，應該以使用者易用性為優先考量。  

+ **X 不應** 將常用情境的 API **過度**抽象化。  

> 高度抽象化的例子最容易看到的就是複雜一點的設計模式 (Design Patterns)，而低抽象化的範例倒是隨處可見。  
> 
> 其實抽象化是必要的，只是任何技巧都有其優缺點，再必要的工具也不應濫用或誤用，剛好在工作上碰過過度抽象化的情境，也碰過完全沒有抽象化的義大利麵，兩者都各自造成了不同面向的傷害。  
> 
> 所以在抽象化這個主題，我們可以先了解抽象化具有的優缺點後再考量正在開發的功能應該要著重在哪個面向再來調整抽象化的程度。  

抽象化的優點: 
+ 可擴展性高
+ 易維護
+ 易測試

抽象化的缺點: 
+ 使用門檻高
+ 使用不直覺
+ 損失一點效能

#### 分層架構原則
分層式架構能讓框架同時滿足強大的功能與易用性。  

在設計單層的 API 時經常要考慮是要減少功能以降低複雜度還是維持多功能但複雜，如有有分層設計的話就能由底層 (low-level) 提供完整功能而外層 (high-level) 只需要考慮主要情境所需的功能。 另外不是所有情境都需要底層和外層，有些情境是可以直接開放底層 API 出來的。  

命名空間 `System.Web` 就是一個分層設計的範例，ASP.NET 提供 HTTP 層級的功能讓使用者可以彈性控制請求 (Request) 的細節，同時也提供的外層 API 讓使用者可以簡易使用不用考慮太多細節。  

+ **O 考慮** 使用分層框架，讓外層專注於易用性，底層則專注於功能性。  

+ **X 避免** 在底層 API 很複雜(例如有很多型別)的時候把底層和外層 API 放在同一個命名空間下。  

+ **O 應該** 確保單一功能的分層是妥善整合的，使用者即使原本使用的是外層也能能透過微幅的改動就改用底層的進階功能。  

不同層的 API 不限於使用不同的命名空間，也可以在相同的命名空間下。  

##### 分層使用不同的命名空間
這種做法能有效將底層的 API 隔離開，不會暴露在外層讓使用者看到.  
ASP.NET 是用這種方式，底層的 `HttpRuntime` 和外層的 `System.Web.UI` 是在不同的命名空間，大多數的框架應該要採用這種方式。  

##### 分層使用相同的命名空間
優點是如果需要的時候可以直接使用更複雜的功能，缺點是相同命名空間下的複雜類別會讓某些情境更難。  

Steven Clarke 表示，要考慮使用者在使用某一層的功能時不會預期到例外會從別層拋出，所以要確定不管是從讀、寫或是閱讀程式碼的角度上，開發者只需要了解正在使用的這一層，其他層對他們來說只是黑箱。  

## 總結
在設計框架的時候，要注意使用者不管從需求還是技術能力的角度來看都是非常多元的，本章的原則能確保開發出來的框架的受眾更廣。  

### 結論
第二章比較像總綱，細節會在後面其他章節細談。  