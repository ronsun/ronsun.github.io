<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[在非同步情境下使用 ConcurrentDictionary]]></title>
      <url>/content/20240622-concurrent-dictionary.html</url>
      <content type="html"><![CDATA[<p>在處理非同步操作時，當多個非同步任務同時操作共享資源時，可能會導致資料不一致。這篇文章將聚焦於如何在非同步情境下使用 <code>ConcurrentDictionary</code> 取代 <code>Dictionary</code> 來解決這些問題。</p>
<a id="more"></a>
<h3 id="問題程式碼"><a href="#問題程式碼" class="headerlink" title="問題程式碼"></a>問題程式碼</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> tasks = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line">    <span class="keyword">var</span> rdm = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do NOT await here.</span></span><br><span class="line">        <span class="keyword">var</span> t = HttpRequest(dic, rdm.Next());</span><br><span class="line">        tasks.Add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task <span class="title">HttpRequest</span>(<span class="params">Dictionary&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; dic, <span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line">        dic[num] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在這段程式碼中，我們模擬同時發送多個 Http Request 的操作，由於多個請求不需互相等待，因此每次呼叫 HttpRequest 方法時並不會加上 <code>await</code> 關鍵字，而是在所有請求都發出後再等待所有結果完成，以達到效能目標。</p>
<p>但每個 Http Request 完成後都會操作一個共享的 <code>Dictionary&lt;long, long&gt;</code> 物件，這在非同步情境下引發多執行緒操作時，會有非常小的機率導致資料不一致。</p>
<h3 id="解決方案：使用-ConcurrentDictionary"><a href="#解決方案：使用-ConcurrentDictionary" class="headerlink" title="解決方案：使用 ConcurrentDictionary"></a>解決方案：使用 <code>ConcurrentDictionary</code></h3><p>為了解決上述問題，我們可以將 <code>Dictionary</code> 換成 <code>ConcurrentDictionary</code> 這個執行序安全的類別，允許多個執行緒安全地操作其中的資料。  </p>
<p>以下是修改後的程式碼：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dic = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> tasks = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line">    <span class="keyword">var</span> rdm = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do NOT await here.</span></span><br><span class="line">        <span class="keyword">var</span> t = HttpRequest(dic, rdm.Next());</span><br><span class="line">        tasks.Add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task <span class="title">HttpRequest</span>(<span class="params">ConcurrentDictionary&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; dic, <span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line">        dic[num] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實當初開發時有閃過一點疑慮，但因為這只是一個賦值的極簡單操作，一時輕率以為不會出錯，導致在上線後發生資料不一致的問題，且因為這個問題一個月只發生一兩次所以多花了很多時間蒐集資訊和追查原因，真的划不來。除了 <code>ConcurrentDictionary</code> 外，從它的命名空間可以發現還有其他針對執行緒安全所設計的類別，也應善加利用。  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p>ChatGPT</p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[資料查詢很慢的原因與因應方式]]></title>
      <url>/content/20240526-identify-and-solve-slow-data-queries.html</url>
      <content type="html"><![CDATA[<p>在實際專案中，資料查詢緩慢是一個常見的問題，如何找出具體原因成了一個很重要的主題。但在工作中，很多人往往過於注重單一面向而沒有精確的找出真正的瓶頸。例如，因為 ORM 使用不當而導致效能低落，卻將問題歸咎於 ORM 本身進而禁用 ORM。直接撰寫 SQL 查詢雖然可能較快，但失去了 ORM 的優勢。如果能先意識到 ORM 使用不當的問題並加以改善，或許能同時達到效能需求並保有 ORM 的優勢。  </p>
<p>找到問題後的解決方案又是另一個複雜的過程，本文將簡單記錄幾個排查資料查詢緩慢的常見方向及應對方式。</p>
<a id="more"></a>
<h3 id="從-ORM-開始"><a href="#從-ORM-開始" class="headerlink" title="從 ORM 開始"></a>從 ORM 開始</h3><p>接續一開始說的，從 ORM 常見問題開始排查。</p>
<h4 id="N-1-Problem-N-1-Queries"><a href="#N-1-Problem-N-1-Queries" class="headerlink" title="N+1 Problem (N+1 Queries)"></a>N+1 Problem (N+1 Queries)</h4><p>以下面程式碼為範例，並有以下前提：</p>
<ol>
<li>使用 Entity Framework Core 作為 ORM。</li>
<li>啟用 Lazy Loading。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 1 Query.</span></span><br><span class="line">    <span class="keyword">var</span> authors = context.Authors.ToList();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> author <span class="keyword">in</span> authors)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// Additional N Queries.</span></span><br><span class="line">        <span class="keyword">var</span> books = author.Books;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的範例中總共會產生 1 (<code>context.Authors</code>) + N (<code>author.Books</code>) 次查詢。也就是說如果資料庫中有 1000 個作者，就會先執行一次查詢來查出所有作者資訊，並<strong>在迴圈中額外查詢 1000 次各個作者的著作</strong>。  </p>
<p>而正確的做法應該如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> AppDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// A single query.</span></span><br><span class="line">    <span class="keyword">var</span> authorsWithBooks = context.Authors</span><br><span class="line">                                  .Include(a =&gt; a.Books)</span><br><span class="line">                                  .ToList();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> author <span class="keyword">in</span> authorsWithBooks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No additional queries are executed here.</span></span><br><span class="line">        <span class="keyword">var</span> books = author.Books;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這個做法在一開始查詢出作者時，也將所有作者的著作查詢出來，迴圈中就只是存取記憶體中的資料，如果資料庫中有 1000 個作者，相當於省下了 1000 次額外查詢。</p>
<h4 id="濫用-Lazy-Loading"><a href="#濫用-Lazy-Loading" class="headerlink" title="濫用 Lazy Loading"></a>濫用 Lazy Loading</h4><p>如果沒有注意 Lazy Loading 的特性就很容易在存取 Model 的過程，不經意的造成大量的額外查詢。例如下面範例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The 1st query.</span></span><br><span class="line">    <span class="keyword">var</span> author = context.Authors.FirstOrDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 2nd query.</span></span><br><span class="line">	<span class="keyword">var</span> books = author.Books;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 3rd query</span></span><br><span class="line">	<span class="keyword">var</span> awards = author.Awards;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Much more queries via navigations.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Entity Framework Core 預設不啟用 Lazy Loading 就讓我覺得很放心，即使是資淺同事也不容易誤用。</p>
</blockquote>
<h4 id="LINQ-查詢所翻譯出來的-SQL-不夠理想"><a href="#LINQ-查詢所翻譯出來的-SQL-不夠理想" class="headerlink" title="LINQ 查詢所翻譯出來的 SQL 不夠理想"></a>LINQ 查詢所翻譯出來的 SQL 不夠理想</h4><p>既然 ORM 的功能之一是將 LINQ 翻譯成 SQL，就應該適時的開啟相應的 Log 功能來印出翻譯結果，並試著透過調整 LINQ 語句來得到更理想的 SQL。</p>
<h4 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h4><p>在分析 ORM 的效能影響時，先確定不是誤用造成的效能瓶頸再來討論 ORM 本身對效能的影響會比較恰當。</p>
<h3 id="資料庫與-SQL-效能"><a href="#資料庫與-SQL-效能" class="headerlink" title="資料庫與 SQL 效能"></a>資料庫與 SQL 效能</h3><p>ORM 能做的就是翻譯，除了翻譯效果不理想的因素外，另外一個面向是從資料庫與 SQL 本身來排查。</p>
<h4 id="Cartesian-Explosion-笛卡兒爆炸"><a href="#Cartesian-Explosion-笛卡兒爆炸" class="headerlink" title="Cartesian Explosion (笛卡兒爆炸)"></a>Cartesian Explosion (笛卡兒爆炸)</h4><p>這是很經典的問題，網路上資源很多所以這邊就用個範例簡介一下就好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Count: 1 AUTHORS * N BOOKS * M AWARDS</span></span><br><span class="line"><span class="keyword">SELECT</span> a.NAME <span class="keyword">AS</span> AUTHOR_NAME, b.TITLE <span class="keyword">AS</span> BOOK_TITLE, aw.AWARD_NAME <span class="keyword">AS</span> AWARD_NAME</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">AUTHORS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> BOOKS b <span class="keyword">ON</span> a.AUTHOR_ID = b.AUTHOR_ID</span><br><span class="line"><span class="keyword">JOIN</span> AWARDS aw <span class="keyword">ON</span> a.AUTHOR_ID = aw.AUTHOR_ID;</span><br><span class="line">WHERE a.NAME = 'John Smith'</span><br></pre></td></tr></table></figure>
<p>假設這個作者關聯 20 本書且他得了 10 個獎項，上面的查詢會查出 200 (10 * 20) 筆資料，依此類推，這個現象在星型架構(Star Schema)的情境會更明顯。但如果我們把它拆成兩個查詢如下，則只會產生總共 30 (10 + 20) 筆資料。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Count: 1 AUTHORS * N BOOKS</span></span><br><span class="line"><span class="keyword">SELECT</span> a.AUTHOR_ID, a.NAME <span class="keyword">AS</span> AUTHOR_NAME, b.TITLE <span class="keyword">AS</span> BOOK_TITLE</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">AUTHORS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> BOOKS b <span class="keyword">ON</span> a.AUTHOR_ID = b.AUTHOR_ID</span><br><span class="line"><span class="keyword">WHERE</span> a.NAME = <span class="string">'John Smith'</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Count: 1 AUTHORS * M AWARDS</span></span><br><span class="line"><span class="keyword">SELECT</span> a.AUTHOR_ID, a.NAME <span class="keyword">AS</span> AUTHOR_NAME, aw.AWARD_NAME <span class="keyword">AS</span> AWARD_NAME</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">AUTHORS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> AWARDS aw <span class="keyword">ON</span> a.AUTHOR_ID = aw.AUTHOR_ID</span><br><span class="line"><span class="keyword">WHERE</span> a.NAME = <span class="string">'John Smith'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>雖然一般情況下，較少的查詢次數能帶來更好的效能，但在笛卡兒爆炸問題下，需要視情況拆分查詢以避免過多資料造成記憶體負擔。大量資料除了對記憶體是負擔外，應用程式處理這些資料也會拖慢執行時間。在極端情況下，多次查詢可能遠快於一次引發笛卡兒爆炸的查詢。</p>
</blockquote>
<h4 id="執行計劃-Execution-Plan"><a href="#執行計劃-Execution-Plan" class="headerlink" title="執行計劃 (Execution Plan)"></a>執行計劃 (Execution Plan)</h4><p>透過執行計劃查看查詢執行的過程，能夠有效的判定出主要效能問題。常見的解決方案如下：</p>
<p><strong>Index</strong><br>最常見的處理方式，適當的索引能大幅提升查詢速度，而索引種類與細節非常多，需要另外花時間研究。</p>
<p><strong>Partition</strong><br>索引不是萬能，當一張表的資料量與查詢範圍夠大時，即使使用 Index 進行範圍查詢也會造成效能低落的問題，這時候 Partition (以 Oracle 來說) 就能有效的進一步提升查詢效能。</p>
<blockquote>
<p>另一個概念是分片(Shard)，<a href="https://medium.com/@_amanarora/partitioning-sharding-choosing-the-right-scaling-method-dbc6b2bec1d5" target="_blank" rel="noopener">兩者差異參考其他資料</a></p>
</blockquote>
<p><strong>資料歸檔(Archive)</strong><br>將少用的資料 (通常是舊資料) 分散到其他資料庫中，減少常用資料庫中的資料量。但這個策略很依賴商務層面使用資料的方式，只在存在少用資料時才有用。  </p>
<p>另外這個做法很複雜：</p>
<ol>
<li>首先要先制定資料遷移的時間和相關操作，如果要不停機遷移難度會更高。</li>
<li>查詢時，如果少用資料終究還是要用到，那應用程式中查詢就要考慮兩個資料庫來源，非常麻煩。</li>
<li>承上，跨資料庫查詢對於需要排序與分頁的功能來說是難以跨越的障礙，這個限制會直接限縮這個解法的適用範圍。</li>
</ol>
<h4 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h4><p>資料庫和 SQL 分析範圍很廣，這邊提的是我見過的部分。  </p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>會想寫這篇是因為在面對效能問題時，常見到找不到真正的瓶頸但卻花很多精神在微小的改善上的情況，或是沒意識到誤用工具而棄用工具，實在很可惜。  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://medium.com/@_amanarora/partitioning-sharding-choosing-the-right-scaling-method-dbc6b2bec1d5" target="_blank" rel="noopener">Partitioning &amp; Sharding — choosing the right scaling method</a>  </p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Entity Framework Core 預熱]]></title>
      <url>/content/20240512-ef-core-warmup.html</url>
      <content type="html"><![CDATA[<p>在使用 Entity Framework Core (EF Core) 進行資料存取操作時，初次查詢時會有耗時較長的現象。這種延遲主要是因為 EF Core 在第一次執行查詢時需要進行一系列的初始化步驟。這些步驟造成的延遲可能會對效能敏感的應用程式造成不利的影響。例如在 WebAPI 服務中，如果初始化花費太多時間可能造成連線超時。而且在效能監測時，這種初始化所造成的延遲可能會產生極端的執行時間資料影響到效能的解讀。</p>
<p>為了解決這個問題，通常會在應用程式啟動階段加入一些預熱的操作，以提前完成一些必要的初始化步驟。這篇文章會介紹兩種預熱解法，<strong>要注意的是這兩個解法不是針對所有的初始化步驟，目的只是要達到觸發 <code>DbContext.OnModelCreating()</code> 的效果來降低首次查詢的延遲時間</strong>。</p>
<a id="more"></a>
<h3 id="解法一：-dbContext-Set-lt-T-gt"><a href="#解法一：-dbContext-Set-lt-T-gt" class="headerlink" title="解法一： dbContext.Set&lt;T&gt;"></a>解法一： <code>dbContext.Set&lt;T&gt;</code></h3><p>以 ASP.NET Core 來說，在 <code>Startup.cs</code> 中的 <code>Configure</code> 方法中注入 <code>DbContext</code> 來達到效果是最常見的作法，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, DbContext dbContext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Warmup operation, trigger DbContext.OnModelCreating() to reduce the initialization delay on first query.</span></span><br><span class="line">    dbContext.Set&lt;Blog&gt;().FirstOrDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這是最簡單的解法，但特定的 Model 進而產生額外的依賴這個缺點會帶來幾個風險和限制：</p>
<ul>
<li>該 Model 被移除時看似無關的預熱功能也需要一併修改而使用其他 Model。</li>
<li>會需要特別寫註解說明目的，否則後期維護時很可能被誤當成多餘的程式碼而刪除，最麻煩的是刪除後短期內可能還不會產生明顯的問題。</li>
<li>難以通用化，例如公司內部如果有通用套件時，會因為依賴特定資料庫對應的 Model 而無法將預熱功能加入其中。</li>
</ul>
<h3 id="解法二：-ExecuteSqlRaw"><a href="#解法二：-ExecuteSqlRaw" class="headerlink" title="解法二： ExecuteSqlRaw()"></a>解法二： <code>ExecuteSqlRaw()</code></h3><p>為了避免解法一所產生的副作用，可以用執行一個和資料表無關的查詢達到效果，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, DbContext dbContext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Warmup operation, trigger DbContext.OnModelCreating() to reduce the initialization delay on first query.</span></span><br><span class="line">    dbContext.Database.ExecuteSqlRaw(<span class="string">"SELECT 1 FROM DUAL"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這個解法解決了依賴特定的 Model，這個優點帶來了很大的通用性。以我遇到的情境來說，能輕易的將預熱功能抽離到內部套件中提供跨部門同事使用，如下範例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In internal library.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">namespace</span> <span class="title">MyCompany.EFCoreEnhancement</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DbContextExtension</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Warmup</span>(<span class="params"><span class="keyword">this</span> DbContext context</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            context.Database.ExecuteSqlRaw(<span class="string">"SELECT 1 FROM DUAL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In application using the internal library.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, DbContext dbContext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dbContext.Warmup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>一般來說除非已有現成 API 可用，否則不建議一開始就做預熱功能。如果要做則是視使用情境，單一專案或存取單一資料庫的情境解法一加註解就很夠用了。解法二則是基於最大化通用性的考量設計的，這個方案在把預熱功能抽離到通用套件時才有明顯的優勢。</p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Packages </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[為什麼陣列索引的存取是常數時間複雜度 O(1)]]></title>
      <url>/content/20240427-why-access-array-index-constant-time.html</url>
      <content type="html"><![CDATA[<p>可能只有我不知道，但是不記下來又覺得需要解釋的時候會解釋不出來。</p>
<a id="more"></a>
<p>陣列是在程式設計中常見的資料結構，將多個<strong>固定大小</strong>的元素存放在<strong>連續的記憶體位址</strong>中，而這段記憶體的<strong>起始位址是已知的</strong>。當要存取陣列中的某個元素時就能透過起始位址加上偏移量來計算出目標元素的記憶體位址，而不需要一個一個的走訪所有元素去找出目標元素。  </p>
<blockquote>
<p>另外，<a href="https://yinwang0.wordpress.com/2013/04/02/indexing" target="_blank" rel="noopener">Why is indexing faster than binary search</a> 這篇文章提到這件事背後與硬體運作有關。</p>
</blockquote>
<p>計算目標元素的記憶體位置公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素位址 = 起始位址 + (目標索引 × 元素大小)</span><br></pre></td></tr></table></figure></p>
<p>由於計算元素位址的過程不依賴於陣列的大小，而僅涉及一次計算操作，因此無論索引大小如何，這個操作的時間都是固定的。這就是為什麼說陣列索引的存取時間複雜度是 O(1)，即常數時間複雜度。  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這是個很小的知識點，寫出來比較像是備忘並幫助我理清思緒，而需要回答這個問題時也能比較順暢的回答。 另一方面參考資料中有很多圖文並茂且深入的講解，透過連結記錄起來需要時也能更深入的了解。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://www.linkedin.com/pulse/how-accessing-array-element-constant-time-prabaharan-balaji-zkj2c/" target="_blank" rel="noopener">How accessing an array element is constant time ?</a><br><a href="https://www.geeksforgeeks.org/why-does-accessing-an-array-element-take-o1-time/" target="_blank" rel="noopener">Why does accessing an Array element take O(1) time?</a><br><a href="http://xahlee.info/comp/why_is_array_access_constant_time.html" target="_blank" rel="noopener">Why is Array Access Constant Time</a><br><a href="https://yinwang0.wordpress.com/2013/04/02/indexing/" target="_blank" rel="noopener">Why is indexing faster than binary search</a>  </p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[責任鏈模式 - Fluent 風格]]></title>
      <url>/content/20240404-fluent-chain-of-responsibility.html</url>
      <content type="html"><![CDATA[<p>一般範例中的責任鏈，負責組合各實作的 Handler 時通常會如下方這樣組合，這樣的做法不管從操作上還是閱讀上都比較不友善：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init</span></span><br><span class="line">IHandler positiveEven = <span class="keyword">new</span> PositiveEvenHandler();</span><br><span class="line">IHandler negativeEven = <span class="keyword">new</span> NegativeEvenHandler();</span><br><span class="line">IHandler positiveOdd = <span class="keyword">new</span> PositiveOddHandler();</span><br><span class="line">IHandler negativeOdd = <span class="keyword">new</span> NegativeOddHandler();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line">positiveEven.SetNext(negativeEven);</span><br><span class="line">negativeEven.SetNext(positiveOdd);</span><br><span class="line">positiveOdd.SetNext(negativeOdd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the chain</span></span><br><span class="line">positiveEven.Handle(<span class="number">1</span>);</span><br><span class="line">positiveEven.Handle(<span class="number">-1</span>);</span><br><span class="line">positiveEven.Handle(<span class="number">2</span>);</span><br><span class="line">positiveEven.Handle(<span class="number">-2</span>);</span><br></pre></td></tr></table></figure></p>
<p>這篇主要是紀錄透過簡單的修改讓 Handler 能更簡單的組合責任鏈。</p>
<a id="more"></a>
<h3 id="以-Fluent-API-風格組合"><a href="#以-Fluent-API-風格組合" class="headerlink" title="以 Fluent API 風格組合"></a>以 Fluent API 風格組合</h3><p>根據上面的範例，如果能將組合責任鏈改成 Fluent API 風格，能有效提升易用性，如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init and Configure</span></span><br><span class="line">IHandler root = <span class="keyword">new</span> PositiveEvenHandler();</span><br><span class="line">root.SetNext(<span class="keyword">new</span> NegativeEvenHandler())</span><br><span class="line">    .SetNext(<span class="keyword">new</span> PositiveOddHandler())</span><br><span class="line">    .SetNext(<span class="keyword">new</span> NegativeOddHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the chain</span></span><br><span class="line">root.Handle(<span class="number">1</span>);</span><br><span class="line">root.Handle(<span class="number">-1</span>);</span><br><span class="line">root.Handle(<span class="number">2</span>);</span><br><span class="line">root.Handle(<span class="number">-2</span>);</span><br></pre></td></tr></table></figure></p>
<p>而各節點的實作重點則是將 <code>void SetNext(IHandler next)</code> 改成回傳下一個節點的實例 <code>IHandler SetNext(IHandler next)</code>，非常簡單就能讓整個責任鏈更易用，如下範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> number</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PositiveEvenHandler</span> : <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IHandler _nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _nextHandler = handler;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span> &amp;&amp; number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"Positive even number <span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_nextHandler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _nextHandler.Handle(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NegativeEvenHandler</span> : <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IHandler _nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _nextHandler = handler;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; -number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"Negative even number <span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_nextHandler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _nextHandler.Handle(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PositiveOddHandler</span> : <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IHandler _nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _nextHandler = handler;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span> &amp;&amp; number % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"Positive odd number <span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_nextHandler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _nextHandler.Handle(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NegativeOddHandler</span> : <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IHandler _nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _nextHandler = handler;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; -number % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"Negative odd number <span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_nextHandler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _nextHandler.Handle(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他作法-Next-屬性取代-SetNext-方法"><a href="#其他作法-Next-屬性取代-SetNext-方法" class="headerlink" title="其他作法 - Next 屬性取代 SetNext 方法"></a>其他作法 - Next 屬性取代 SetNext 方法</h3><p>也是個簡化組合的程式碼的方式，但這種方式當整個責任鏈很長時可讀性稍差，搭配 DI 操作起來也不太順暢。 但優點就是直接用自動實作屬性就好，不用再額外實作 SetNext 方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IHandler chain = <span class="keyword">new</span> PositiveEvenHandler</span><br><span class="line">&#123;</span><br><span class="line">    Next = <span class="keyword">new</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Next = <span class="keyword">new</span> NegativeEvenHandler</span><br><span class="line">        &#123;</span><br><span class="line">            Next = <span class="keyword">new</span> PositiveOddHandler</span><br><span class="line">            &#123;</span><br><span class="line">                Next = <span class="keyword">new</span> NegativeOddHandler&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>之前的文章提到過的，設計模式只是個樣板，實務上應該針對語言特性與應用場景做適當的調整。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://ad57475747.medium.com/design-pattern-%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F-chain-of-responsibility-pattern-29757935134e" target="_blank" rel="noopener">Design Pattern— 責任鏈模式(Chain of Responsibility Pattern)</a>  </p>
]]></content>
      
        <categories>
            
            <category> DesignPatterns </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 語言特性更新 - C# 8]]></title>
      <url>/content/20240324-whats-new-in-csharp-8.html</url>
      <content type="html"><![CDATA[<p>C# 各版本新特性摘要，包含自己的想法與實務上的偏好。</p>
<a id="more"></a>
<h3 id="唯獨成員-Readonly-members"><a href="#唯獨成員-Readonly-members" class="headerlink" title="唯獨成員 (Readonly members)"></a>唯獨成員 (Readonly members)</h3><p>允許在結構 (struct) 成員上單獨使用 <code>readonly</code> 修飾詞。<br>其中有一些精細的限制，違反的話會有 Warning 或因而無法編譯，所以不用刻意去記。</p>
<h3 id="預設介面方法-Default-interface-methods"><a href="#預設介面方法-Default-interface-methods" class="headerlink" title="預設介面方法 (Default interface methods)"></a>預設介面方法 (Default interface methods)</h3><p>介面中可以有預設實作方法，打破以前介面無法實作的限制。<br>主要的優點是讓 API 開發者可以在後續版本上加上新的介面方法而不會造成破壞性變更 (Breakin Changes)，算是方便但是預設介面方法有很多限制，並不是表面上的 “介面中的方法可以有實作內容” 這麼單純，這個之後再另外發文探討。而這個特性除了方便外，也會讓介面和抽象方法之間的界線更為模糊，這時候設計的時候就應該更從物件導向設計的角度來決定兩者的使用時機，而不單單只是看語言特性的差異。  </p>
<h3 id="擴大模式比對的應用-More-patterns-in-more-places"><a href="#擴大模式比對的應用-More-patterns-in-more-places" class="headerlink" title="擴大模式比對的應用 (More patterns in more places)"></a>擴大模式比對的應用 (More patterns in more places)</h3><p>模式比對從 C# 8 後更新的非常迅速，五花八門琳瑯滿目的很多，如果不是要看變更歷程的話，推薦直接看完整教學：</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching" target="_blank" rel="noopener">Pattern matching overview</a>  </li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns" target="_blank" rel="noopener">Patterns</a></li>
</ul>
<h4 id="switch-運算式-Switch-expressions"><a href="#switch-運算式-Switch-expressions" class="headerlink" title="switch 運算式 (Switch expressions)"></a><code>switch</code> 運算式 (Switch expressions)</h4><p>讓 <code>switch</code> 語句更精簡，如下範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">    Yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetColorHex</span>(<span class="params">Color color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color <span class="keyword">switch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Color.Red =&gt; <span class="string">"#FF0000"</span>,</span><br><span class="line">        Color.Green =&gt; <span class="string">"#00FF00"</span>,</span><br><span class="line">        Color.Blue =&gt; <span class="string">"#0000FF"</span>,</span><br><span class="line">        Color.Yellow =&gt; <span class="string">"#FFFF00"</span>,</span><br><span class="line">		<span class="comment">// Default</span></span><br><span class="line">        _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(color), color, <span class="literal">null</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這不只是語法外觀的改變，switch 區塊的主體也變成了運算式 (Expression)，而不是以前的陳述式 (Statement)。</p>
<h4 id="屬性模式-Property-patterns-、Tuple-模式-Tuple-patterns-、位置模式-Positional-patterns"><a href="#屬性模式-Property-patterns-、Tuple-模式-Tuple-patterns-、位置模式-Positional-patterns" class="headerlink" title="屬性模式 (Property patterns)、Tuple 模式 (Tuple patterns)、位置模式 (Positional patterns)"></a>屬性模式 (Property patterns)、Tuple 模式 (Tuple patterns)、位置模式 (Positional patterns)</h4><p>雖然命名上是 Property patterns，但他的意思不是在 Property 上使用模式比對，而是使用模式比對時可以針對目標型別的屬性來比對。大概就是用一堆符號來表達對屬性的型別、值範圍等判斷，主訴是程式碼的簡潔。  </p>
<p>Tuple 模式和位置模式依此類推。</p>
<h3 id="using-宣告-Using-declarations"><a href="#using-宣告-Using-declarations" class="headerlink" title="using 宣告 (Using declarations)"></a><code>using</code> 宣告 (Using declarations)</h3><p>不同於以往的<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> foo = <span class="keyword">new</span> Foo())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Somthing to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而改用<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">// Somthing to do</span></span><br></pre></td></tr></table></figure></p>
<p>差別在於以往我們要將 <code>using</code> 區塊另外框起來，常常需要處理區塊內宣告的參數在區塊外無法使用的問題，不難但很雜，且經常被迫要把宣告與賦值分開，程式碼就比較亂，差異如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> foo = <span class="keyword">new</span> Foo())</span><br><span class="line">&#123;</span><br><span class="line">    v1 = foo.GetV1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v2 = v1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">// Place only code related to "foo" in this scope to make it disposed ASAP.</span></span><br><span class="line"><span class="keyword">var</span> v1 = foo.GetV1();</span><br><span class="line"><span class="keyword">var</span> v2 = v1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如上範例註解所示，在新的語法中我們不用關心區塊，區塊範圍會在編譯時期決定，但相對的就是要注意 <code>using</code> 宣告的變數應該盡早使用，避免在中間放其他無關程式碼造成實際的 <code>using</code> 區塊太大。</p>
<h3 id="靜態區域函式-Static-local-functions"><a href="#靜態區域函式-Static-local-functions" class="headerlink" title="靜態區域函式 (Static local functions)"></a>靜態區域函式 (Static local functions)</h3><p>靜態區域函式能讓我們的區域函式不捕捉外層的變數，但這部分是透過 Warning <code>CS8421</code> 來達到的。  </p>
<p>區域函式的變數捕捉特性會產生關注點發散到外層方法的副作用，又因為預設會自動捕捉外層的變數導致平常開發時很難確保所需資訊都由參數列提供而不是透過變數捕捉，靜態區域函式的特點可以有效避免這個困擾。</p>
<h3 id="ref-struct-可實作-IDisposable-Disposable-ref-structs"><a href="#ref-struct-可實作-IDisposable-Disposable-ref-structs" class="headerlink" title="ref struct 可實作 IDisposable (Disposable ref structs)"></a><code>ref struct</code> 可實作 <code>IDisposable</code> (Disposable ref structs)</h3><p>就字面上的意思，同時也適用 <code>readonly ref struct</code>。</p>
<h3 id="可為-Null-的參考型別-Nullable-reference-types"><a href="#可為-Null-的參考型別-Nullable-reference-types" class="headerlink" title="可為 Null 的參考型別 (Nullable reference types)"></a>可為 Null 的參考型別 (Nullable reference types)</h3><p>參考型別本來就可以是 Null，這個特性使得參考型別編譯時被視為不可為 Null，並由編譯器分析是否可能誤用使其值為 <code>null</code>。<br>看起來是在空值判斷這個議題上，透過強制規範迫使開發者嚴格檢視空值情境，如果在已有嚴格規範的專案上使用有錦上添花的效果，但如果現有專案規範與品質不夠或開發習慣不嚴謹，啟用這個特性幫助不大，甚至適得其反讓程式碼風格更不一致。  </p>
<h3 id="非同步資料流-Asynchronous-streams"><a href="#非同步資料流-Asynchronous-streams" class="headerlink" title="非同步資料流 (Asynchronous streams)"></a>非同步資料流 (Asynchronous streams)</h3><p>雖然名字有 streams 字眼，但他和 <code>Stream</code> 型別無關，是提供非同步迭代的一種特性。 </p>
<p>如下方範例程式，有幾個關鍵：</p>
<ol>
<li><code>async</code> 方法</li>
<li>回傳 <code>IAsyncEnumerable&lt;T&gt;</code></li>
<li>呼叫端迭代時需要在前面加 <code>await</code> 關鍵字，不限定使用 <code>foreach</code> 的情境，在自己操作迭代器的情境也適用如 <code>await using var enumerator = numberGenerator.GetAsyncEnumerator();</code>。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GenerateNumbersAsync</span>(<span class="params"><span class="number">5</span></span>))</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GenerateNumbersAsync</span>(<span class="params"><span class="keyword">int</span> count</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面範例每秒都能回傳一個結果，但以前通常只能等到 <code>GenerateNumbersAsync()</code> 完成再一次回傳如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt; GenerateNumbersAsync(<span class="keyword">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> numbers = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">        numbers.Add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Doesn't work, returns `IEnumerable&lt;Task&lt;int&gt;&gt;` also doesn't work.</span></span><br><span class="line"><span class="comment">// static async Task&lt;IEnumerable&lt;int&gt;&gt; GenerateNumbersAsync(int count)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; count; i++)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         await Task.Delay(1000);</span></span><br><span class="line"><span class="comment">//         yield return i;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>而根據 ChatGPT 的範例，不使用這個特性要每秒都能回傳一個結果的話，程式碼就會像下面這樣難以閱讀：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> GenerateNumbersAsync(<span class="number">5</span>, <span class="keyword">async</span> number =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(number);</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">GenerateNumbersAsync</span>(<span class="params"><span class="keyword">int</span> count, Func&lt;<span class="keyword">int</span>, Task&gt; processNumber</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> processNumber(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="IAsyncDisposable-Asynchronous-disposable"><a href="#IAsyncDisposable-Asynchronous-disposable" class="headerlink" title="IAsyncDisposable (Asynchronous disposable)"></a><code>IAsyncDisposable</code> (Asynchronous disposable)</h3><p>如字面上的非同步 dispose，上面的非同步資料流中提到的 <code>IAsyncEnumerable&lt;T&gt;</code> 就繼承自 <code>IAsyncDisposable</code>。</p>
<h3 id="索引和範圍-Indices-and-ranges"><a href="#索引和範圍-Indices-and-ranges" class="headerlink" title="索引和範圍 (Indices and ranges)"></a>索引和範圍 (Indices and ranges)</h3><p>用更簡潔的語法表達索引和範圍，提供兩個新的型別 <code>System.Index</code> 和 <code>System.Range</code>，並透過 <code>^</code> (倒數) 和 <code>..</code> (到) 符號來使用。 要注意的是第一個是 <code>0</code>，但倒數第一個是 <code>^1</code> 。  </p>
<p>歸納一下規則：</p>
<ol>
<li><code>^n</code> 是倒數第 n 個 (即 <code>sequence[sequence.Length - n]</code> 的概念)。</li>
<li><code>x..y</code> 是索引 x (包含) 到索引 y (不包含)，省略 x 代表從頭開始。省略 y 代表到底為止。 x 和 y 可以是 ^m 和 ^n 這樣表示。 索引 x 必須小於或等於索引 y，而 ^m 和 ^n 推論成 x 和 y 後亦同。</li>
</ol>
<p>範例如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str = <span class="string">"This is a book."</span>;</span><br><span class="line">Index first = <span class="number">0</span>;</span><br><span class="line">Index firstFromEnd = ^<span class="number">1</span>;</span><br><span class="line">str[first].Dump(); <span class="comment">// T</span></span><br><span class="line">str[firstFromEnd].Dump(); <span class="comment">// .</span></span><br><span class="line">str[<span class="number">0</span>].Dump(); <span class="comment">// T</span></span><br><span class="line">str[^<span class="number">1</span>].Dump(); <span class="comment">// .</span></span><br><span class="line"></span><br><span class="line">Range range = <span class="number">10.</span><span class="number">.14</span>;</span><br><span class="line">Range rangeFromEnd = ^<span class="number">5.</span>.^<span class="number">1</span>;</span><br><span class="line">str[range].Dump(); <span class="comment">// book</span></span><br><span class="line">str[rangeFromEnd].Dump(); <span class="comment">// book</span></span><br><span class="line">str[<span class="number">10.</span><span class="number">.14</span>].Dump(); <span class="comment">// book</span></span><br><span class="line">str[^<span class="number">5.</span>.^<span class="number">1</span>].Dump(); <span class="comment">// book</span></span><br><span class="line"></span><br><span class="line">str[<span class="number">5.</span>.^<span class="number">8</span>].Dump(); <span class="comment">// is</span></span><br><span class="line">str[^<span class="number">10.</span><span class="number">.7</span>].Dump(); <span class="comment">// is</span></span><br><span class="line"></span><br><span class="line">str[.<span class="number">.7</span>].Dump(); <span class="comment">// This is</span></span><br><span class="line">str[<span class="number">10.</span>.].Dump(); <span class="comment">// book.</span></span><br><span class="line">str[<span class="number">0.</span>.^<span class="number">0</span>].Dump(); <span class="comment">// This is a book.</span></span><br><span class="line">str[..].Dump(); <span class="comment">// This is a book.</span></span><br></pre></td></tr></table></figure></p>
<p>雖然正向和倒數可以混用，但不要濫用不然可讀性也會差。</p>
<h3 id="Null-coalescing-assignment"><a href="#Null-coalescing-assignment" class="headerlink" title="??= (Null-coalescing assignment)"></a><code>??=</code> (Null-coalescing assignment)</h3><p>範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message ??= <span class="string">"Default Message"</span>;</span><br></pre></td></tr></table></figure></p>
<p>同義於<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (message == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    message = <span class="string">"Default Message"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非託管結構型別-Unmanaged-constructed-types"><a href="#非託管結構型別-Unmanaged-constructed-types" class="headerlink" title="非託管結構型別 (Unmanaged constructed types)"></a>非託管結構型別 (Unmanaged constructed types)</h3><p>如果結構只包含非託管型別的屬性時，該結構也是非託管型別。  </p>
<h3 id="巢狀運算式中的-Stackalloc-Stackalloc-in-nested-expressions"><a href="#巢狀運算式中的-Stackalloc-Stackalloc-in-nested-expressions" class="headerlink" title="巢狀運算式中的 Stackalloc (Stackalloc in nested expressions)"></a>巢狀運算式中的 Stackalloc (Stackalloc in nested expressions)</h3><p>如果 stackalloc 運算式的結果是 <code>Span&lt;T&gt;</code> 或 <code>ReadOnlySpan&lt;T&gt;</code> 就可以不用另外指派給另外一個變數，如下範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">stackalloc</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In earlier version:</span></span><br><span class="line"><span class="comment">// Span&lt;int&gt; searchNumbers = stackalloc[] &#123; 2, 4, 6, 8 &#125;;</span></span><br><span class="line"><span class="comment">// var idx = numbers.IndexOfAny(searchNumbers);</span></span><br><span class="line"><span class="comment">// Now:</span></span><br><span class="line"><span class="keyword">var</span> idx = numbers.IndexOfAny(<span class="keyword">stackalloc</span>[] &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="擴充內插逐字字串-Enhancement-of-interpolated-verbatim-strings"><a href="#擴充內插逐字字串-Enhancement-of-interpolated-verbatim-strings" class="headerlink" title="擴充內插逐字字串 (Enhancement of interpolated verbatim strings)"></a>擴充內插逐字字串 (Enhancement of interpolated verbatim strings)</h3><p>可支援 <code>$@&quot;...&quot;</code> 和 <code>@$&quot;...&quot;</code>，順序不會造成編譯錯誤。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://web.archive.org/web/20211203061114/https://docs.microsoft.com/en-gb/dotnet/csharp/whats-new/csharp-8" target="_blank" rel="noopener">What’s new in C# 8.0 (原文件已經被刪除，這是 Archive 網站的存檔)</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 語言特性更新 - C# 7]]></title>
      <url>/content/20240203-whats-new-in-csharp-7.html</url>
      <content type="html"><![CDATA[<p>C# 各版本新特性摘要，包含自己的想法與實務上的偏好。</p>
<p>C# 7 系列比較特殊，總共經過 7.0、7.1、7.2、7.3 四個版本，且範圍有高度重疊，所以這邊不分開看，直接依照 2021 年版官方整合過的文件將 C# 7 的新特性一起看。</p>
<a id="more"></a>
<h3 id="Tuples-和-Discards"><a href="#Tuples-和-Discards" class="headerlink" title="Tuples 和 Discards"></a>Tuples 和 Discards</h3><h4 id="具名-Tuple"><a href="#具名-Tuple" class="headerlink" title="具名 Tuple"></a>具名 Tuple</h4><p>以前的 Tuple 沒辦法具名，所以會產生很多 <code>tuple.Item1</code> 這類的呼叫，嚴重影響程式碼的可讀性，具名 Tuple 出現後很大程度解決了這個問題，如下範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> (<span class="keyword">int</span> Id, <span class="keyword">string</span> Name) GetPerson()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, <span class="string">"Ron"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line"><span class="keyword">var</span> user = GetPerson();</span><br><span class="line"><span class="string">$"ID: <span class="subst">&#123;user.Id&#125;</span>, Name: <span class="subst">&#123;user.Name&#125;</span>"</span>.Dump(); <span class="comment">// ID: 1, Name: Ron</span></span><br></pre></td></tr></table></figure></p>
<p>但這也衍生出另外一個問題就是命名風格，這邊我建議依照呼叫端的使用方式來決定，以本例來說，呼叫端使用上像是將他視為屬性，因此使用雙駝峰。但如果像下面的情境，就應該使用單駝峰，因為呼叫端使用上像是區域變數：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> id, <span class="keyword">var</span> name) = (<span class="number">1</span>, <span class="string">"Ron"</span>);</span><br><span class="line"><span class="string">$"ID: <span class="subst">&#123;id&#125;</span>, Name: <span class="subst">&#123;name&#125;</span>"</span>.Dump(); <span class="comment">// ID: 1, Name: Ron</span></span><br></pre></td></tr></table></figure></p>
<p>另外還要注意這種風格的 Tuple 其實背後是編譯成 <code>System.ValueTuple</code> 而不是傳統的 <code>System.Tuple</code>，<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples#tuples-vs-systemtuple" target="_blank" rel="noopener">這兩種型別有一些差異</a>。  </p>
<h4 id="Discards"><a href="#Discards" class="headerlink" title="Discards"></a>Discards</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> (<span class="keyword">int</span> Id, <span class="keyword">string</span> Name, <span class="keyword">string</span> Address) GetPerson()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, <span class="string">"Ron"</span>, <span class="string">"My Home"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller, discard the Address</span></span><br><span class="line">(<span class="keyword">var</span> id, <span class="keyword">var</span> name, _) = GetPerson();</span><br><span class="line"><span class="string">$"ID: <span class="subst">&#123;id&#125;</span>, Name: <span class="subst">&#123;name&#125;</span>"</span>.Dump(); <span class="comment">// ID: 1, Name: Ron</span></span><br></pre></td></tr></table></figure>
<p>如上範例，用不到的變數可以用一個底線 <code>_</code> 取代，可以讓維護的人不用關注無用的資訊。但這也不是他唯一的使用情境，詳細情境參考<a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards" target="_blank" rel="noopener"> Discards 官方文件</a>。</p>
<h4 id="C-怎麼處理-Tuple-的名字"><a href="#C-怎麼處理-Tuple-的名字" class="headerlink" title="C# 怎麼處理 Tuple 的名字?"></a>C# 怎麼處理 Tuple 的名字?</h4><p>將一段簡單的程式碼編譯後，透過反組譯工具反組譯回低版本的 C# 可以發現，最後還是呼叫 <code>Item1</code>、<code>Item2</code>，所以具名 Tuple 其實是一種編譯時期的語法糖。</p>
<h4 id="解構-Deconstruction"><a href="#解構-Deconstruction" class="headerlink" title="解構 (Deconstruction)"></a>解構 (Deconstruction)</h4><p>雖然解構看起來是另外一個主題了，但可能是因為 Tuple、Discards、解構，三者太常互相搭配使用，官方文件中是將他和 Discards 放在一起的，解構不只能套用到 Tuple 還能透過實作 <code>Deconstruct</code> 方法套用到其他型別上。  </p>
<p>直接看 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards" target="_blank" rel="noopener">Discards</a> 和 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct" target="_blank" rel="noopener">Deconstructing tuples and other types</a> 來了解會更全面。  </p>
<p>這邊要注意一下，寫這篇文章時 C# 已經更新到 12 版了，官方的規格介紹中會夾很多後面版本新增的特性。  </p>
<h3 id="模式比對-Pattern-matching"><a href="#模式比對-Pattern-matching" class="headerlink" title="模式比對 (Pattern matching)"></a>模式比對 (Pattern matching)</h3><p>這個功能比較像是為了可讀性的擴充，主要用途在於用 <code>is</code> 關鍵字來做型別確認與轉換；用 <code>when</code> 關鍵字來做附加條件判斷；額外搭配 <code>switch</code> 來透過簡單的語法達到複雜的運用。</p>
<h4 id="is-關鍵字"><a href="#is-關鍵字" class="headerlink" title="is 關鍵字"></a><code>is</code> 關鍵字</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do somthing using i.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="keyword">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do somthing using s.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從上述範例可以看到以前需要先透過 <code>is</code> 判斷型別後再轉型 (或使用 <code>as</code> 後再判斷空值後處理)，現在可以將兩個行為合一讓可維護性提高很多。</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span> i:</span><br><span class="line">            <span class="comment">// Do somthing using i.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span> s:</span><br><span class="line">            <span class="comment">// Do somthing using s.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DateTime dt when dt.Year == <span class="number">2021</span>:</span><br><span class="line">            <span class="comment">// Do somthing using dt which contains Year is 2021.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">            <span class="comment">// Do somthing for null scenario.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Default behavior.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從上述範例可以看到，<code>switch</code> 關鍵字在使用上能更有彈性的設定條件了。  </p>
<p>這個規格依然是編譯時期的語法糖， <code>switch</code> 本身的限制並沒有改變，上面的範例編譯後其實是 <code>if</code>、<code>else if</code>、<code>else</code> 條件式的組合。</p>
<h3 id="Async-main"><a href="#Async-main" class="headerlink" title="Async main"></a>Async main</h3><p>在 Main 上可以加上 <code>async</code> 關鍵字了。<br>比較意外的是這也是語法糖，<a href="https://blog.miniasp.com/post/2019/04/03/Deep-Dive-CSharp-71-async-Main-method" target="_blank" rel="noopener">保哥有一篇文章提供詳細的說明</a>。</p>
<h3 id="區域函式-Local-functions"><a href="#區域函式-Local-functions" class="headerlink" title="區域函式 (Local functions)"></a>區域函式 (Local functions)</h3><p>區域函式允許一個方法中包含另外一個方法，而區域函式只能被包含他的方法呼叫。這個設計主要用於迭代器和非同步方法中。  </p>
<h4 id="實務使用情境"><a href="#實務使用情境" class="headerlink" title="實務使用情境"></a>實務使用情境</h4><p>而在實務上，在滿足以下條件下，也可考慮使用區域函式：</p>
<ul>
<li><strong>有足夠的理由將該區塊抽離：</strong> 通常這種情境下如果不抽離的話，原方法會過於肥大，以前常見的作法是用 <code>#region</code> 包覆起來，但這種做法對維護沒有太大的幫助。</li>
<li><strong>該方法做為私有方法仍然過於特殊：</strong> 很多時候會有程式碼區塊內容過於特殊，離開主方法後無法封裝成一個方法。  </li>
</ul>
<h4 id="使用注意事項"><a href="#使用注意事項" class="headerlink" title="使用注意事項"></a>使用注意事項</h4><p>區域函式不宜濫用，如果濫用會發現主要方法仍然很肥大，且會增加排版的難度。關於區域函式排版上我自己有幾個建議要點：</p>
<ol>
<li>區域函式集中放在最下方且要在 <code>return</code> 後，這樣區域函式才不會穿插在呼叫端的程式碼中造成更大的混亂。</li>
<li>即使方法無回傳也要在區域函式前加上 <code>return;</code>，用以更明確的區隔呼叫端程式碼和區域函式部分。</li>
</ol>
<p>如下範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">bool</span> c</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a2 = LocalFunction(a);</span><br><span class="line">    <span class="keyword">int</span> ans = c ? LocalFunction(a2 + b) : LocalFunction(a * b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always return at the last line of primary implementation.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local functions</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LocalFunction</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>區域函式也是編譯時期的語法糖且有很多細節要說，尤其是參數傳遞的部分，這部分之後再另外寫一篇來詳細說明。  </p>
<h3 id="更多成員支援運算式主體-More-expression-bodied-members"><a href="#更多成員支援運算式主體-More-expression-bodied-members" class="headerlink" title="更多成員支援運算式主體 (More expression-bodied members)"></a>更多成員支援運算式主體 (More expression-bodied members)</h3><p>運算式主體套用到更多成員上，包含建構子、Finalizer、以及在屬性和索引子上的 <code>get</code> 與 <code>set</code> 存取子，範例如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyContainer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">string</span>&gt; items = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expression-bodied constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyContainer</span>(<span class="params"><span class="keyword">string</span> initialLabel</span>) </span>=&gt; Label = initialLabel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expression-bodied finalizer</span></span><br><span class="line">    ~MyContainer() =&gt; Console.WriteLine(<span class="string">"Finalizing or cleaning up MyContainer."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expression-bodied property get and set accessors</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Label</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; label;</span><br><span class="line">        <span class="keyword">set</span> =&gt; label = <span class="keyword">value</span> ?? <span class="string">"Default label"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expression-bodied indexer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; items[index];</span><br><span class="line">        <span class="keyword">set</span> =&gt; items[index] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers" target="_blank" rel="noopener">Finalizer，舊稱 Destructor</a> 的語法 <code>~</code> 實際上是個語法糖，編譯後其實是 <code>Finalize()</code> 方法。</p>
<h3 id="throw-運算式-Throw-expressions"><a href="#throw-運算式-Throw-expressions" class="headerlink" title="throw 運算式 (Throw expressions)"></a>throw 運算式 (Throw expressions)</h3><p><code>throw</code> 一直都是陳述式 (Statement) 而非運算式 (Expression)，也因此以前很多運算式中無法包含 <code>throw</code> (例如在三元運算子中)，而在 C# 7.0 中新增的 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-throw-expression" target="_blank" rel="noopener">throw 運算式</a> 解決了這個限制。  </p>
<h3 id="預設常值運算式-Default-literal-expressions"><a href="#預設常值運算式-Default-literal-expressions" class="headerlink" title="預設常值運算式 (Default literal expressions)"></a>預設常值運算式 (Default literal expressions)</h3><p><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/default#default-literal" target="_blank" rel="noopener">擴大 <code>default</code> 運算子的適用範圍到運算式上</a>  </p>
<h3 id="數值常值的語法增強功能-Numeric-literal-syntax-improvements"><a href="#數值常值的語法增強功能-Numeric-literal-syntax-improvements" class="headerlink" title="數值常值的語法增強功能 (Numeric literal syntax improvements)"></a>數值常值的語法增強功能 (Numeric literal syntax improvements)</h3><p>允許利用 <code>_</code> 符號來分隔數字而不影響數值本身，類似於千分位符號的功能且同時能套用到二進位數值上，範例如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binary = <span class="number">0</span>b001_0000;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">10</span>_000_000;</span><br><span class="line"><span class="keyword">decimal</span> money = <span class="number">1</span>_000<span class="number">.123</span>_456;</span><br></pre></td></tr></table></figure></p>
<h3 id="out-變數-out-variables"><a href="#out-變數-out-variables" class="headerlink" title="out 變數 (out variables)"></a><code>out</code> 變數 (<code>out</code> variables)</h3><p>可以把 <code>out</code> 變數的宣告和傳遞寫在一起，如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>.TryParse(str, <span class="keyword">out</span> <span class="keyword">int</span> number);</span><br></pre></td></tr></table></figure></p>
<p>這個特性雖然看起來不起眼，但是在實務上對於維護是有非常大的幫助的，他能避免讓變數的宣告和使用的位置距離太遠，如下面範例是實務上常見的痛點。<br>首先看這段程式碼，因為維護或各種關係導致變數 <code>number</code> 和 <code>decimal</code> 的宣告遠離第一次被使用的位置，進而造成閱讀時必須同時關注這麼一大段程式碼並忽略中間穿插的各種雜訊。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unrelated code, making it hard to track 'number'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Loop 1: "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">string</span> temp = <span class="string">"Hello"</span>;</span><br><span class="line">Console.WriteLine(temp.ToUpper());</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Flag is true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decimal</span> money;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unrelated code, making it hard to track 'money'</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Item: "</span> + item);</span><br><span class="line">&#125;</span><br><span class="line">DateTime now = DateTime.Now;</span><br><span class="line">Console.WriteLine(<span class="string">"Current time: "</span> + now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage of 'number' and 'money' is separated from its declaration</span></span><br><span class="line"><span class="keyword">int</span>.TryParse(str, <span class="keyword">out</span> number);</span><br><span class="line"><span class="keyword">decimal</span>.TryParse(str2, <span class="keyword">out</span> money);</span><br></pre></td></tr></table></figure></p>
<p>但套用這個特性，維護過程我們就不用關注那些雜訊而能直接鎖定在真正的目標上。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>.TryParse(str, <span class="keyword">out</span> <span class="keyword">int</span> number);</span><br><span class="line"><span class="keyword">decimal</span>.TryParse(str2, <span class="keyword">out</span> <span class="keyword">decimal</span> money);</span><br></pre></td></tr></table></figure></p>
<p>這個問題的主因是不好的開發習慣，但長期多人開發的專案很難完全避免這個現象。重構和 Code Reivew 能緩解這個問題，但終究是額外的成本，因此從語言特性上直接避免是更理想的。</p>
<h3 id="非後置具名引數-Non-trailing-named-arguments"><a href="#非後置具名引數-Non-trailing-named-arguments" class="headerlink" title="非後置具名引數 (Non-trailing named arguments)"></a>非後置具名引數 (Non-trailing named arguments)</h3><p>具名引數非必要放在最後，例如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In C# 7.1 and earlier, named arguments should be trailing.</span></span><br><span class="line">DisplayPersonDetails(<span class="number">35</span>, <span class="string">"Ron"</span>, city: <span class="string">"New York"</span>);</span><br><span class="line"><span class="comment">// In C# 7.2 and later, named arguments do not necessarily have to be trailing.</span></span><br><span class="line">DisplayPersonDetails(age: <span class="number">35</span>, <span class="string">"Ron"</span>, city: <span class="string">"New York"</span>);</span><br></pre></td></tr></table></figure></p>
<p>這讓我們可以不用為了遷就前排的具名引數而將其後所有引數具名，但從另外一個角度來看，使用具名引數時提高可讀性前應該先思考方法參數列的設計是否需要改善。  </p>
<h3 id="private-protected-存取修飾詞-private-protected-access-modifier"><a href="#private-protected-存取修飾詞-private-protected-access-modifier" class="headerlink" title="private protected 存取修飾詞 (private protected access modifier)"></a><code>private protected</code> 存取修飾詞 (<code>private protected</code> access modifier)</h3><p>限制存取範圍在 <strong><code>protected</code> AND <code>internal</code></strong>，比 <code>protected internal</code> 代表的 <strong><code>protected</code> OR <code>internal</code></strong> 存取範圍更狹窄。  </p>
<h3 id="改善選擇多載的規則-Improved-overload-candidates"><a href="#改善選擇多載的規則-Improved-overload-candidates" class="headerlink" title="改善選擇多載的規則 (Improved overload candidates)"></a>改善選擇多載的規則 (Improved overload candidates)</h3><p>增加三個解析規則來讓更明確的選擇多載。  </p>
<p>老實說我不想特別去記這些複雜的規則，因為這些規則是建立在呼叫多載方法時會混淆的前提，通常這代表多載設計得不夠好，應該優先考慮改善多載方法的設計。</p>
<h3 id="擴充安全程式碼的能力-Enabling-more-efficient-safe-code"><a href="#擴充安全程式碼的能力-Enabling-more-efficient-safe-code" class="headerlink" title="擴充安全程式碼的能力 (Enabling more efficient safe code)"></a>擴充安全程式碼的能力 (Enabling more efficient safe code)</h3><p>幾乎都是沒用過的特性，所以直接看官方文件，沒甚麼好說的。</p>
<h3 id="套用-ref-到區域變數和回傳值上-ref-條件運算式-Ref-locals-and-returns-Conditional-ref-expressions"><a href="#套用-ref-到區域變數和回傳值上-ref-條件運算式-Ref-locals-and-returns-Conditional-ref-expressions" class="headerlink" title="套用 ref 到區域變數和回傳值上 / ref 條件運算式 (Ref locals and returns / Conditional ref expressions)"></a>套用 <code>ref</code> 到區域變數和回傳值上 / <code>ref</code> 條件運算式 (Ref locals and returns / Conditional <code>ref</code> expressions)</h3><p>允許傳址給區域變數，例如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">int</span> two = <span class="keyword">ref</span> numbers[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        two = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(two); <span class="comment">// 0</span></span><br><span class="line">        Console.WriteLine(numbers[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>允許回傳時傳址，例如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">var</span> two = <span class="function"><span class="keyword">ref</span> <span class="title">GetTwo</span>(<span class="params">numbers</span>)</span>;</span><br><span class="line"></span><br><span class="line">        two = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(two); <span class="comment">// 0</span></span><br><span class="line">        Console.WriteLine(numbers[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">ref</span> <span class="keyword">int</span> <span class="title">GetTwo</span>(<span class="params"><span class="keyword">int</span>[] numbers</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ref</span> numbers[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ref</code> 條件運算式，例如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ref</span> <span class="keyword">var</span> i = <span class="keyword">ref</span> (numbers1 != <span class="literal">null</span> ? <span class="keyword">ref</span> numbers1[<span class="number">0</span>] : <span class="keyword">ref</span> numbers2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<p>除非很必要否則我不用 <code>ref</code> 的，因為對於開發、維護人員來說門檻較高且容易被濫用，且到目前為止工作上可以使用 <code>ref</code> 的情境其實都有其他成本不高且低副作用的替代方案。 當然也不是說 <code>ref</code> 不好，相信他在一些效能極度敏感的情境是很有用的。  </p>
<h3 id="in-參數修飾詞"><a href="#in-參數修飾詞" class="headerlink" title="in 參數修飾詞"></a><code>in</code> 參數修飾詞</h3><p>補充現有的 <code>ref</code> 和 <code>out</code>。<br><code>ref</code> 傳址，被呼叫的方法不一定要為其賦值；<code>out</code> 傳址，被呼叫的方法一定要為其賦值，代表這個引數在傳入前賦值通常是沒意義的；<code>in</code> 傳址，被呼叫的方法不能為其賦值。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Do</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">string</span> a, <span class="keyword">out</span> <span class="keyword">string</span> b, <span class="keyword">in</span> <span class="keyword">string</span> c</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Must to have</span></span><br><span class="line">    b = <span class="string">"B"</span>;</span><br><span class="line">    <span class="comment">// Can not assign to "in" parameter.</span></span><br><span class="line">    <span class="comment">// c = "C";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> s1 = <span class="string">"a"</span>;</span><br><span class="line"><span class="comment">// Bad, assignment here generally doesn't make sense.</span></span><br><span class="line"><span class="keyword">string</span> s2 = <span class="string">"b"</span>;</span><br><span class="line"><span class="comment">// Need to have value generally.</span></span><br><span class="line"><span class="keyword">string</span> s3 = <span class="string">"c"</span>;</span><br><span class="line">Do(<span class="keyword">ref</span> s1, <span class="keyword">out</span> s2, <span class="keyword">in</span> s3);</span><br></pre></td></tr></table></figure></p>
<h3 id="更多型別支援-fixed-陳述式-More-types-support-the-fixed-statement"><a href="#更多型別支援-fixed-陳述式-More-types-support-the-fixed-statement" class="headerlink" title="更多型別支援 fixed 陳述式 (More types support the fixed statement)"></a>更多型別支援 <code>fixed</code> 陳述式 (More types support the <code>fixed</code> statement)</h3><p>在 C# 7.3 之後，所有包含 <code>GetPinnableReference()</code> 方法且回傳 <code>ref T</code> 或 <code>ref readonly T</code> 的型別都能套用 <code>fixed</code>。</p>
<h3 id="fixed-索引欄位不需要釘選-Indexing-fixed-fields-does-not-require-pinning"><a href="#fixed-索引欄位不需要釘選-Indexing-fixed-fields-does-not-require-pinning" class="headerlink" title="fixed 索引欄位不需要釘選 (Indexing fixed fields does not require pinning)"></a><code>fixed</code> 索引欄位不需要釘選 (Indexing <code>fixed</code> fields does not require pinning)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">fixed</span> <span class="keyword">int</span> FixedArray[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyStruct myStruct = <span class="keyword">new</span> MyStruct();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Before C# 7, pinning required</span></span><br><span class="line">        <span class="keyword">fixed</span> (<span class="keyword">int</span>* ptr = myStruct.FixedArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// After C# 7, no pinning required</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Direct indexing is now allowed</span></span><br><span class="line">            myStruct.FixedArray[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stackalloc-陣列支援初始設定式-stackalloc-arrays-support-initializers"><a href="#stackalloc-陣列支援初始設定式-stackalloc-arrays-support-initializers" class="headerlink" title="stackalloc 陣列支援初始設定式 (stackalloc arrays support initializers)"></a><code>stackalloc</code> 陣列支援初始設定式 (<code>stackalloc</code> arrays support initializers)</h3><p>C# 7.3 之前：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">stackalloc</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>C# 7.3 之後：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">stackalloc</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="擴充泛型限制"><a href="#擴充泛型限制" class="headerlink" title="擴充泛型限制"></a>擴充泛型限制</h3><p>可以限制 <code>System.Enum</code> 或 <code>System.Delegate</code> 做為泛型型別的限制；也可以用 <code>unmanaged</code> 限制為不可空的非託管型別。  </p>
<p>最有感的是 <code>System.Enum</code> 以前要限制泛型型別只能用 <code>struct</code> 再加上一些驗證程式碼，沒辦法在編譯時期精準限制列舉為泛型型別。</p>
<h3 id="新的編譯選項"><a href="#新的編譯選項" class="headerlink" title="新的編譯選項"></a>新的編譯選項</h3><p>這部分沒用過，就<a href="https://web.archive.org/web/20211114194546/https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#new-compiler-options" target="_blank" rel="noopener">留個連結備查</a>。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>C# 7 多了很多東西，最明顯的是各種語法糖，面對語法糖，應該找時間更仔細的研究他們編譯後實際的樣子避免誤用。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://web.archive.org/web/20211114194546/https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7" target="_blank" rel="noopener">What’s new in C# 7.0 through C# 7.3 (原文件已經被刪除，這是 Archive 網站的存檔)</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[可重用的 XML 文件註解]]></title>
      <url>/content/20240122-reuseable-xml-documentation-comments.html</url>
      <content type="html"><![CDATA[<p>在開發 C# 專案時，我們經常使用 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/" target="_blank" rel="noopener">XML 文件註解</a> 來為型別或成員寫說明，這類型的註解除了可以提高維護性外，也可以透過工具自動轉化成 API 文件。  </p>
<p>但是註解也是需要維護的，在多載方法的註解經常面臨一個問題就是一群多載方法通常有著相似的註解，維護時需要一個一個修改其實很容易使得最後不同多載間的註解有著許多細微的不一致。另一方面這樣也讓維護註解變得更麻煩瑣碎。</p>
<p><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/" target="_blank" rel="noopener">XML 文件註解</a> 官方文件很詳細，這篇文章不詳細說明這些內容，而會聚焦在重用註解的方式。</p>
<a id="more"></a>
<h3 id="lt-inheritdoc-gt"><a href="#lt-inheritdoc-gt" class="headerlink" title="&lt;inheritdoc&gt;"></a><code>&lt;inheritdoc&gt;</code></h3><p>首先是 <code>&lt;inheritdoc&gt;</code> 這個標記，這算是比較常用的部分，範例如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FluentUriBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Create <span class="doctag">&lt;see cref="FluentUriBuilder"/&gt;</span>.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Created <span class="doctag">&lt;see cref="FluentUriBuilder"/&gt;</span>.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FluentUriBuilder <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FluentUriBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc cref="Create()"/&gt;</span> With passed <span class="doctag">&lt;paramref name="uri"/&gt;</span>.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="uri"&gt;</span>Uri.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Created <span class="doctag">&lt;see cref="FluentUriBuilder"/&gt;</span>.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FluentUriBuilder <span class="title">Create</span>(<span class="params">Uri uri</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FluentUriBuilder(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先可以看到無參數方法 <code>Create()</code> 有一行註解 <code>Create &lt;see cref=&quot;FluentUriBuilder&quot;/&gt;.</code>，對於另外一個多載來說應該也要套用相同的註解為基底，可能會需要加上針對該多載的特別描述，這時候就可以用 <code>&lt;inheritdoc cref=&quot;Create()&quot;/&gt;</code> 的方式來 “繼承” 無參數方法的註解，並附加額外的說明。  </p>
<p>但這個方法有些缺點，首先，當多載數量一多的時候註解內容就會有很多繼承語句，可讀性不太好；其次，在決定要用哪個多載的註解當基底時也容易有標準不一致的情況。這兩個缺點都會讓註解的維護打了不少折扣。  </p>
<p>整體來說，堪用但可維護性偏差。</p>
<h3 id="lt-include-gt"><a href="#lt-include-gt" class="headerlink" title="&lt;include&gt;"></a><code>&lt;include&gt;</code></h3><p>同樣的程式碼片段，變成下面這樣：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FluentUriBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;include file='Properties/SharedComments.xml' path='SharedComments/Method[@name="FluentUriBuilder.Create"]'/&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Created <span class="doctag">&lt;see cref="FluentUriBuilder"/&gt;</span>.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FluentUriBuilder <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FluentUriBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;include file='Properties/SharedComments.xml' path='SharedComments/Method[@name="FluentUriBuilder.Create"]'/&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> With passed <span class="doctag">&lt;paramref name="uri"/&gt;</span>.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="uri"&gt;</span>Uri.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Created <span class="doctag">&lt;see cref="FluentUriBuilder"/&gt;</span>.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FluentUriBuilder <span class="title">Create</span>(<span class="params">Uri uri</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FluentUriBuilder(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這個做法直接把共用註解檔獨立出去成一個 XML 檔案存放在 <code>Properties</code> 中，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SharedComments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Method</span> <span class="attr">name</span>=<span class="string">"FluentUriBuilder.Create"</span>&gt;</span></span><br><span class="line">    Create <span class="tag">&lt;<span class="name">see</span> <span class="attr">cref</span>=<span class="string">"FluentUriBuilder"</span>/&gt;</span>.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SharedComments</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>優點在於避免 <code>&lt;inheritdoc&gt;</code> 在方法間相互 “繼承” 所引發的混亂，但相對的缺點就是會需要額外的註解檔，且以可讀性差來說和 <code>&lt;inheritdoc&gt;</code> 不相上下。  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>雖然 XML 文件註解很簡單，但其實他有各式各樣的標記讓我們在維護程式過的過程就順便維護 API 註解，能為自動產生的 API 提供很大的幫助最大化降低額外維護文件的成本與風險。 而註解因為沒有編譯器的保護所以寫壞很難察覺，如果能活用 XML 文件註解的話也能更容易的維持高品質的註解。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/" target="_blank" rel="noopener">XML documentation comments</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在 EF Core 中自定義 ValueConverter]]></title>
      <url>/content/20231225-efcore-customize-valueconverter.html</url>
      <content type="html"><![CDATA[<p>關於 EF Core 中的值轉換 (Value Conversion)，官方文件已經展示的非常詳細，但這樣的實作使得值轉換和 <code>DbContext</code> 高度相依，在中小型專案中這樣已經足夠，但在複雜的產品群中，如果需要基於 EF Core 建立內部共用的套件，就會難以將這些客製化的 <code>ValueConverter</code> 從套件中抽離，也難以讓應用程式自行擴充自己特殊的 <code>ValueConverter</code>，本文主要提供另外一個面向的實作來達到更低的耦合度與更高的可擴充性。</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通常我們不需要自己客製化 Value Converters，但實務環境總是不會這麼單純。  </p>
<p>以一個實務的例子來說，舊的資料庫在將真假值欄位的值存成 1 代表 false，2 代表 true，然後在程式中用一個列舉 <code>TrueFalseEnum</code> 來表達時，而同一個資料庫又有正常的真假值欄位是存成 0 代表 false 而 1 代表 true，並在程式中轉成 <code>bool</code>。 當有機會重整舊系統時，想要統一這種真假值的型別但又因為要避免未重整部分出錯而不能直接修正資料庫的資料時，就需要在 EF Core 轉換過程直接透過不同的 <code>ValueConverter</code> 來讓這兩種情境都能和 <code>bool</code> 互相轉換。  </p>
<p>或是另外一種資料庫設計不當的情境，例如一張表將時間區間欄位設計成數字代表小時，另外一張表的時間區間欄位可能是代表分，這種不一致很容易造成程式中操作的困難，維護的工程師常常需要分心想現在這個數字代表的是時、分還是秒，也容易不小心弄錯產生 bug。 這時候不管是新專案還是重整舊系統，都會面臨到資料庫欄位變更困難但又不想讓程式遷就資料庫不當設計的兩難。 這時候也很適合用不同的 Value Converters 來轉換數字和 <code>TimeSpan</code> 之類的一致的型別，提升程式碼的可維護性。  </p>
<p>抽象來說，就是當資料庫和程式中的型別無法用預設機制轉換時，就可以考慮客製化 Value Converters.</p>
<h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><h4 id="另外繼承並實作-ValueConverter-lt-gt"><a href="#另外繼承並實作-ValueConverter-lt-gt" class="headerlink" title="另外繼承並實作 ValueConverter&lt;&gt;"></a>另外繼承並實作 <code>ValueConverter&lt;&gt;</code></h4><p>首先我們可以參考 EF Core 內建的各種 Value Converters 來實作，例如：<a href="https://github.com/dotnet/efcore/blob/main/src/EFCore/Storage/ValueConversion/DateTimeToTicksConverter.cs" target="_blank" rel="noopener">DateTimeToTicksConverter.cs</a>。  </p>
<h4 id="提供一個客製的-Attribute"><a href="#提供一個客製的-Attribute" class="headerlink" title="提供一個客製的 Attribute"></a>提供一個客製的 Attribute</h4><p>提供一個 <code>ValueConverterAttribute</code>，讓使用者可以放在 Entity Domain Model 中如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Table(<span class="meta-string">"PERSON"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Column(<span class="meta-string">"WHATEVER"</span>)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">bool</span> Whatever &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Column(<span class="meta-string">"IS_DELETED"</span>)</span>]</span><br><span class="line">	[<span class="meta">ValueConverter(typeof(BooleanToTrueFalse))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> IsDeleted &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Whatever</code> 欄位就是正常的布林值 (0 和 1)，而 <code>IsDeleted</code> 標記套用 <code>BooleanToTrueFalse</code> 這個 Value Converter 來適應資料庫中不當的真假值 (1 和 2)，在程式中我們可以一致的操作 <code>bool</code>，而資料庫的整理則可以等程式整理完後再另外分案處理。  </p>
<h4 id="DbContext-中的實作"><a href="#DbContext-中的實作" class="headerlink" title="DbContext 中的實作"></a><code>DbContext</code> 中的實作</h4><p>這是非常重要的一部份，如果我們照官方文件的作法，會讓 <code>DbContext</code> 和 <code>ValueConverter</code> 直接且高度依賴，這邊我們透過 <code>ValueConverterAttribute</code> 來解除他們的依賴，程式碼範例如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDbContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _entityAssemblyName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDbContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        DbContextOptions&lt;MyDbContext&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">        Setting settings</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _entityAssemblyName = settings.EntityAssemblyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> entityTypes = Assembly.Load(_entityAssemblyName).GetTypes();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> type <span class="keyword">in</span> entityTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> entity = modelBuilder.Entity(type);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> property <span class="keyword">in</span> type.GetProperties())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> converterAttribute = property.GetCustomAttribute&lt;ValueConverterAttribute&gt;();</span><br><span class="line">                <span class="keyword">if</span> (converterAttribute != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> converter = (ValueConverter)Activator.CreateInstance(converterAttribute.Type);</span><br><span class="line">                    entity.Property(property.Name).HasConversion(converter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我們可以在 <code>OnModelCreating</code> 中透過偵測 <code>ValueConverterAttribute</code> 以及反射來設定 Value Conversions。 要注意這個只是用來展示概念，細節部分還需要視情況仔細設計。  </p>
<h3 id="其他應用"><a href="#其他應用" class="headerlink" title="其他應用"></a>其他應用</h3><p>這種設計不限於本文提到的 Value Converters 的情境，只要是會在 <code>MyDbContext</code> 中的各方法中和外部 (例如 Entity Domain Model) 產生直接依賴的情境，都可以用這種設計來解耦。  </p>
<h3 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h3><p>以下是一些重要的注意事項：  </p>
<ol>
<li>直接搜尋組件來找出標有特定 Attribute 的成員是效能很差的做法，在本例中可以接受是因為 <code>OnModelCreating</code> 只會在初始化時執行一次，整體效能影響不大，加上我遇到的是非常重視解耦與彈性的情境，所以是利大於弊的。</li>
<li>這種設計不適用於無跨專案共用需求的 <code>DbContext</code>。</li>
</ol>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>基礎用法其實官方文件都有，但是實務上往往比文件上的範例複雜，這時候就需要變通並試著找出其他更適合的解決方案，但也要了解到不同的機制各有不同的缺點，需要謹慎評估。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://learn.microsoft.com/en-us/ef/core/modeling/value-conversions?tabs=data-annotations" target="_blank" rel="noopener">Value Conversions</a>  </p>
<p><a href="https://github.com/dotnet/efcore/tree/main/src/EFCore/Storage/ValueConversion" target="_blank" rel="noopener">ValueConversion on GitHub</a></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Switch-Case 中使用重名區域變數與延伸探討]]></title>
      <url>/content/20231217-switch-case-variable-scoping.html</url>
      <content type="html"><![CDATA[<p>問題起始於一個情境如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (cryptoType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> CryptoType.AesEncrypt:</span><br><span class="line">        <span class="keyword">var</span> key = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> iv = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CryptoType.AesDecrypt:</span><br><span class="line">        <span class="keyword">var</span> key = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> iv = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// Others</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這時候因為 case 之間的區域變數名字重複了所以編譯不會通過。</p>
<blockquote>
<p>現實情境更複雜，<code>CryptoType</code> 可能有幾十個。  </p>
<p>這邊要先聲明，理論上這種大量的 switch-case 有很多設計可以管理它，但實務上是一個老舊又缺乏架構的專案，甚至亂到重構後的檔案放哪都只會更亂的程度，而如果只是抽出方法，那一些簡單的情境就會因此被抽出大量小型方法，且都放在同一個類別中也不會比較好。  </p>
<p>總之，這個例子只是拿來說明區域變數與其作用域和生命週期，不表示例子中的設計是恰當的。</p>
</blockquote>
<a id="more"></a>
<h3 id="使用區塊限定作用域"><a href="#使用區塊限定作用域" class="headerlink" title="使用區塊限定作用域"></a>使用區塊限定作用域</h3><p>在 cases 中建立利用區塊 <code>{}</code> 建立獨立的作用域：  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (cryptoType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> CryptoType.AesEncrypt:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> key = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">var</span> iv = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CryptoType.AesDecrypt:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> key = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">var</span> iv = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// Others</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="區塊-Block-與區域變數生命週期"><a href="#區塊-Block-與區域變數生命週期" class="headerlink" title="區塊 (Block) 與區域變數生命週期"></a>區塊 (Block) 與區域變數生命週期</h3><p>在 C# 中，區塊 <code>{}</code> 不僅是 <code>if</code>、<code>for</code> 等控制流語句的一部分，也是作用域的界定者。在一個區塊內定義的區域變數，其作用域限定在該區塊內。這意味著同一變數名可以在不同區塊中獨立使用，不會相互影響。</p>
<p>另外如果有必要的時候，使用區塊來限定變數的作用域，不僅有助於解決命名衝突，還可以讓區域變數因為結束區塊而釋放。 但是這樣做會犧牲很大的可讀性與可維護性去得到微乎其微的效益，只能說 “理論上可以這樣做”。</p>
<p>另外，基於好奇稍微去看了 C# 的語言規格書怎麼描述這種基礎到不知道怎麼描述的語法，才發現其實這些看似基礎的東西，細節還真的不少，例如： <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables#929-local-variables" target="_blank" rel="noopener">區域變數</a>、<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#133-blocks" target="_blank" rel="noopener">區塊</a>。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實單獨用區塊控制區域變數的生命週期就是一句話的事，實在很猶豫要不要寫成一篇。 但實務上可能還是會遇到要維護肥大的 switch-case 又無法改設計的情境，導致變數名稱常常重複，如果不用區塊分隔開就會出現為了避免區域變數重名而產生冗長難閱讀的變數，也會讓變數命名時還要去考慮現存的 case 中會不會出現相同的名字造成細微卻常態出現的干擾。 想想還是寫一篇紀錄一下好了。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/specifications" target="_blank" rel="noopener">C# standard specification</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[設計 WebAPI 通用回傳模板]]></title>
      <url>/content/20231216-consistent-webapi-returns.html</url>
      <content type="html"><![CDATA[<p>在我以往的工作經驗中，處理過不少 WebAPI 的維護工作，普遍面臨的一個問題是回傳資料的不一致性。舉例來說，常見的幾種回傳格式包括：</p>
<ol>
<li>純值： <code>true</code>、<code>100</code> 等，會出現在回傳單一值的 API 中。</li>
<li>物件： <code>{&quot;name&quot;: &quot;Ron&quot;, &quot;gender&quot;: &quot;Male&quot;}</code>，會出現在回傳物件的 API 中。</li>
<li>物件含狀態： <code>{&quot;status&quot;: &quot;1001&quot;, &quot;name&quot;: &quot;Ron&quot;, &quot;gender&quot;: &quot;Male&quot;}</code>，會出現在呼叫端需要知道更多狀態細節時。</li>
<li>其他變種：除了資料外還有各種狀態、錯誤、訊息等欄位，但格式與名稱不統一。</li>
</ol>
<p>這個現象造成的問題就是明明是同一個站台對外提供服務，回傳的狀態訊息卻每個 API 都不一樣，不僅對使用者不友善，也會讓接手維護的人無所適從。</p>
<p>本篇文章會介紹並分析的幾種解決方案，所有方案都有高一致性與關注點分離的共同優點，但也有些不同的缺點。</p>
<a id="more"></a>
<h3 id="用-Header-表示狀態"><a href="#用-Header-表示狀態" class="headerlink" title="用 Header 表示狀態"></a>用 Header 表示狀態</h3><p>這是個很常見的做法，用 Header 表示狀態，而回傳的 Body 中則只包含資料本身。  </p>
<p><strong>優點</strong>  </p>
<ul>
<li>把狀態和資料徹底區分開，具有高度彈性和相容性，尤其適合於需要回傳非字串類型資料 (如串流、multipart/form-data) 的情境。</li>
</ul>
<p><strong>缺點</strong>  </p>
<ul>
<li>管理不便<ul>
<li>需要較多文件輔助。</li>
<li>需要適當設計來集中來收納各種 Header 的常數，避免到處散落的 Magic String。</li>
</ul>
</li>
<li>較不直覺，開發者和使用者都需要認知到 Header 中有包含狀態訊息。</li>
</ul>
<h3 id="用基底類別收納狀態相關欄位"><a href="#用基底類別收納狀態相關欄位" class="headerlink" title="用基底類別收納狀態相關欄位"></a>用基底類別收納狀態相關欄位</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResponseModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> : <span class="title">ResponseModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Gender Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面範例，使用 <code>ResponseModelBase</code> 做為基底類別來收納狀態類的資訊，他會被所有 API 的回傳類別繼承，他與使用 Header 的解決方案有著相似的優點並解決了一些 Header 的缺點，但也產生不同面相的缺點。  </p>
<p><strong>優點</strong>  </p>
<ul>
<li>管理稍微容易，只需要提到繼承 <code>ResponseModelBase</code> 即可。</li>
<li>直覺，狀態就在 Body 中。</li>
</ul>
<p><strong>缺點</strong>  </p>
<ul>
<li>只支援回傳字串的情境。</li>
<li>如果衍生類別 (如 Person) 與基底類別 (如 ResponseModelBase) 有同名欄位，會造成命名上的困擾、缺陷或混淆。 由於無法預測未來的規格變化，這種風險難以避免。 (基底類別的欄位用很特殊的命名不算個解法)。</li>
</ul>
<h3 id="繼承通用泛型類別"><a href="#繼承通用泛型類別" class="headerlink" title="繼承通用泛型類別"></a>繼承通用泛型類別</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ResponseModel&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Gender Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上範例，借用以包含取代繼承的概念，設計泛型類別取代基底類別，而 API 回傳的型別則會變成 <code>ResponseModel&lt;Person&gt;</code>。</p>
<p><strong>優點</strong>  </p>
<ul>
<li>管理稍微容易，只需要提到 <code>ResponseModel&lt;T&gt;</code> 即可。</li>
<li>直覺，狀態就在 Body 中。</li>
<li>基礎類別 (如 Person) 不用擔心和 <code>ResponseModel&lt;T&gt;</code> 中的欄位同名。</li>
</ul>
<p><strong>缺點</strong>  </p>
<ul>
<li>只支援回傳字串的情境。</li>
<li>比起繼承，泛型型別在使用時的程式碼比較冗長。</li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這幾種方案各有利弊，但至少都能解決文章開頭提到的一致性、維護性和使用者友好度的問題。總結建議如下：</p>
<ol>
<li>當預期會回傳非字串型態的 Body 時，選擇 Header 解決方案，但需要注意管理的複雜性。  </li>
<li>當預期只會回傳字串 Body 時，選擇泛型解決方案。</li>
<li>不要選擇繼承通用類別的解法，提到他只是要記錄他和泛型型別設計上的差異。  </li>
</ol>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p>開發經驗。  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[客製 .NET 程式碼分析與自動修正]]></title>
      <url>/content/20230812-write-roslyn-analyzer-and-code-fix.html</url>
      <content type="html"><![CDATA[<p><a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview?view=vs-2022" target="_blank" rel="noopener">.NET 編譯器平台 (Roslyn) 分析器</a> 提供很多有用的程式碼分析規則讓我們更容易維持良好的程式碼品質，但有時候我們會需要自己定義一些規則來符合專案開發規範。官方以及其他網路文章其實已經提供了不少資訊，但因為步驟和說明真的很多，了解起來太花時間，於是想自己來整理一下讓需要的人可以快速走完所有步驟。</p>
<a id="more"></a>
<h3 id="用-Visual-Studio-樣板建立專案"><a href="#用-Visual-Studio-樣板建立專案" class="headerlink" title="用 Visual Studio 樣板建立專案"></a>用 Visual Studio 樣板建立專案</h3><ol>
<li>打開 Visual Studio (這邊用 2022 版來示範)。</li>
<li><p>File &gt; New &gt; Project，選擇 Analyzer with code fix (.NET Standard) 如下圖：  </p>
 <img src="/content/20230812-write-roslyn-analyzer-and-code-fix/1-create-solution-1.png">   
<blockquote>
<p>找不到的話就是沒安裝相關元件，<a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/tutorials/how-to-write-csharp-analyzer-code-fix#installation-instructions---visual-studio-installer" target="_blank" rel="noopener">參考官方說明來安裝</a>。  </p>
</blockquote>
</li>
<li><p>下一步繼續設定名稱路徑等，這邊要注意的是 <strong>Framework 選單沒有意義，不管選哪一個建立的方案都是一樣的版本，所以不用費心挑選</strong>。</p>
 <img src="/content/20230812-write-roslyn-analyzer-and-code-fix/1-create-solution-2.png">   
</li>
<li><p>建立完成如下圖，會得到四個專案，<a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/tutorials/how-to-write-csharp-analyzer-code-fix#explore-the-analyzer-template" target="_blank" rel="noopener">詳情參考官方介紹</a>。  </p>
 <img src="/content/20230812-write-roslyn-analyzer-and-code-fix/1-create-solution-3.png">   
</li>
</ol>
<h3 id="建立規則並發佈"><a href="#建立規則並發佈" class="headerlink" title="建立規則並發佈"></a>建立規則並發佈</h3><h4 id="開發與測試"><a href="#開發與測試" class="headerlink" title="開發與測試"></a>開發與測試</h4><p>從剛剛建立的方案所提供的範本為起點。  </p>
<ol>
<li><code>MyRoslynAnalyzer</code> 專案中寫的是主要的程式碼分析規則。</li>
<li><code>MyRoslynAnalyzer.Test</code> 專案中寫的是測試。</li>
<li><p><code>MyRoslynAnalyzer.Package</code> 提供一些製作 NuGet Package 時候所需要的設定與工具。</p>
<blockquote>
<p>預設就可以用不需要改。</p>
</blockquote>
</li>
<li><p><code>MyRoslynAnalyzer.Vsix</code> 設定為起始專案啟動後會另外開一個 Visual Studio 來套用前面寫的規則。</p>
<blockquote>
<p>我會刪掉這個專案。<br>他也是預設就可以用，但會多開一個 Visual Studio，這樣交錯操作對我來說容易搞混，不如單元測試完直接把 NuGet Package 放在自己本機然後用固定的專案測試。但是這個做法是因為我已經建好本機 NuGet 儲存庫了，建立本機 NuGet 儲存庫的方法之前有寫過一篇 <a href="/content/20220924-local-nuget-package-repository.html" title="在本機上建立 NuGet 儲存庫">在本機上建立 NuGet 儲存庫</a>。  </p>
</blockquote>
</li>
</ol>
<h4 id="開發建議"><a href="#開發建議" class="headerlink" title="開發建議"></a>開發建議</h4><ul>
<li><strong>Hello World 從 <a href="https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/Tutorials/MakeConst" target="_blank" rel="noopener">官方提供的範例專案</a> 開始看。</strong>  </li>
<li><strong>綜合參考 <a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers" target="_blank" rel="noopener">StyleCopAnalyzers</a> 和 <a href="https://github.com/buyaa-n/roslyn-analyzers" target="_blank" rel="noopener">roslyn-analyzers</a> 來進一步學習。</strong>  </li>
<li><strong>資料夾結構與命名等參考 StyleCopAnalyzers。</strong>這是因為他用編號命名，資料夾結構用規則分類來做，整體專案也比較單純，這對維護來說很方便。  </li>
<li><strong>實作細節參考 roslyn-analyzers。</strong>這是因為 StyleCopAnalyzers 畢竟是另外一套工具，他有一些自定義的內容，相較之下參考 roslyn-analyzers 的實作能最大限度的利用內建的物件避免自造輪子或額外依賴另一個套件的物件增加沒必要的複雜度。但是 StyleCopAnalyzers 的資料夾複雜，要找到可以參考的規則還真不太好找，但因為所有規則都會繼承 <code>DiagnosticAnalyzer</code> 類別並加上 <code>DiagnosticAnalyzerAttribute</code>，以這個為進入點就會好找很多。  </li>
<li><strong>從最簡單的命名規則開始</strong>，會比較容易建立信心。  </li>
<li><strong>善用 ChatGPT 或 GitHub Copilot 輔助。</strong>AI 在這類很常見的情境上表現得很好，我自己就只用 AI 加預設範例就實作出一些簡單的規則了。  </li>
</ul>
<h4 id="發佈"><a href="#發佈" class="headerlink" title="發佈"></a>發佈</h4><p>發佈的話就是直接編譯 <code>MyRoslynAnalyzer.Package</code> 並用 Visual Studio 內建的功能來製作 nupkg 檔就好，很方便。<br>    <img src="/content/20230812-write-roslyn-analyzer-and-code-fix/3-packing-1.png">   </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實入門不難，但是就是官方文件非常長所以要看很久。  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview?view=vs-2022" target="_blank" rel="noopener">Overview of source code analysis</a>  </p>
<p><a href="https://devblogs.microsoft.com/dotnet/how-to-write-a-roslyn-analyzer/" target="_blank" rel="noopener">How to write a Roslyn Analyzer</a></p>
<p><a href="https://www.alwaysdeveloping.net/p/analyzer-explained/" target="_blank" rel="noopener">Roslyn Analyzer Part 1 - 5</a>  </p>
<p><a href="https://github.com/buyaa-n/roslyn-analyzers" target="_blank" rel="noopener">roslyn-analyzers</a>  </p>
<p><a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers" target="_blank" rel="noopener">StyleCopAnalyzers</a>  </p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[樂觀鎖與悲觀鎖的選擇]]></title>
      <url>/content/20230721-optimistic-vs-pessimistic-lock.html</url>
      <content type="html"><![CDATA[<p>在資料庫操作時，面對多個操作的並行操作，為了避免資料不一致和衝突我們主要有兩種方法可以達成這個目標：樂觀鎖 (Optimistic Lock) 和悲觀鎖 (Pessimistic Lock)。但我們應該如何選擇適合的方法呢？</p>
<blockquote>
<p>樂觀鎖和悲觀鎖的實作網路資源太多了，這篇不會特別提。</p>
</blockquote>
<a id="more"></a>
<h3 id="樂觀鎖分析"><a href="#樂觀鎖分析" class="headerlink" title="樂觀鎖分析"></a>樂觀鎖分析</h3><p>個人經驗來說，會用一個 Version 欄位來記錄版本，在寫入資料時再判斷版本是否因為被其他操作更新過，以此為依據來避免互相覆蓋。  </p>
<p><strong>特性</strong>  </p>
<ol>
<li>由應用程式控制而不是資料庫中真實的鎖。</li>
<li>衝突時比較晚更新的那個操作會被取消，應用程式中可能會拋出例外。</li>
</ol>
<p><strong>優點</strong>  </p>
<ol>
<li>Entity Framework Core 和 NHibernate 等 ORM 有支援樂觀鎖，使用方便。</li>
</ol>
<p><strong>缺點</strong>  </p>
<ol>
<li>衝突時比較晚更新的那個操作如果一定要更新就需要有重試機制，當衝突率高時重試開銷會很高。</li>
<li>操作取消並重試的機制在效能上必然較差，重試機制要兼顧資料正確性時較複雜。</li>
</ol>
<p><strong>適用情境</strong>  </p>
<ol>
<li><strong>衝突時只需要認列第一個操作時。</strong></li>
<li><strong>衝突時需要認列後面的操作，但是不能直接寫入而需要重新執行一些商務邏輯再更新才正確時。</strong></li>
</ol>
<h3 id="悲觀鎖分析"><a href="#悲觀鎖分析" class="headerlink" title="悲觀鎖分析"></a>悲觀鎖分析</h3><p>悲觀鎖又稱行鎖 (Row Lock)，一開始操作時就先把該筆資料鎖定，防止其他操作修改該資料，解鎖後其他操作會繼續執行，它可以預防衝突，而不是在事後解決衝突。</p>
<p><strong>特性</strong>  </p>
<ol>
<li>由資料庫提供的行鎖。</li>
<li>衝突時所有操作會排隊在解鎖後依序執行。</li>
</ol>
<p><strong>優點</strong>  </p>
<ol>
<li>避免事後處理衝突的開銷。</li>
</ol>
<p><strong>缺點</strong>  </p>
<ol>
<li>Entity Framework Core 和 NHibernate 等 ORM 不直接支援，如果要使用會需要用純 SQL 下指令，以 Oracle 來說就是 <code>SELECT C1, C2 FROM T1 FOR UPDATE</code>。</li>
<li>鎖定時資料無法被修改，如果因為操作不當而沒有及時解鎖，就會嚴重影響效能。</li>
</ol>
<p><strong>適用情境</strong>  </p>
<ol>
<li><strong>衝突時多個操作可依序執行時(例如後面的變更覆蓋之前的變更是正確的時)。</strong></li>
</ol>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這兩種鎖互有優缺，應該要適當的搭配使用。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p>ChatGPT</p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[參考型別當 Dictionary Key 的注意事項]]></title>
      <url>/content/20230720-reference-type-as-dictionary-key.html</url>
      <content type="html"><![CDATA[<p><code>Dictionary&lt;TKey, TValue&gt;</code> 是很常用的資料結構，我們可以使用索引子 (Indexer) 透過特定的 Key 來存取資料。 但使用時，我們要特別注意 Key 的型別，使用值型別作為 Key 通常不會有問題，但當使用參考型別作為 Key 時就不一定了。</p>
<a id="more"></a>
<h3 id="使用參考型別作為-Key-時的存取"><a href="#使用參考型別作為-Key-時的存取" class="headerlink" title="使用參考型別作為 Key 時的存取"></a>使用參考型別作為 Key 時的存取</h3><p>先看下面程式碼：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TwoValue&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoValue</span>(<span class="params">T1 v1, T2 v2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Value1 = v1;</span><br><span class="line">        Value2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T1 Value1 &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> T2 Value2 &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The key is `new TwoValue&lt;int, int&gt;(1, 2)`</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">string</span>&gt;();</span><br><span class="line">dic.Add(<span class="keyword">new</span> TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">dic.TryGetValue(<span class="keyword">new</span> TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">out</span> <span class="keyword">var</span> v1).Dump(); <span class="comment">// false</span></span><br><span class="line">v1.Dump(); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>從 <a href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,191" target="_blank" rel="noopener">Dictionary 的 Add(…) 方法</a> 中可以看到，在新增項目的時候，Key 的部分是以呼叫 <code>GetHashCode()</code> 方法所得到的結果為基準產生的。我們也知道參考型別的不同物件，呼叫 GetHashCode 得到的結果會不同，所以新增項目後又以另外一個新建的 <code>TwoValue</code> 物件為 Key 去查詢，就會因為新物件的 <code>GetHashCode()</code> 回傳和 <code>Dictionary</code> 內物件的不同而找不到。</p>
<blockquote>
<p>關於 <code>Object.GetHashCode()</code> 怎麼運作、和物件的實際記憶體位置有什麼關係、和 <code>Object.Equal(object)</code> 又有什麼關係，之後再找時間仔細了解。</p>
</blockquote>
<h3 id="使用-Tuple-作為-Key-時的存取"><a href="#使用-Tuple-作為-Key-時的存取" class="headerlink" title="使用 Tuple 作為 Key 時的存取"></a>使用 Tuple 作為 Key 時的存取</h3><p>但是如果使用的是 <code>Tuple</code> 就不同了，如下範例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The key is `new Tuple&lt;int, int&gt;(1, 2)`</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;Tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">string</span>&gt;();</span><br><span class="line">dic.Add(<span class="keyword">new</span> Tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">dic.TryGetValue(<span class="keyword">new</span> Tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">out</span> <span class="keyword">var</span> v2).Dump(); <span class="comment">// true</span></span><br><span class="line">v2.Dump(); <span class="comment">// "Hello"</span></span><br></pre></td></tr></table></figure></p>
<p>雖然 <code>Tuple&lt;T1,T2&gt;</code> 是參考型別，但因為他<a href="https://referencesource.microsoft.com/#mscorlib/system/tuple.cs,225" target="_blank" rel="noopener">覆寫了 <code>GetHashCode()</code> 方法</a> 使得產生的雜湊值其實是源自於它包含的 T1 與 T2 的雜湊值，所以才會造成參考型別的 Key 即使是不同物件也能用來查詢 Dictionary 項目的現象。  </p>
<p>這點其實很重要，如果不知道這些細節，可能會因為這些程式碼執行結果而反向推斷出像是 “<code>Tuple</code> 是值型別” 這樣的錯誤認知，或是對參考型別的特性產生困惑與混淆。</p>
<h3 id="使用包含參考型別的-Tuple-作為-Key-時的存取"><a href="#使用包含參考型別的-Tuple-作為-Key-時的存取" class="headerlink" title="使用包含參考型別的 Tuple 作為 Key 時的存取"></a>使用包含參考型別的 Tuple 作為 Key 時的存取</h3><p>經過上面兩種情境的示範，應該不能猜出這個情境會有什麼結果了，範例如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TwoValue&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoValue</span>(<span class="params">T1 v1, T2 v2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Value1 = v1;</span><br><span class="line">        Value2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T1 Value1 &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> T2 Value2 &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The key is `new TwoValue&lt;int, int&gt;(1, 2), 3)`</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;Tuple&lt;TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;, <span class="keyword">string</span>&gt;();</span><br><span class="line">dic.Add(<span class="keyword">new</span> Tuple&lt;TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;(<span class="keyword">new</span> TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">dic.TryGetValue(<span class="keyword">new</span> Tuple&lt;TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;(<span class="keyword">new</span> TwoValue&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="keyword">out</span> <span class="keyword">var</span> v3).Dump(); <span class="comment">// false</span></span><br><span class="line">v3.Dump(); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>因為 <code>Tuple&lt;T1, T2&gt;</code> 是以其所包含的型別參數們的雜湊值為基礎去產生他自己的雜湊值，所以當然如果型別參數中有參考型別，那整個 <code>Tuple&lt;T1, T2&gt;</code> 的雜湊值就可能 (如果他沒有改變 <code>GetHashCode()</code> 的行為) 會因為其所包含的成員產生不同雜湊值而最終結果也不同，不能單以型別參數是參考型別而判定他適合做為 <code>Dictionary</code> 的 Key。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>總結來說就是， <code>Dictionary&lt;TKey, TValue&gt;</code> 中的 TKey 盡量不要用參考型別，如果要用得要確定他不會產生上述的疑慮。  </p>
<p>其實不難理解，但是很難用文字說明，自己看起來都像是在繞口令…  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">Reference Source</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 部分類別 (Partial Class) 的使用建議]]></title>
      <url>/content/20230709-using-partial-class.html</url>
      <content type="html"><![CDATA[<p>在 C# 中，partial class 可以讓開發者把一個類別分散到多個檔案中。當程式編譯時，這些分散的部分會被合併成一個單一的類別。這篇會根據以往經驗來紀錄一下使用建議。</p>
<a id="more"></a>
<h3 id="設計建議"><a href="#設計建議" class="headerlink" title="設計建議"></a>設計建議</h3><h4 id="檔名名稱"><a href="#檔名名稱" class="headerlink" title="檔名名稱"></a>檔名名稱</h4><p>檔名名稱應該是 <code>&lt;Class&gt;.&lt;Category&gt;.cs</code> 這樣的格式。  </p>
<p>例如一個類別 <code>Product</code> 有一個 <code>Product.cs</code> 檔案包含了產品的部分資訊，當需要建立另外一個部分類別來包含商品屬性的時候，這個新的部分類別可以放在另外一個 <code>Product.Properties.cs</code> 檔案中，這樣做的好處有幾個：</p>
<ol>
<li><code>Product.cs</code> 是主要資訊，其他資訊可以依照分類建立在不同檔案中，非常清楚也容易維護。</li>
<li>使用如果 Visual Studio 開發，建立檔案 <code>Product.Properties.cs</code> 的時候它預設的的類別就會是 <code>Product</code>，且對程式碼分析工具來說也是符合規範的 (至少我用過的程式碼分析是這樣)。</li>
<li>即便不是使用 Visual Studio 開發，在程式編碼規範的訂定上也比較容易，例如：一般會要求主檔名要符合類別名稱，這在部分類別的情境也適用。  </li>
</ol>
<p>細節可依狀況調整，但大方向依照 <code>&lt;Class&gt;.&lt;Category&gt;.cs</code> 這樣的模式是副作用最小的。</p>
<h4 id="檔案管理"><a href="#檔案管理" class="headerlink" title="檔案管理"></a>檔案管理</h4><p>同一個類別的所有部分類別檔案放在同一個資料夾下，避免檔案四散各處而難以追蹤整個類別的完整樣貌。</p>
<h4 id="共用成員的管理"><a href="#共用成員的管理" class="headerlink" title="共用成員的管理"></a>共用成員的管理</h4><p>這個主題包含建構子、共用欄位、共用屬性、共用方法等需要在被不同檔案中的部分類別共用的情境。  </p>
<p>通常我會把共用成員放在主要檔案中，例如： <code>Product.cs</code> 中就包含所有共用成員，且要維護過程中需要時刻注意呼叫方法時是否會破壞這個原則。</p>
<h3 id="適用情境"><a href="#適用情境" class="headerlink" title="適用情境"></a>適用情境</h3><h4 id="隔離自動生成-Auto-Generated-的程式碼"><a href="#隔離自動生成-Auto-Generated-的程式碼" class="headerlink" title="隔離自動生成 (Auto-Generated)的程式碼"></a>隔離自動生成 (Auto-Generated)的程式碼</h4><p>有時候我們需要透過工具或框架自動產生程式碼，最常見的情況就是 ORM (如 Entity Framework）所產生的資料模型 (Entity Data Model)，我們不應該去修改這些自動生成的程式碼，避免之後重新生成覆蓋掉我們的修改，這時候就可以用部分類別來擴充與維護，範例如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateOfBirth &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.Aggregation.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FullName</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; FirstName + <span class="string">" "</span> + LastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這樣一來當重新產生資料模型的時候就只會影響到工具所管轄的檔案 <code>Product.cs</code> 而已。</p>
<h4 id="大類別的拆分"><a href="#大類別的拆分" class="headerlink" title="大類別的拆分"></a>大類別的拆分</h4><p>有些類別因為定義的過於抽象且現實不允許重構時，就可以透過將一個大類別細分成多個小的部分類別，提升一點可維護性；另外一種是資料容器型的類別 (Model)，尤其是 Context 或是 Metadata 這一類的類別很容易就包山包海，稍微分類一下也是有幫助。  </p>
<p>但是要注意的是：<br><strong>如果適合，一開始就設計成不同類別會更理想；如果不適合設計成不同類別，那再來考慮部分類別。</strong></p>
<h4 id="分階段重構時"><a href="#分階段重構時" class="headerlink" title="分階段重構時"></a>分階段重構時</h4><p>有些包袱特別重的專案，裡面會有很肥又很亂的類別，偏偏又不允許一次到位的重構整個類別，這時候就會需要分階段重構。而分階段重構時必然會面對邊重構邊維護的困境，使得一個原本就很亂的類別中的程式碼新舊交融，因而更難以維護，也容易因為維護不當導致亂上加亂。  </p>
<blockquote>
<p>這邊的新舊交融不是指重構後留著舊程式碼不刪，而是有些重構了但有些還沒做的意思。</p>
</blockquote>
<p>這時候可以把舊的程式碼直接改成部分類別留在原本的檔案 <code>GhostStory.cs</code> 中，另外建立一個新檔案 <code>GhostStory.Refactoring.cs</code> 包含整理過的程式碼，達到分階段重構期間仍然可以維護舊的程式而不會互相干擾的效果。  </p>
<p>等到幾百年後重構終於完成了，就可以刪掉舊的 <code>GhostStory.cs</code> 後再把  <code>GhostStory.Refactoring.cs</code> 重新命成回 <code>GhostStory.cs</code> 並移除 <code>partial</code> 關鍵字就完成了。  </p>
<h3 id="缺點與誤用風險"><a href="#缺點與誤用風險" class="headerlink" title="缺點與誤用風險"></a>缺點與誤用風險</h3><h4 id="分類不當或程式放在不適合的檔案"><a href="#分類不當或程式放在不適合的檔案" class="headerlink" title="分類不當或程式放在不適合的檔案"></a>分類不當或程式放在不適合的檔案</h4><p>用部分類別雖然可以達到大類別分類管理的效果，但如果分類不當或將程式放在不適合的檔案中，反而會增加維護難度。</p>
<h4 id="共用成員難管理"><a href="#共用成員難管理" class="headerlink" title="共用成員難管理"></a>共用成員難管理</h4><p>當多個不同檔案的方法需要呼叫共用成員時，那個共用成員要放在哪個檔案也是個不好決定的主題，甚至複雜一點會產生多個檔案間的方法交錯呼叫而難以追蹤與管理。即使一開始決定好了，維護過程也要一直注意呼叫關係是否恰當以及是否要讓成員換檔案住的問題。  </p>
<p>這點是最難掌控的，因為很容易隨著維護的過程慢慢歪掉。</p>
<h4 id="逃避設計或重構"><a href="#逃避設計或重構" class="headerlink" title="逃避設計或重構"></a>逃避設計或重構</h4><p>部分類別算是備用方案，如果不先考慮好好設計而一股腦地使用部分類別的話，還是會產生一個大雜燴風格的類別，違反了單一職責原則 (Single Responsibility Principle) 且容易讓程式碼的可維護性快速下降。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>部分類別是個很好用的工具，但如果使用不當，再好用的工具都會砸到自己的腳，所以設計時應該要綜合考慮優缺點與副作用以及需要的取捨後再做決定。  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p>ChatGPT  </p>
<p>開發經驗  </p>
<p><a href="https://stackoverflow.com/questions/1478610/naming-conventions-for-partial-class-files" target="_blank" rel="noopener">Naming Conventions For Partial Class Files</a>  </p>
<p><a href="https://stackoverflow.com/questions/351272/best-practices-when-not-to-use-partial-classes" target="_blank" rel="noopener">Best Practices: When not/to use partial classes</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 ORM 做單次大查詢的效能陷阱]]></title>
      <url>/content/20230617-large-scale-query-with-orm.html</url>
      <content type="html"><![CDATA[<p>在開發過程中，我們經常需要透過 ORM　(我是使用 EF Core) 從資料庫中取得資訊，在查詢很複雜的時候我通常都會盡量透過一個查詢就把資料準備好，並轉換成巢狀的資料結構以便於應用程式進行操作，這樣可以避免多次查詢造成的效能風險。　　</p>
<p>但前陣子在開發過程檢查 ORM 產生的 SQL 時意外發現我的認知不一定是對的。  </p>
<a id="more"></a>
<h3 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h3><p>因為單次大查詢雖然能避免多次來回查詢的成本，但是當遇到巢狀的資料結構的時候，單次大查詢轉換出來的 SQL 可能會非常糟，問題主要可以分成兩個方向。</p>
<p>這邊先附上一個複雜的 LINQ 查詢與透過 EF Core 轉化出來的 SQL 作為下面說明的參考資料：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> courseDetails = _dbContext.Set&lt;Course&gt;()</span><br><span class="line">    .Where(c =&gt; c.Id == id)</span><br><span class="line">    .Select(c =&gt; <span class="keyword">new</span> Detail</span><br><span class="line">    &#123;</span><br><span class="line">        Id = c.Id,</span><br><span class="line">        Name = c.Name,</span><br><span class="line">        Teacher = c.Teacher.Name,</span><br><span class="line">        Students = c.Students.Select(s =&gt; <span class="keyword">new</span> Student</span><br><span class="line">        &#123;</span><br><span class="line">            Id = s.Id,</span><br><span class="line">            Name = s.Name,</span><br><span class="line">            Grade = s.Grades.FirstOrDefault(g =&gt; g.CourseId == c.Id).Grade,</span><br><span class="line">            PersonalInfo = <span class="keyword">new</span> PersonalInfo</span><br><span class="line">            &#123;</span><br><span class="line">                Address = s.PersonalInfo.Address,</span><br><span class="line">                PhoneNumber = s.PersonalInfo.PhoneNumber,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).ToList(),</span><br><span class="line">    &#125;)</span><br><span class="line">    .SingleOrDefault();</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="string">"c"</span>.<span class="string">"Id"</span>, </span><br><span class="line">    <span class="string">"c"</span>.<span class="string">"Name"</span>, </span><br><span class="line">    <span class="string">"t"</span>.<span class="string">"Name"</span>, </span><br><span class="line">    <span class="string">"s"</span>.<span class="string">"Id"</span>, </span><br><span class="line">    <span class="string">"s"</span>.<span class="string">"Name"</span>, </span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="string">"g"</span>.<span class="string">"Grade"</span> <span class="keyword">FROM</span> <span class="string">"Grades"</span> <span class="keyword">AS</span> <span class="string">"g"</span> <span class="keyword">WHERE</span> (<span class="string">"g"</span>.<span class="string">"CourseId"</span> = <span class="string">"c"</span>.<span class="string">"Id"</span>) <span class="keyword">AND</span> (<span class="string">"g"</span>.<span class="string">"StudentId"</span> = <span class="string">"s"</span>.<span class="string">"Id"</span>) <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="keyword">ROW</span> <span class="keyword">ONLY</span>),</span><br><span class="line">    <span class="string">"p"</span>.<span class="string">"Address"</span>, </span><br><span class="line">    <span class="string">"p"</span>.<span class="string">"PhoneNumber"</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="string">"Courses"</span> <span class="keyword">AS</span> <span class="string">"c"</span> </span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">"Teachers"</span> <span class="keyword">AS</span> <span class="string">"t"</span> <span class="keyword">ON</span> <span class="string">"c"</span>.<span class="string">"Id"</span> = <span class="string">"t"</span>.<span class="string">"CourseId"</span></span><br><span class="line">    <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="string">"s"</span>.*, <span class="string">"cs"</span>.<span class="string">"CourseId"</span> </span><br><span class="line">        <span class="keyword">FROM</span> <span class="string">"Students"</span> <span class="keyword">AS</span> <span class="string">"s"</span></span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">"CourseStudents"</span> <span class="keyword">AS</span> <span class="string">"cs"</span> <span class="keyword">ON</span> <span class="string">"s"</span>.<span class="string">"Id"</span> = <span class="string">"cs"</span>.<span class="string">"StudentId"</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">"cs"</span>.<span class="string">"CourseId"</span></span><br><span class="line">    ) <span class="keyword">AS</span> <span class="string">"s"</span> <span class="keyword">ON</span> <span class="string">"c"</span>.<span class="string">"Id"</span> = <span class="string">"s"</span>.<span class="string">"CourseId"</span></span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">"PersonalInfos"</span> <span class="keyword">AS</span> <span class="string">"p"</span> <span class="keyword">ON</span> <span class="string">"s"</span>.<span class="string">"Id"</span> = <span class="string">"p"</span>.<span class="string">"StudentId"</span></span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    <span class="string">"c"</span>.<span class="string">"Id"</span> = :<span class="keyword">id</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">    <span class="string">"c"</span>.<span class="string">"Id"</span>, </span><br><span class="line">    <span class="string">"s"</span>.<span class="string">"CourseId"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>這個問題是工作上遇到的也<strong>已經確認過問題的確存在</strong>，但當然不能拿公司實際資料當範例，所以這邊用 ChatGPT 產生 LINQ 和 SQL 來當範例，因為是機器產生的和實際運作產生的 SQL 不一定會相同甚至無法運作，<strong>但作為展示概念的參考資料已經足夠了</strong>。</p>
</blockquote>
<h4 id="大量多餘的資料"><a href="#大量多餘的資料" class="headerlink" title="大量多餘的資料"></a>大量多餘的資料</h4><p>這部分可以用 SQL 搜尋出來的資料是一個表格為出發點去理解，因為透過 SQL 沒辦法直接搜尋出一個巢狀的資料結構，所以在查到的資料到應用程式的巢狀類別中間勢必要經過轉化，而這個轉化是發生在應用程式中的。  </p>
<p>從上面的範例來看，我們可以看到他產生的 SQL 因為包含大量的 JOIN 所以搜尋出來的資料筆數可能會極大，然後才在應用程式中分組整合。</p>
<p><strong>而重點在於這大量的資料中的多數欄位都是重複的內容。</strong>  </p>
<blockquote>
<p>以實際遇到的情境來說，我只是要搜尋一筆主資料，但因為關聯到很多其他資料表所以實際上搜尋出幾千筆的資料，然後在應用程式中將幾千筆資料分組整合成一個巢狀類別。  </p>
</blockquote>
<p>這會造成的問題有：  </p>
<ul>
<li><strong>無謂的記憶體消耗，甚至 GC 的負擔</strong><br>透過上面描述，可想而知這幾千筆中重複的內容會造成多少無謂的記憶體消耗，如果資料夠大還可能會進一步造成 GC 的負擔。</li>
<li><strong>提高對 CPU 的負擔</strong><br>這點也很好理解，大量資料的轉化需要很多運算資源。</li>
</ul>
<h4 id="不必要的排序"><a href="#不必要的排序" class="headerlink" title="不必要的排序"></a>不必要的排序</h4><p>另外一個就是不必要的排序，從前面的範例可以發現所產生的不必要的排序，這個排序會使得 SQL 本身的查詢成本大幅提高。  </p>
<blockquote>
<p>至於為什麼會排序，根據 ChatGPT 的說法是：<br>Entity Framework Core 在產生 SQL 語句時，會在某些情況下插入排序操作，以確保返回的資料符合 C# 的 LINQ 查詢的順序。這通常發生在涉及集合導航屬性的查詢中，因為 EF Core 需要保證資料的順序與原始查詢相符。<br>這種排序操作是 EF Core 為了處理導航集合屬性（如 c.Students）而添加的。它需要按照外鍵（在這裡是 CourseId）的順序來獲取相關的 Students，以便能夠正確地建立回傳的物件。</p>
</blockquote>
<h3 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h3><p>解決方式其實就是把單次大查詢轉化成多次小查詢，如下範例。</p>
<pre><code class="csharp"><span class="keyword">var</span> courseDetails = _dbContext.Set&lt;Course&gt;()
    .Where(c =&gt; c.Id == id)
    .Select(c =&gt; <span class="keyword">new</span> Detail
    {
        Id = c.Id,
        Name = c.Name,
        Teacher = c.Teacher.Name,
    })
    .SingleOrDefault();

courseDetails.Students = _dbContext.Set&lt;Student&gt;()
    .Where(s =&gt; s.Courses.Any(c =&gt; c.Id == courseDetails.Id))
    .Select(s =&gt; <span class="keyword">new</span> Student
    {
        Id = s.Id,
        Name = s.Name,
        Grade = s.Grades.FirstOrDefault(g =&gt; g.CourseId == courseDetails.Id).Grade,
        PersonalInfo = <span class="keyword">new</span> PersonalInfo
        {
            Address = s.PersonalInfo.Address,
            PhoneNumber = s.PersonalInfo.PhoneNumber,
        }
    }).ToList();
</code></pre>
<p>因為被拆成幾段小查詢，所以每一段查詢都會降低 JOIN 的數量 (甚至沒有)，因此就能避免單次大查詢的效能陷阱了。</p>
<blockquote>
<p>但這邊還是要注意，不是把巢狀拆掉分開就是好的，如果 JOIN 後的資料量很小，多次小查詢的效能是可能比單次查詢要差的，這部分就變成要因地制宜來判定了。</p>
</blockquote>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>以前總是覺得多個小查詢查資料效能比較差，沒想到其實不一定。  </p>
<p>總結一下巢狀物件的查詢心得：  </p>
<ol>
<li>看到巢狀物件考慮拆成多個小查詢。</li>
<li>巢狀部分的資料量很大或預期會快速成長時，拆成小查詢可能比較好。</li>
<li>巢狀部分的資料量很小且幾乎不會增長時，不拆可能程式碼會比較整潔。</li>
<li>拆與不拆之間，要綜合考量可讀性、效能差異幅度、資料是否會增長…等多個要素，也可將 ORM 所產生的 SQL 印出來後分析以協助判斷。</li>
</ol>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p>ChatGPT</p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 SourceBrowser 建立原始碼瀏覽網站]]></title>
      <url>/content/20230312-use-source-browser.html</url>
      <content type="html"><![CDATA[<p><a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">Reference Source</a> 是一個非常方便的資源可以用來查看 .NET Framework 的程式碼，而這個網站是利用 <a href="https://github.com/KirillOsenkov/SourceBrowser" target="_blank" rel="noopener">SourceBrowser</a> 所建立的。  </p>
<p>對於我們自己開發的專案，雖然都有原始碼好像用不到這個工具，但很多時候想快速查看程式碼卻又不想耗費資源在執行 IDE 上的時候(尤其同時維護多專案的時候)，這個工具能提供一個不錯的介面來使用。</p>
<p>官方提供了基本的使用教學，但要開 Visual Studio 來編譯 SourceBrowser 專案，比較不方便，所以這邊會使用官方也有提供的 <a href="https://www.nuget.org/packages/SourceBrowser" target="_blank" rel="noopener">NuGet Package</a> 來做，稍微紀錄一下過程，讓之後需要的時候能更快的使用。</p>
<a id="more"></a>
<h3 id="基本使用步驟"><a href="#基本使用步驟" class="headerlink" title="基本使用步驟"></a>基本使用步驟</h3><h4 id="下載-NuGet-Package"><a href="#下載-NuGet-Package" class="headerlink" title="下載 NuGet Package"></a>下載 NuGet Package</h4><p>下載  <a href="https://www.nuget.org/packages/SourceBrowser" target="_blank" rel="noopener">NuGet Package</a> 後解壓縮後只留下 tools 資料夾。</p>
<h4 id="使用-HtmlGenerator-exe-來建立資料"><a href="#使用-HtmlGenerator-exe-來建立資料" class="headerlink" title="使用 HtmlGenerator.exe 來建立資料"></a>使用 HtmlGenerator.exe 來建立資料</h4><p>根據 <a href="https://github.com/KirillOsenkov/SourceBrowser/blob/main/GenerateTestSite.cmd" target="_blank" rel="noopener">GenerateTestSite.cmd</a> 可以知道我們需要用 HtmlGenerator.exe 來解析目標專案並輸出到指定目錄下，如下範例：<br><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tools\HtmlGenerator.exe <span class="string">"MyGithub\MoreNet.Cryptography\MoreNet.Cryptography.sln"</span> /out:tools\site</span><br></pre></td></tr></table></figure></p>
<h4 id="將輸出結果佈署到伺服器上"><a href="#將輸出結果佈署到伺服器上" class="headerlink" title="將輸出結果佈署到伺服器上"></a>將輸出結果佈署到伺服器上</h4><p>根據 <a href="https://github.com/KirillOsenkov/SourceBrowser/blob/main/RunTestSite.cmd" target="_blank" rel="noopener">RunTestSite.cmd</a> 可以知道我們需要使用 Microsoft.SourceBrowser.SourceIndexServer.dll 來啟動 SourceBrowser 站台 (也可以直接執行 Microsoft.SourceBrowser.SourceIndexServer.exe)，例如：<br><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet Microsoft.SourceBrowser.SourceIndexServer.dll</span><br></pre></td></tr></table></figure></p>
<p>如果是在本機執行，從瀏覽器瀏覽 <a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> 就可以看到結果了，也可以佈署到伺服器上提供線上查詢。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>相關的指令可以自己寫成 <code>*.bat</code> 檔方便重複使用。</li>
<li>產生出來的內容至少依賴 dotnet，詳細資訊見官方說明，我本機上環境太雜沒辦法精準驗證需要哪些依賴。</li>
<li>可能還有其他使用方式和參數，但目前不急著知道所以需要的時候再看 GitHub 就好</li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>雖然從 GitHub 或其他線上儲存庫就能直接看程式碼，但是 SourceBrowser 提供更強大的功能來查看程式碼之間的參考與依賴關係，還是能讓我們更有效率的查看程式碼。  </p>
<p>唯一美中不足的是它不是靜態網站且有一些框架的依賴，所以佈署成本滿高的。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://github.com/KirillOsenkov/SourceBrowser" target="_blank" rel="noopener">SourceBrowser</a></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 using 以及當例外從 finally 區塊拋出時的問題]]></title>
      <url>/content/20230311-problem-about-exception-from-finally-block-of-using.html</url>
      <content type="html"><![CDATA[<p>當我們想要使用實作 <code>IDisposable</code> 的型別時，<code>using</code> 關鍵字通常是不二人選，但是其中卻包含一些小陷阱 (嚴格來說不是陷阱，是實作 <code>IDisposable</code> 的時候沒做好)。</p>
<blockquote>
<p>背景知識:<br><code>using</code> 關鍵字就是 try-finally 加上呼叫 <code>IDisposable.Dispose()</code> 的語法糖，沒把握的話找個反組譯工具確認一下就知道了。</p>
</blockquote>
<a id="more"></a>
<h3 id="有可能的問題"><a href="#有可能的問題" class="headerlink" title="有可能的問題"></a>有可能的問題</h3><h4 id="捕捉不到的例外"><a href="#捕捉不到的例外" class="headerlink" title="捕捉不到的例外"></a>捕捉不到的例外</h4><p>首先，用下面的範例程式來說明：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// caller</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> f = <span class="keyword">new</span> Foo())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// exception thrown here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// never executed from here.</span></span><br></pre></td></tr></table></figure>
<p>我們有一個實作 <code>IDisposable</code> 的類別，這個類別模擬在 <code>Dispose</code> 方法中拋出例外，而上面的程式碼因為 <code>Foo.Dispose()</code> 拋出例外而使得看起來能正常捕捉例外的程式碼其實是會有漏洞的。</p>
<h4 id="拋出預期外的例外"><a href="#拋出預期外的例外" class="headerlink" title="拋出預期外的例外"></a>拋出預期外的例外</h4><p>那如果把 try-catch 區塊移到 using 外呢？以下方程式來說明：  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// caller</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> f = <span class="keyword">new</span> Foo())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// got exception from Foo.Dispose() and missing the one from try block.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一樣的 <code>Foo</code>，不一樣的呼叫端，但是這樣使用會造成呼叫端的 catch 區塊中捕捉到的例外其實是 <code>Foo.Dispose()</code> 拋出的例外，這意味著<strong>當呼叫端程式發生例外時，錯誤根本不會被捕捉到</strong>，也就代表當 Production Issue 發生時，會完全看不到呼叫端程式真正的例外，在有時間壓力下發生這種事是很可怕的。</p>
<h4 id="問題總結"><a href="#問題總結" class="headerlink" title="問題總結"></a>問題總結</h4><p>這件事的根本原因是因為在 <code>using</code> 的 finally 區塊中拋出例外使得呼叫端誤以為自己有考慮到所有例外，或是呼叫端誤以為自己能捕捉到 try 區塊中的例外，但其實不然。</p>
<h3 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h3><h4 id="服務提供方確保-IDisposable-Dispose-不拋出例外"><a href="#服務提供方確保-IDisposable-Dispose-不拋出例外" class="headerlink" title="服務提供方確保 IDisposable.Dispose() 不拋出例外"></a>服務提供方確保 <code>IDisposable.Dispose()</code> 不拋出例外</h4><p>如果要實作 <code>IDisposable</code>，必須確保 <code>IDisposable.Dispose()</code> 方法中不會拋出例外。</p>
<h4 id="不推薦-呼叫端避免使用-using"><a href="#不推薦-呼叫端避免使用-using" class="headerlink" title="(不推薦) 呼叫端避免使用 using"></a>(不推薦) 呼叫端避免使用 <code>using</code></h4><p>就是用手動釋放資源取代 <code>using</code>，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// release in anther way instead of calling Dispose()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般來說，這個問題應該是服務提供方應該要注意的，所以除非確定服務提供方有這個缺陷且沒辦法要求改正，不然不推薦將這種作法作為預設選項。</p>
<h4 id="很不推薦-呼叫端用多個-try-catch-暴力解"><a href="#很不推薦-呼叫端用多個-try-catch-暴力解" class="headerlink" title="(很不推薦) 呼叫端用多個 try-catch 暴力解"></a>(很不推薦) 呼叫端用多個 try-catch 暴力解</h4><p>很不推薦的做法，雖然簡單但太過暴力，很醜且維護的人很容易覺得這是多餘的而拆掉其中一個 try-catch 區塊。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> f = <span class="keyword">new</span> Foo())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>會想寫這篇是源於<a href="https://learn.microsoft.com/en-us/dotnet/framework/wcf/samples/use-close-abort-release-wcf-client-resources" target="_blank" rel="noopener">這個已知的問題</a>，但我覺得這是微軟的鍋，不應該因噎廢食而放棄 <code>using</code>，但萬一遇到了，還是要知道有這個現象來避免鬼打牆找不到問題，所以需要紀錄一下來加強印象。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://learn.microsoft.com/en-us/dotnet/framework/wcf/samples/use-close-abort-release-wcf-client-resources" target="_blank" rel="noopener">Close and Abort release resources safely when network connections have dropped</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hangfire 搭配 Redis 時的資料清理機制]]></title>
      <url>/content/20230114-auto-delete-jobs-for-hangfire-with-redis.html</url>
      <content type="html"><![CDATA[<p>Hangfire 是很常用的定時排程工具，他會將排程和任務資訊紀錄在資料庫中，但是如果使用 Redis 做資料儲存時，就必須謹慎思考資料清理的問題，畢竟資料存放在記憶體中是不可能不去限制大小的。</p>
<a id="more"></a>
<h3 id="限制資料筆數"><a href="#限制資料筆數" class="headerlink" title="限制資料筆數"></a>限制資料筆數</h3><p>使用 <a href="https://github.com/marcoCasamento/Hangfire.Redis.StackExchange" target="_blank" rel="noopener">Hangfire.Redis.StackExchange</a> 的話，可以透過 <code>RedisStorageOptions</code> 中的 <code>SucceededListSize</code> 和 <code>DeletedListSize</code> 兩個欄位來限制成功和已刪除的任務的列表長度，避免無限制的增長。  </p>
<p>但是問題是在於失敗的任務怎麼辦?</p>
<p>一開始找了很多網路文章，通常都是建議用 <a href="https://docs.hangfire.io/en/latest/extensibility/using-job-filters.html" target="_blank" rel="noopener">Job Filters</a> 來設定，雖然看起來很合理但實測卻發現失敗列表不可以手動刪除，最後才發現可以透過 <code>AutomaticRetryAttribute</code> 來達到目標。  </p>
<p>這個做法的主要邏輯是在重試次數結束後刪除，使得任務進入已刪除列表，而已刪除列表是可以設定最大長度的， <code>AutomaticRetryAttribute</code> 可以單獨用在需要的排程上，也可以一次設定到所有排程，如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services</span><br><span class="line">        .AddHangfire((serviceProvider, config) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            config</span><br><span class="line">                .UseFilter(<span class="keyword">new</span> AutomaticRetryAttribute &#123; Attempts = <span class="number">0</span>, OnAttemptsExceeded = AttemptsExceededAction.Delete &#125;)</span><br><span class="line">                ;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>失敗列表不能手動刪除的這個限制滿合理的，畢竟有重試機制存在，如果可以手動刪除那等於是和重試機制產生衝突了，倒是刪除失敗任務的設定在重試機制的設定中這點滿讓人意外的。  </p>
<p>然後網路的解法不能盡信，要實驗過才知道能不能運作。</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[透過 GET 發送 HTTP Request 的時候 Uri 過長的問題]]></title>
      <url>/content/20230114-resolve-url-too-long-exception.html</url>
      <content type="html"><![CDATA[<p>很多時候我們需要從客戶端從透過 HTTP GET 發送 Reqeust 給服務端，但在之前的一個 ASP.NET Core 的專案中卻因為 Uri 過長而出現了 <code>Invalid URI: The uri string is too long</code> 這樣的錯誤訊息。  </p>
<p>這個問題網路上幾乎都是改 Web Service (例如: IIS) 的設定來解決，這是最簡單方便的方法，但如果伺服器很多或是需要經常擴充伺服器時就會造成不小的困擾，即使伺服器不多也可能因為這些瑣碎的設定造成維護上的不方便，所以這邊提供另外一種解決方案。</p>
<a id="more"></a>
<h3 id="X-Http-Method-Override"><a href="#X-Http-Method-Override" class="headerlink" title="X-Http-Method-Override"></a>X-Http-Method-Override</h3><h4 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h4><p>X-Http-Method-Override 這個 Header 典型的用法是用於用戶端因為各種限制而無法配合服務端的要求使用特定 HTTP Method 時，以<a href="https://www.hanselman.com/blog/http-put-or-delete-not-allowed-use-xhttpmethodoverride-for-your-rest-service-with-aspnet-web-api" target="_blank" rel="noopener">這篇文章</a>為例， 服務端要求的是 <code>PUT /api/Person/4</code>，但客戶端無法配合時，就可以改用 <code>POST /api/Person/4</code> 搭配 X-Http-Method-Override 這個 Header (值為 PUT) 來改變實際上的 HTTP Method，這可以不需要遷就客戶端而讓服務端的設計保持一致且合理。  </p>
<p>利用這個特性，我們可以試著讓呼叫端改用 HTTP POST 來發送以避開 Web Server 對 Uri 的長度限制。</p>
<blockquote>
<p>同理，對 QueryString 的長度限制也適用。</p>
</blockquote>
<h4 id="實做"><a href="#實做" class="headerlink" title="實做"></a>實做</h4><p>首先，從<a href="https://vnextcoder.wordpress.com/2018/06/05/how-to-allow-http-method-override-dotnet-core/" target="_blank" rel="noopener">這篇文章</a>我們可以知道 ASP.NET Core 有提供相關的功能來支援 X-Http-Method-Override，但仔細看 <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpOverrides/src/HttpMethodOverrideExtensions.cs#L20" target="_blank" rel="noopener">UseHttpMethodOverride</a> 和 <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpOverrides/src/HttpMethodOverrideMiddleware.cs#L13" target="_blank" rel="noopener">HttpMethodOverrideMiddleware</a> 的實做可以發現這並不足以滿足我們的需求，HttpMethodOverrideMiddleware 的實做只包含改變 HTTP Method 但不包含處理 Body 或 QueryString。</p>
<p>但至少我們知道 ASP.NET Core 對於 X-Http-Method-Override 的支援是透過 Middleware 來完成的，這樣我們就可以自己寫 Middleware 來達到想要的效果。</p>
<p><strong>建立另外一個 Middleware 來處理 Body 的部分: </strong><br>框架內建的部份我們就沿用就好，所以自製的 Middleware 只需要處理 Body。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpGetOverrideMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> XHttpMethodOverride = <span class="string">"X-Http-Method-Override"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpGetOverrideMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xHttpMethodOverrideValue = context.Request.Headers[XHttpMethodOverride];</span><br><span class="line">        <span class="keyword">if</span> (HttpMethods.IsGet(xHttpMethodOverrideValue))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* pseudo code</span></span><br><span class="line"><span class="comment">            var body = ReadFromRequestBody();</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            string anotherQueryString = string.Empty();</span></span><br><span class="line"><span class="comment">            if (isJson)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                anotherQueryString = ParseBodyFromJsonToQueryString();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else if (isXml)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                anotherQueryString = ParseBodyFromXmlToQueryString();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else if (whatever)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                anotherQueryString = ParseBodyFromWhateverToQueryString();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            context.Request.QueryString += anotherQueryString;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            ClearBody(); // if possible</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>註冊並使用: </strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        app.UseHttpMethodOverride();</span><br><span class="line">        app.UseMiddleware&lt;HttpGetOverrideMiddleware&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，在 Middleware 那一層將 Body 轉換成 QueryString 再繼續，這樣一來 Web API 的規格仍然是合理的 HTTP GET， 呼叫端也可以透過 HTTP POST 加上 X-Http-Method-Override 來呼叫到只支援 HTTP GET 的 API。</p>
<p><strong>注意事項: </strong>  </p>
<ul>
<li>將 Body 轉換為 QueryString 的過程有很多瑣碎的細節要考慮<ul>
<li>如果原本的 Uri 就包含 QueryString 的話(不合理，但技術上可能發生)不能覆蓋掉</li>
<li>Body 讀取後要不要把內容清空?</li>
<li>不清空 Body 的話要不要允許後面的程式能重複讀取 Body? 這會影響 Body 讀取後要不要回捲</li>
<li>Body 資料無法用 QueryString</li>
</ul>
</li>
<li>將 Body 轉換為 QueryString 後整個 Uri 會很長，後面的程式直接操作時要小心避免因過長拋出例外，例如:<br><code>new Uri(string)</code> 就有機會因為長度太長而拋出例外。</li>
<li>Startup 中呼叫 <code>UseHttpMethodOverride()</code> 和註冊 <code>HttpGetOverrideMiddleware</code> 的順序，誰先誰後比較合理?</li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這個做法看起來有點暴力，但因為 ASP.NET Core 也是用這樣的方式支援 X-Http-Method-Override 的，所以就跟隨原有的做法下去擴充了。  </p>
<p>另外值得一提的是， ASP.NET Core 的很多功能 (例如: Health checks) 背後其實都是封裝 Middleware 後提供一個較易用或可讀性較高的 API，知道這點後也能了解很多類似的功能都可以用 Middleware 來實現，只要小心不要弄錯執行順序的話是很好用的。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://www.hanselman.com/blog/http-put-or-delete-not-allowed-use-xhttpmethodoverride-for-your-rest-service-with-aspnet-web-api" target="_blank" rel="noopener">HTTP PUT or DELETE not allowed? Use X-HTTP-Method-Override for your REST Service with ASP.NET Web API</a>  </p>
<p><a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpOverrides/src/HttpMethodOverrideMiddleware.cs#L13" target="_blank" rel="noopener">HttpMethodOverrideMiddleware.cs</a>  </p>
<p><a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpOverrides/src/HttpMethodOverrideExtensions.cs#L20" target="_blank" rel="noopener">HttpMethodOverrideExtensions.cs</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[避免在需要使用 EF Core 的環境擴充 IEnumerable< T >]]></title>
      <url>/content/20221115-do-not-let-extension-methods-of-generic-ienumerable-work-with-efcore.html</url>
      <content type="html"><![CDATA[<p>擴充方法是很常用的技巧, 之前在使用 Entity Framework Core 的時候, 擴充了一個 <code>IQueryable&lt;T&gt;</code> 的擴充方法 <code>WhereIf()</code>, 後來想說這個方法也適用於其他衍生自 <code>IEnumerable&lt;T&gt;</code> 的型別, 且 <code>IQueryable&lt;T&gt;</code> 繼承了 <code>IEnumerable&lt;T&gt;</code>, 所以把 <code>WhereIf()</code> 方法改成 <code>IEnumerable&lt;T&gt;</code> 的擴充方法以求更廣的適用範圍, 沒想到一切都不一樣了, 要是當時沒及時發現就引爆了一個效能核彈了.  </p>
<blockquote>
<p>雖然標題是寫 Entity Framework Core, 但 <code>IQueryable&lt;T&gt;</code> 本來就是設計給”資料查詢”的情境來說, 其他 ORM 八九不離十會遇到一樣的現象.  </p>
</blockquote>
<a id="more"></a>
<h3 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h3><p>以下面的程式碼為範例來說明:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adults = _dbContext.Set&lt;Person&gt;() <span class="comment">// DbSet&lt;Person&gt;</span></span><br><span class="line">    .Where(r =&gt; r.Age &gt;= <span class="number">18</span>)          <span class="comment">// Append condition, IQueryable&lt;Person&gt;</span></span><br><span class="line">    .ToList();                        <span class="comment">// Query</span></span><br></pre></td></tr></table></figure>
<p>我們知道在 <code>ToList()</code> 被呼叫前的行為都只是在組合查詢條件, 不會真正去查資料, 基於這個前提如一開始描述擴充一個 <code>IEnumerable&lt;T&gt;</code> 的擴充方法 <code>WhereIf(...)</code> 來方便使用, 如下:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnumerableExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;T&gt; WhereIf&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; query, Func&lt;T, <span class="keyword">bool</span>&gt; predicate, <span class="keyword">bool</span> shouldAppendWhere)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldAppendWhere)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query.Where(predicate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adults = _dbContext.Set&lt;Person&gt;()</span><br><span class="line">    .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) <span class="comment">// Optional filter</span></span><br><span class="line">    .Where(r =&gt; r.Age &gt;= <span class="number">18</span>)</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure>
<p>雖然執行結果沒錯, 但這樣做會有個很嚴重的問題, 以上面的例子來說, 當 <code>WhereIf(...)</code> 被呼叫時會從資料來源查詢資料, 以 Oracle 來說就是執行了 <code>SELECT * FROM PERSON</code> 的查詢將 Person 資料表的 <strong>所有資料</strong> 搜尋出來後才在應用程式中做後續的篩選和處理.  </p>
<h3 id="為什麼會有這個現象"><a href="#為什麼會有這個現象" class="headerlink" title="為什麼會有這個現象?"></a>為什麼會有這個現象?</h3><p>其實從 <code>IQeueryable&lt;T&gt;</code> 和 <code>IEnumerable&lt;T&gt;</code> 的用途與差別大概就能推測出會有這樣的結果了, 不過出於好奇還是稍微實驗一下看會不會有更明確的答案.  </p>
<p>實驗程式碼如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;T&gt; WhereIf&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; query, Func&lt;T, <span class="keyword">bool</span>&gt; predicate, <span class="keyword">bool</span> shouldAppendWhere)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldAppendWhere)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query.Where(predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyQueryable&lt;T&gt; : IQueryable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Type ElementType =&gt; <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Expression Expression =&gt; <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IQueryProvider Provider =&gt; <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; query1 = <span class="keyword">new</span> MyQueryable&lt;<span class="keyword">int</span>&gt;().WhereIf(r =&gt; r &gt; <span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; query2 = <span class="keyword">new</span> MyQueryable&lt;<span class="keyword">int</span>&gt;().WhereIf(r =&gt; r &gt; <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"Correct here."</span>.Dump();</span><br><span class="line"><span class="comment">// NotImplementedException("a")</span></span><br><span class="line">query1.Dump();</span><br><span class="line"></span><br><span class="line"><span class="comment">// NotImplementedException("b")</span></span><br><span class="line">query2.Dump();</span><br></pre></td></tr></table></figure></p>
<p>經過實驗, 可以看到有加其他條件和直接轉型的情境會分別呼叫到兩個不同的 <code>GetEnumerator()</code> 方法, 翻了一下 Entity Framework Core 的原始碼可以發現 <a href="https://github.com/dotnet/efcore/blob/main/src/EFCore/Internal/InternalDbSet.cs#L459" target="_blank" rel="noopener">InternalDbSet<t> 中的兩個 GetEnumerator() 方法的實作</t></a> 最後都會呼叫到 <code>CreateEntityQueryable()</code> 方法且回傳一個 <code>EntityQueryable&lt;T&gt;</code> 型別的物件, 接著從 <a href="https://github.com/dotnet/efcore/blob/c771d25cd11a27d268cc7d4fdeeba3c4c4203386/src/EFCore/Query/Internal/EntityQueryable%60.cs#L86" target="_blank" rel="noopener">EntityQueryable<t> 中相關的方法</t></a> 的實作大概就可以<strong>推測</strong>到會去執行查詢了.  </p>
<blockquote>
<p><strong>也就是說, 只要觸發 GetEnumerator() 方法的呼叫, 就會引發資料查詢.</strong>  </p>
<p>這部分這樣推測是比較粗糙的作法, 嚴格來說應該是要找到真的去執行的程式碼才能證實, 但因為實測已經知道結果了, 加上懶得在家建立完整的環境追蹤, 所以就沒堅持要找到最底層.  </p>
</blockquote>
<h3 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h3><h4 id="方案一-同時擴充-IQueryable-lt-T-gt-和-IEnumerable-lt-T-gt"><a href="#方案一-同時擴充-IQueryable-lt-T-gt-和-IEnumerable-lt-T-gt" class="headerlink" title="方案一 : 同時擴充 IQueryable&lt;T&gt; 和 IEnumerable&lt;T&gt;"></a>方案一 : 同時擴充 <code>IQueryable&lt;T&gt;</code> 和 <code>IEnumerable&lt;T&gt;</code></h4><p>如下範例:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">QueryableExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IQueryable&lt;T&gt; WhereIf&lt;T&gt;(<span class="keyword">this</span> IQueryable&lt;T&gt; query, Expression&lt;Func&lt;T, <span class="keyword">bool</span>&gt;&gt; predicate, <span class="keyword">bool</span> shouldAppendWhere)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldAppendWhere)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query.Where(predicate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnumerableExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;T&gt; WhereIf&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; query, Func&lt;T, <span class="keyword">bool</span>&gt; predicate, <span class="keyword">bool</span> shouldAppendWhere)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldAppendWhere)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query.Where(predicate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adults = _dbContext.Set&lt;Person&gt;()</span><br><span class="line">    .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) <span class="comment">// Optional filter</span></span><br><span class="line">    .Where(r =&gt; r.Age &gt;= <span class="number">18</span>)</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure></p>
<p>雖然同時擴充 <code>IQueryable&lt;T&gt;</code> 和 <code>IEnumerable&lt;T&gt;</code> 可以解決問題, 但這有幾個缺點:  </p>
<ol>
<li>因為 <code>DbSet&lt;T&gt;</code> 實作了 <code>IQueryable&lt;T&gt;</code>, 而 <code>IQueryable&lt;T&gt;</code> 繼承了 <code>IEnumerable&lt;T&gt;</code>, 所以編譯時優先使用 <code>IQueryable&lt;T&gt;</code> 的擴充方法, 雖然符合預期, 但完全依賴於編譯時的優先順序, 非常隱晦.  </li>
<li>考慮到搭配選擇性引數 (Optional Arguments) 使用時, 很容易在無意間因為一點小改動而導致使用了 <code>IEnumerable&lt;T&gt;</code> 的擴充方法而沒發現.  </li>
<li>萬一維護過程將 <code>IQueryable&lt;T&gt;</code> 的擴充方法移除或重新命名, 呼叫端還是可以正確編譯的, 但會變成呼叫了 <code>IEnumerable&lt;T&gt;</code> 的擴充方法, 而且很難意識到這個問題.  </li>
</ol>
<blockquote>
<p><strong>這是個有用且支援範圍廣但需要謹慎維護的解決方案, 適合非常嚴謹的團隊.</strong>  </p>
<p>事實上, dotnet runtime 就是同時做了 <a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Linq.Queryable/src/System/Linq/Queryable.cs#L47" target="_blank" rel="noopener"><code>IEnumerable&lt;T&gt;</code> 版本的 <code>Where()</code> 擴充方法</a> 和 <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Linq/src/System/Linq/Where.cs#L12" target="_blank" rel="noopener"><code>IQueryable&lt;T&gt;</code> 版本的 <code>Where()</code> 擴充方法</a></p>
</blockquote>
<h4 id="方案二-只擴充-IQueryable-lt-T-gt"><a href="#方案二-只擴充-IQueryable-lt-T-gt" class="headerlink" title="方案二 : 只擴充 IQueryable&lt;T&gt;"></a>方案二 : 只擴充 <code>IQueryable&lt;T&gt;</code></h4><p>如下範例:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">QueryableExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IQueryable&lt;T&gt; WhereIf&lt;T&gt;(<span class="keyword">this</span> IQueryable&lt;T&gt; query, Expression&lt;Func&lt;T, <span class="keyword">bool</span>&gt;&gt; predicate, <span class="keyword">bool</span> shouldAppendWhere)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldAppendWhere)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> query.Where(predicate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adults = _dbContext.Set&lt;Person&gt;()</span><br><span class="line">    .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) <span class="comment">// Optional filter</span></span><br><span class="line">    .Where(r =&gt; r.Age &gt;= <span class="number">18</span>)</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure></p>
<p>這樣做不容易出錯, 但也有一個缺點 - 對於衍生自 <code>IEnumerable&lt;T&gt;</code> 的型別不友善.  </p>
<p>以下面範例來說, 需要透過 <code>AsQueryable()</code> 方法轉型後才能使用.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSource = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line"><span class="keyword">var</span> adults = dataSource</span><br><span class="line">    .AsQueryable()</span><br><span class="line">    .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) <span class="comment">// Optional filter</span></span><br><span class="line">    .Where(r =&gt; r.Age &gt;= <span class="number">18</span>)</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>是個支援範圍比較窄, 但是維護風險較低的做法, 適合無法保證謹慎維護的專案.</strong>  </p>
</blockquote>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>整體來說, 如果可能會被任何需要 ORM 的用戶端程式呼叫到, 優先避免做 <code>IEnumerable&lt;T&gt;</code> 的擴充方法, 真的需要的話要考慮如果會被 <code>IQueryable&lt;T&gt;</code> 的衍生類別呼叫到就必須連同 <code>IQueryable&lt;T&gt;</code> 的擴充方法一起做.  </p>
<p>還好在確認 ORM 產生的 SQL Script 內容時就即時發現, 不然等到上 production 才爆發就真的很難找到這麼隱晦的問題來源了.  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[遠端連線時支援"部份多螢幕"]]></title>
      <url>/content/20220925-use-some-of-monitors-for-remote.html</url>
      <content type="html"><![CDATA[<p>使用 Windows 內建的遠端連線工具 (Remote Desktop Connection) 如果需要支援雙螢幕的話需要做一些設定，這些網路上資源很多沒什麼好說的。  </p>
<p>但是如果是想要只使用三個螢幕中的其中兩個螢幕呢?</p>
<a id="more"></a>
<h3 id="手動編輯-rdp-檔案"><a href="#手動編輯-rdp-檔案" class="headerlink" title="手動編輯 .rdp 檔案"></a>手動編輯 .rdp 檔案</h3><p>RDP 的圖形化介面沒有提供部分多螢幕的設定，只能將 <code>*.rdp</code> 檔案用文字編輯器打開後編輯。  </p>
<p>增加設定如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use multimon:i:1</span><br><span class="line">selectedmonitors:s:0,1</span><br></pre></td></tr></table></figure></p>
<p>意思是支援多螢幕，然後套用到 0、1 兩個螢幕，不確定 0、1 怎麼編號的，但是要用的時候試一下就好也就不仔細追究了。  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>很空虛的一篇，但是不是太熱門的問題不想之後需要又要到處找所以還是隨手紀錄一下。  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://superuser.com/a/1555631/809665" target="_blank" rel="noopener">remote desktop connection on 2 out of 3 monitors</a></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在本機上建立 NuGet 儲存庫]]></title>
      <url>/content/20220924-local-nuget-package-repository.html</url>
      <content type="html"><![CDATA[<p>最近的一個大專案剛好有機會重新打造基礎建設，於是便將常用與各種擴充功能做成套件發佈到內部的 NuGet 儲存庫，但有一個問題是因為套件上傳後就不應該再重新佈署同一個版本，如果新的套件開發初期有頻繁的設計變更會經常引發 breaking change，造成版本號增加的很快，即便不是設計變更，一有小 bug 或是小變更就急著跑流程發新版也是很浪費時間。  </p>
<p>所以就有了一個想法，如果能在本機上建立 NuGet 套件儲存庫，這樣就能先在本機上試用確認設計適當且品質夠好，再將正式版發佈到真正的 NuGet 儲存庫上。  </p>
<a id="more"></a>
<h3 id="在本機上建立-NuGet-儲存庫"><a href="#在本機上建立-NuGet-儲存庫" class="headerlink" title="在本機上建立 NuGet 儲存庫"></a>在本機上建立 NuGet 儲存庫</h3><p>其實很簡單，用 Visual Studio 開發的話幾個步驟就好了:  </p>
<ul>
<li>打開 NuGet Package 管理介面</li>
<li>依照下圖步驟指定資料夾</li>
<li>最後只要將包好的 <code>*.nupkg</code> 檔案放到資料夾中，就能從 NuGet Package 管理介面下載了。</li>
</ul>
<img src="/content/20220924-local-nuget-package-repository/step1.png">   
<h3 id="NuGet-下載後的儲存位置"><a href="#NuGet-下載後的儲存位置" class="headerlink" title="NuGet 下載後的儲存位置"></a>NuGet 下載後的儲存位置</h3><p>如果從本機開發，版號部分可以後綴個 <code>-local-v1</code> (這部分隨變加後綴是因為是本機臨時版不會真的上線，正式版要有<a href="https://semver.org/lang/zh-TW/" target="_blank" rel="noopener">嚴謹的定版規則</a>)，這樣就可以頻繁修改直到確定要發行後再上線，但這樣缺點就是會留一大堆臨時版的資料在本機上，讓人覺得很礙眼。  </p>
<p>這時候就可以從 <code>%USERPROFILE%\.nuget\packages</code> (我這邊完整路徑是 <code>C:\Users\{user}\.nuget\packages</code>) 中找到下載來的套件，可以開發完後順手清一下臨時版的資料，免得留一堆垃圾佔空間。  </p>
<blockquote>
<p>其實一開始是每個臨時版都是用一樣的版號，然後再手動到下載資料夾中清掉舊的重新下載一次，但是畢竟不是正常的操作方式，而且常常這樣做也是很繁瑣，所以還是用不同的版號比較好，等正式版要上前再去清垃圾就好了，另一方面也能養成不重覆發行相同版本套件的正確習慣。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[依字位 (grapheme) 處理字串 (2)]]></title>
      <url>/content/20220828-grapheme-cluster-string-2.html</url>
      <content type="html"><![CDATA[<p>前陣子在 <a href="/content/20220528-grapheme-cluster-string.html" title="依字位 (grapheme) 處理字串">依字位 (grapheme) 處理字串</a> 這篇文章中有以越南文為例提到 grapheme 的問題，後來覺得 <code>TextElementEnumerator</code> 提供的方法不夠多，所以基於他另外封裝了一個仿 <code>String</code> 的類別，折騰了幾天常用的都寫得差不多了才發現繞遠路做了不少原本 <code>string</code> 就有提供的功能。  </p>
<a id="more"></a>
<h3 id="主要問題"><a href="#主要問題" class="headerlink" title="主要問題"></a>主要問題</h3><p>主要問題是因為 unicode 的幾種不同的標準化格式，導致字面上一樣的字其實是不同的內容，造成字串在比對的時候 (<code>==</code> 運算子) 會認為雙方是不同的字。  </p>
<p>關於標準化格式就放連結在這邊就好，要看再慢慢看:  </p>
<ul>
<li><a href="https://unicode.org/reports/tr15/" target="_blank" rel="noopener">UNICODE NORMALIZATION FORMS</a>  </li>
<li><a href="https://blog.sean.taipei/2021/12/unicode" target="_blank" rel="noopener">Unicode Normalization 文字標準化</a>  </li>
</ul>
<h3 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h4><p>其實 <code>String</code> 提供的不少方法就有包含到這個問題，通常透過方法中的 <code>StringComparison</code> 或 <code>CultureInfo</code> 參數來做。</p>
<h4 id="String-Normalize"><a href="#String-Normalize" class="headerlink" title="String.Normalize(...)"></a><code>String.Normalize(...)</code></h4><p>這個方法可以將字串轉為特定的標準化格式，轉換後可以直接比對字串不需要考慮格式問題</p>
<blockquote>
<p>避免用 <code>String.Normalize(...)</code> 做字串取代後輸出，轉化後的內容和輸入內容不同這樣做容易出意外，例如: 預期沒有要取代的內容卻被轉化成不同的格式後輸出。</p>
</blockquote>
<h3 id="用-TextElementEnumerator"><a href="#用-TextElementEnumerator" class="headerlink" title="用 TextElementEnumerator"></a>用 <code>TextElementEnumerator</code></h3><p>這就和之前那篇一樣了。 </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>優先使用 <code>string</code> 提供的方法，包含 <code>String.Normalize(...)</code>，兩者都不合用時再考慮 <code>TextElementEnumerator</code>，不要一開始就繞遠路。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netstandard-2.1#char-objects-and-unicode-characters" target="_blank" rel="noopener">Char objects and Unicode characters</a>  </p>
<p><a href="https://unicode.org/reports/tr15/" target="_blank" rel="noopener">UNICODE NORMALIZATION FORMS</a>  </p>
<p><a href="https://blog.sean.taipei/2021/12/unicode" target="_blank" rel="noopener">Unicode Normalization 文字標準化</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在 RoslynPad 中使用 MeasureIt 做基準測試 (benchmarking)]]></title>
      <url>/content/20220818-use-measureit-in-roslynpad-for-benchmarking.html</url>
      <content type="html"><![CDATA[<p>BenchmarkDotNet 是一個很熱門的工具可以用來簡單的量測與比較程式碼的效能，但是有時候我們只是想要快速測試一段程式碼的執行時間，這時候還要開 IDE 使用 BenchmarkDotNet 就覺得有點厚重 (除非 BenchmarkDotNet 專案已經建好在方案中可以一邊開發一邊實驗)。  </p>
<p>這時候就想要在 RoslynPad 或 LinqPad 中使用基準測試工具，偏偏因為 RoslynPad 的限制而無法支援 BenchmarkDotNet，所以只能另外找一個替代方案 - MeasureIt。</p>
<a id="more"></a>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#r &quot;nuget:MeasureIt.exe/0.2.2&quot;</span><br><span class="line"></span><br><span class="line">using PerformanceMeasurement;</span><br><span class="line"></span><br><span class="line">var cost = LinqPadUX.Measure.Action(new Action(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    string s = string.Empty;</span><br><span class="line">    for (var i = 0; i &lt; 1000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s += i.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)).Dump();</span><br><span class="line"></span><br><span class="line">var costComparison = LinqPadUX.Measure.NamedActions(new List&lt;NamedAction&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    new NamedAction(&quot;string&quot;, () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        string s = string.Empty;</span><br><span class="line">        for (var i = 0; i &lt; 1000; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s += i.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new NamedAction(&quot;stringBuilder&quot;, () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        var sb = new StringBuilder();</span><br><span class="line">        for (var i = 0; i &lt; 1000; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(i.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">        var s = sb.ToString();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).Dump();</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>沒什麼難度，但是沒記一下的話很快就忘了，尤其這個替代方案不算熱門，沒有很好找。  </p>
<p>這個工具的功能比較精簡，如果真的要複雜的分析還是 BenchmarkDotNet 比較豐富。</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://github.com/roslynpad/roslynpad/issues/118#issuecomment-403788063" target="_blank" rel="noopener">Support BenchmarkDotNet</a>  </p>
<p><a href="http://ig2600.blogspot.com/2012/12/run-time-costs-of-small-operations-in-c.html" target="_blank" rel="noopener">Run time costs of small operations in C#</a>  </p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Model Binding 後讀取 Request.Body 的內容]]></title>
      <url>/content/20220626-read-form-body-after-model-binding.html</url>
      <content type="html"><![CDATA[<p>一般來說在 WebAPI 的專案中, 我們會偏好使用 Model Binding 的機制來綁定請求內容, 但是之前在一個特殊需求上卻遇到在 Model Binding 後仍然要讀取 <code>Request.Body</code> (型別是 <code>Stream</code>) 的內容.  </p>
<p>而問題在於, Form Post 的情境中, 在Model Binding 後 (在 Action 中) 讀取<code>Request.Body</code> 時會得到空的內容, 但是資料長度又是正確的 (而神奇的是 JSON 和 XML 情境是沒問題的).  </p>
<blockquote>
<p>這邊 Form Post, JSON 和 XML 情境是依 Content-Type 這個 Header 來分辨的.  </p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>這個需求是剛需, 因為這個 API 提供給外部廠商呼叫, 是不固定格式內容的, 所以 Body 中有可能是 Form, JSON ,XML, 甚至是自定義格式的, 比起客製 Model Binding 機制, 簡單的讀取 <code>Request.Body</code> 後再解析是比較容易上手的.  </p>
</blockquote>
<h3 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h3><p>這個症狀和 Sream 讀取後需要”倒帶” (rewind) 才能再讀取的特性很像, 但是在 Action 中又無法直接倒帶, 剛好之前有遇過類似的問題, 印象中是要額外設定才能開啟倒帶功能 (但我金魚腦忘了怎麼做).  </p>
<p>找了很久沒看到完全一樣的問題, 倒是看到一篇 <a href="https://stackoverflow.com/q/66817215" target="_blank" rel="noopener">類似的情境</a> 值得一試, 只需要簡單的在 <code>Startup.cs</code> 中如下啟用就好: </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Must before UseEndpoints() called.</span></span><br><span class="line">    app.Use(next =&gt; context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        context.Request.EnableBuffering();</span><br><span class="line">        <span class="keyword">return</span> next(context);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但有限制: </p>
<ul>
<li>一定要出現在 <code>UseEndpoints()</code> 被呼叫之前, 推測是因為 Middleware 的執行順序的緣故.  </li>
<li>不能在 Action 中才呼叫 <code>EnableBuffering()</code>, 也是合理, 畢竟都在所有 Middleware 後才呼叫, 就不符合上一個限制了, 但可惜目前還不知道是怎樣的運作機制讓倒帶這麼挑場合設定.  </li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>基本上能用 Model Binding 就盡量用, 沒特殊情境不需要特別去讀 Body Stream, 解析麻煩而且相對容易錯.  </p>
<p>這要是第一次遇到連關鍵字都沒有不知道會卡多久, 還好之前有先遇過 Stream 倒帶和 Reqeut Rewind 的情境, 真是謝天謝地.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/q/66817215" target="_blank" rel="noopener">IAsyncActionFilter, trying to log request body, but it is empty</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[關於物件和集合初始設定式]]></title>
      <url>/content/20220606-about-object-and-collection-initializers.html</url>
      <content type="html"><![CDATA[<p>寫 C# 也好幾年了, 對於物件和集合初始設定式的使用也很習慣, 也知道那是語法糖, 但是前陣子看到自訂類別要套用物件和集合初始設定式時, 才發現其實沒有想像中的熟, 所以想稍微再整理一下一些細節.  </p>
<a id="more"></a>
<p>首先, 其實<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers" target="_blank" rel="noopener">官方文件</a>已經非常完整的, 如果看過官方文件其實這邊就沒什麼好看的了.</p>
<p>也因為官方文件很完整, 所以這邊只會記一些平常沒被注意到的細節.  </p>
<h3 id="初始設定式的語法糖"><a href="#初始設定式的語法糖" class="headerlink" title="初始設定式的語法糖"></a>初始設定式的語法糖</h3><h4 id="Indexer-部分"><a href="#Indexer-部分" class="headerlink" title="Indexer 部分"></a>Indexer 部分</h4><p>以 <code>Dictionary</code> 為例<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta"><span class="meta-string">"k"</span></span>] = <span class="string">"v"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>編譯後的結果會接近下面的樣子, 去存取 Indexer.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">x[<span class="string">"k"</span>] = <span class="string">"v"</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Collection-部分"><a href="#Collection-部分" class="headerlink" title="Collection 部分"></a>Collection 部分</h4><p>以 List 為例<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"a"</span>,</span><br><span class="line">   <span class="string">"b"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>編譯後的結果會接近下面的樣子, 去存取 <code>Add()</code> 方法.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">x.Add(<span class="string">"a"</span>);</span><br><span class="line">x.Add(<span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="自定義類別套用初始設定式"><a href="#自定義類別套用初始設定式" class="headerlink" title="自定義類別套用初始設定式"></a>自定義類別套用初始設定式</h3><h4 id="Indexer-部分-1"><a href="#Indexer-部分-1" class="headerlink" title="Indexer 部分"></a>Indexer 部分</h4><p>如標題, <strong>重點就是要實作對應的 indexer</strong>.  </p>
<p>懶得自己想 Demo 了, 就偷一下官方的範例來改:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定義的物件與 indexer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[,] storage = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="keyword">this</span>[<span class="keyword">int</span> row, <span class="keyword">int</span> column]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; storage[row, column];</span><br><span class="line">        <span class="keyword">set</span> =&gt; storage[row, column] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> identity = <span class="keyword">new</span> Matrix</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">0, 0</span>] = <span class="number">1.0</span>,</span><br><span class="line">    [<span class="meta">0, 1</span>] = <span class="number">0.0</span>,</span><br><span class="line">    [<span class="meta">0, 2</span>] = <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">    [<span class="meta">1, 0</span>] = <span class="number">0.0</span>,</span><br><span class="line">    [<span class="meta">1, 1</span>] = <span class="number">1.0</span>,</span><br><span class="line">    [<span class="meta">1, 2</span>] = <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">    [<span class="meta">2, 0</span>] = <span class="number">0.0</span>,</span><br><span class="line">    [<span class="meta">2, 1</span>] = <span class="number">0.0</span>,</span><br><span class="line">    [<span class="meta">2, 2</span>] = <span class="number">1.0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// identity[0, 0] =&gt; 1</span></span><br><span class="line"><span class="comment">// identity[0, 1] =&gt; 0</span></span><br></pre></td></tr></table></figure>
<h4 id="Collection-部分-1"><a href="#Collection-部分-1" class="headerlink" title="Collection 部分"></a>Collection 部分</h4><p>兩個重點</p>
<ul>
<li><strong>必須實作 <code>System.Collections.IEnumerable</code> (或其衍生類別/介面)</strong>  <ul>
<li>這部分倒也不是初始設定式會用到, 只是不實作的話呼叫時就無法使用集合初始設定式.  </li>
<li><code>GetEnumerator()</code> 內容在初始設定式不會被呼叫到, 所以沒實作也不會壞, 但是還是應該要實作.</li>
</ul>
</li>
<li><strong>必須有 Add 方法</strong><ul>
<li>Add 方法參數對應的就是初始設定式中參數的數量, 例如 <code>{a, b, c}</code> 就是對應呼叫到 <code>Add(a, b, c)</code> 這個多載</li>
</ul>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定義的物件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NameCollection</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IList&lt;<span class="keyword">string</span>&gt; _names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">string</span> lastName</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _names.Add(<span class="string">$"<span class="subst">&#123;lastName&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">string</span> fistName, <span class="keyword">string</span> lastName</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _names.Add(<span class="string">$"<span class="subst">&#123;fistName&#125;</span> <span class="subst">&#123;lastName&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _names.GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> fullNames = <span class="keyword">new</span> NameCollection</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Add("Smith")</span></span><br><span class="line">    &#123;<span class="string">"Smith"</span>&#125;,</span><br><span class="line">	<span class="comment">// Add("John", "Smith")</span></span><br><span class="line">    &#123;<span class="string">"John"</span>, <span class="string">"Smith"</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這邊會需要用到實作的 IEnumerable.GetEnumerator()</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> f <span class="keyword">in</span> fullNames)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> fullName = f.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實使用上都很熟了, 但碰到自定義類別要套用初始設定式時, 一時之間會想不到怎麼做 (尤其時集合初始設定式), 所以這邊紀錄一下怎麼實作.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers" target="_blank" rel="noopener">Object and Collection Initializers</a>  </p>
<p><a href="https://riptutorial.com/csharp/example/160/collection-initializers-in-custom-classes" target="_blank" rel="noopener">Collection initializers in custom classes</a>  </p>
<p><a href="https://riptutorial.com/csharp/example/6054/collection-initializers-with-parameter-arrays" target="_blank" rel="noopener">Collection Initializers with Parameter Arrays</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[XML 序列化時有條件的忽略欄位]]></title>
      <url>/content/20220530-xml-serialization-conditional-ignore.html</url>
      <content type="html"><![CDATA[<p>之前遇到需要在 XML 序列化的過程中忽略值為空值或預設值的欄位, 查了一下才發現不太好找而且做法沒有很直覺.</p>
<a id="more"></a>
<h3 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h3><h4 id="bool-ShouldSerialize-PropertyName"><a href="#bool-ShouldSerialize-PropertyName" class="headerlink" title="bool ShouldSerialize{PropertyName}"></a><code>bool ShouldSerialize{PropertyName}</code></h4><p>建立回傳型別為 <code>bool</code> 的方法, 方法名稱必須為 ShouldSerialize 加上屬性名.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">M</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> S &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> N &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ShouldSerialize + S</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">ShouldSerializeS</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">string</span>.IsNullOrEmpty(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="唯獨屬性-PropertytName-Specified"><a href="#唯獨屬性-PropertytName-Specified" class="headerlink" title="唯獨屬性 {PropertytName}Specified"></a>唯獨屬性 <code>{PropertytName}Specified</code></h4><p>建立唯獨屬性, 名稱必須為屬性名加上 Specified, 有幾個細節:</p>
<ul>
<li>不一定要是唯獨屬性, 有 setter 也可以, 但是沒意義, 不要這樣做.  </li>
<li>Attribute <code>System.Xml.Serialization.XmlIgnore</code> 不是必要的 (因為唯獨), 但建議要加, 避免有人加了 setter 或其他因素而導致他被序列化, 閱讀時也多一個提示效果.  </li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">M</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> S &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> N &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        </span><br><span class="line">    [<span class="meta">System.Xml.Serialization.XmlIgnore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> NSpecified</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> N &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="呼叫端與綜合分析"><a href="#呼叫端與綜合分析" class="headerlink" title="呼叫端與綜合分析"></a>呼叫端與綜合分析</h4><p>簡單的呼叫端範例.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> m = <span class="keyword">new</span> M();</span><br><span class="line">        m.S = <span class="string">""</span>;</span><br><span class="line">        XmlSerializer xs = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(M));</span><br><span class="line">        StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        xs.Serialize(sw, m);</span><br><span class="line">        Console.WriteLine(sw.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>建議:  </p>
<ol>
<li>優先使用 <code>bool ShouldSerialize{PropertyName}</code> 方法, 主要原因是因為他名字比較好記也比較直覺, 另外一個做法比較麻煩.</li>
<li>將屬性和條件拆開成個獨立的檔案搭配 partial class, 範例如下: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// M.cs</span></span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">M</span></span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;        <span class="keyword">public</span> <span class="keyword">string</span> S &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&gt;        <span class="keyword">public</span> <span class="keyword">int</span> N &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;    <span class="comment">// M.Ignore.cs</span></span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">M</span></span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">ShouldSerializeS</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&gt;        </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">return</span> !<span class="keyword">string</span>.IsNullOrEmpty(S);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>找到解法的時候其實很驚訝, 因為這種做法維護上其實會有點困擾, 想想如果屬性要改名, 結果還要有意識的刻意找出 <code>ShouldSerialize{PropertyName}</code> 或是 <code>{PropertytName}Specified</code> 來修改, 對於維護其實不太友善, 只是沒有找到其他做法也就先拿來用了.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/a/5818571" target="_blank" rel="noopener">Xml serialization - Hide null values</a>  </p>
<p><a href="https://stackoverflow.com/a/1533339" target="_blank" rel="noopener">How to exclude null properties when using XmlSerializer</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[依字位 (grapheme) 處理字串]]></title>
      <url>/content/20220528-grapheme-cluster-string.html</url>
      <content type="html"><![CDATA[<p>以前在處理字串的時候, 不管是反轉或是取字元都沒考慮到有些語言的一個字母可能是由多個字組成的, 直到遇到問題.  </p>
<p>舉個越南文的例子, <code>ơ</code> 是由 <code>o</code> 和 <code>̛</code> (%cc%9b) 組成的, 所以處理的時候就容易有預料外的結果, 以字串反轉來說, <code>ơa</code> 反轉後變成 <code>a̛o</code></p>
<a id="more"></a>
<h3 id="關於-Grapheme-與相關"><a href="#關於-Grapheme-與相關" class="headerlink" title="關於 Grapheme 與相關"></a>關於 Grapheme 與相關</h3><p>這部分沒有仔細研究, 但是網路資源很多可以需要時知道細節時再查詢.  </p>
<ul>
<li><a href="https://stackoverflow.com/q/27331819/8223582" target="_blank" rel="noopener">What’s the difference between a character, a code point, a glyph and a grapheme?</a>  </li>
<li><a href="http://www.unicode.org/glossary/" target="_blank" rel="noopener">Glossary of Unicode Terms</a>: 相關關鍵字 <code>Abstract Character</code> / <code>Character</code> / <code>Glyph</code> / <code>Grapheme</code></li>
</ul>
<h3 id="使用-TextElementEnumerator-處理字串"><a href="#使用-TextElementEnumerator-處理字串" class="headerlink" title="使用 TextElementEnumerator 處理字串"></a>使用 TextElementEnumerator 處理字串</h3><p>使用 <code>TextElementEnumerator</code> 就能正確的將 <code>ơa</code> 反轉成 <code>ơa</code> 了.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Globalization;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ReverseGraphemeClusters</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TextElementEnumerator enumerator = StringInfo.GetTextElementEnumerator(s);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        sb.Insert(<span class="number">0</span>, enumerator.GetTextElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>就是個沒遇到不會想到的問題, 處理方式也很簡單, 只是背後細節要看很多文件才能了解很麻煩所以乾脆紀錄一下備查.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/q/27331819/8223582" target="_blank" rel="noopener">What’s the difference between a character, a code point, a glyph and a grapheme?</a><br><a href="http://www.unicode.org/glossary/" target="_blank" rel="noopener">Glossary of Unicode Terms</a><br><a href="https://riptutorial.com/csharp/example/10627/correctly-reversing-a-string" target="_blank" rel="noopener">Correctly reversing a string</a><br><a href="https://zetcode.com/csharp/grapheme/" target="_blank" rel="noopener">C# grapheme</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Flatten JSON]]></title>
      <url>/content/20211114-flatten-json.html</url>
      <content type="html"><![CDATA[<p>幾年前因為需要將”不固定格式且不可預期”的 JSON 字串轉換成 <code>Dictionary&lt;strin, string&gt;</code> 而做了擴充方法, 但後來發現實作得太複雜了.所以想記錄一下比較簡單的做法.  </p>
<a id="more"></a>
<h3 id="搭配-Newtonsoft-Json"><a href="#搭配-Newtonsoft-Json" class="headerlink" title="搭配 Newtonsoft.Json"></a>搭配 Newtonsoft.Json</h3><p>一開始的思路是將字串轉換成 <code>JObject</code> 後再迴圈所有的欄位, 根據那些欄位是 Object / Aarray / Value 搭配遞迴把整個 JSON 字串轉換成 <code>Dictionary&lt;strin, string&gt;</code>, 雖然遞迴有點費神但是整體也就四五十行程式碼, 寫完覺得很滿意.  </p>
<p>沒想到最近發現了<a href="https://stackoverflow.com/a/35838986/8223582" target="_blank" rel="noopener">這一篇回答</a>的精妙解法, 才發現之前的作法簡直是土法煉鋼, 所以稍微改了一下.  </p>
<blockquote>
<p>連結中的 Code 不支援第一層是陣列的 JSON, 例如: <code>[{&quot;key&quot;, &quot;a&quot;}, {&quot;key&quot;, &quot;b&quot;}]</code>, 所以需要改過.</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">JContainerExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; <span class="title">Flatten</span>(<span class="params"><span class="keyword">this</span> JContainer jContainer</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IEnumerable&lt;JToken&gt; jTokens = jContainer.Descendants().Where(p =&gt; p.Count() == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> jTokens.ToDictionary(jToken =&gt; jToken.Path, jToken =&gt; jToken.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不到十行而且又簡單明瞭, 呼叫端使用上也很容易:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jContainer = JToken.Parse(testData) <span class="keyword">as</span> JContainer;</span><br><span class="line"><span class="keyword">var</span> flattenJContainer = jContainer?.Flatten();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>JToken.Parse(testData) as JContainer</code> 這一行是成立的, 會成立是因為 <code>JToken.Parse(testData)</code> 的結果可能是 <code>JObject</code> / <code>JArray</code> / <code>JValue</code>, 除了 <code>JValue</code> 外都繼承了 <code>JContainer</code>, 所以轉型上不會有問題, 而 <code>JValue</code> 是沒有 key 的純值 (例如: <code>JToken val = JToken.Parse(&quot;abc&quot;);</code>), 本來就不適合出現在要轉換成 <code>Dictionary&lt;string, string&gt;</code> 的情境.  </p>
</blockquote>
<h3 id="搭配-Sysetem-Text-Json"><a href="#搭配-Sysetem-Text-Json" class="headerlink" title="搭配 Sysetem.Text.Json"></a>搭配 Sysetem.Text.Json</h3><p>這個是內建的 Json 處理工具, 不過功能沒有 Newtonsoft.Json 那麼多, 沒找到比較簡單的做法所以只好還是用遞迴, 在實作上會麻煩很多.  </p>
<p>先來點擴充方法:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">JsonDocumentExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; <span class="title">Flatten</span>(<span class="params"><span class="keyword">this</span> JsonDocument document</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">        FlattenElement(<span class="keyword">string</span>.Empty, document.RootElement, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FlattenElement</span>(<span class="params"><span class="keyword">string</span> key, JsonElement element, Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; result</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (element.ValueKind)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> JsonValueKind.Object:</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> pty <span class="keyword">in</span> element.EnumerateObject())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span> nextKey = <span class="keyword">string</span>.IsNullOrEmpty(key) ? pty.Name : <span class="string">$"<span class="subst">&#123;key&#125;</span>.<span class="subst">&#123;pty.Name&#125;</span>"</span>;</span><br><span class="line">                    FlattenElement(nextKey, pty.Value, result);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JsonValueKind.Array:</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> arrayItem <span class="keyword">in</span> element.EnumerateArray())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span> nextKey = <span class="string">$"<span class="subst">&#123;key&#125;</span>[<span class="subst">&#123;i&#125;</span>]"</span>;</span><br><span class="line">                    FlattenElement(nextKey, arrayItem, result);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.Add(key.ToString(), element.ToString());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呼叫端是這樣:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flattenJsonDocument = JsonDocument.Parse(testData).Flatten();</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>用了 Newtonsoft.Json 結果因為沒發現套件已經提供的功能而自己土法煉鋼真的沒效率又容易錯, 算是被以前的自己雷到.   </p>
<p>另外為了方便驗證, 有範例專案<a href="https://github.com/ronsun/Demo/tree/master/FlattenJson" target="_blank" rel="noopener">在這裡</a>.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/a/35838986/8223582" target="_blank" rel="noopener">C# flattening json structure</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET Core 中單一介面多實作搭配依賴注入的幾種方式]]></title>
      <url>/content/20211031-netcore-inject-multiple-implementation.html</url>
      <content type="html"><![CDATA[<p>在 .NET Core 中注入多個實作有幾種方式，各自有不同的優缺點與試用情境，相關範例程式碼會放在 <a href="https://github.com/ronsun/Demo/tree/master/MultipleImplementation" target="_blank" rel="noopener">這個 GitHub 專案</a> 上。  </p>
<a id="more"></a>
<h3 id="Implementation-Factory"><a href="#Implementation-Factory" class="headerlink" title="Implementation Factory"></a>Implementation Factory</h3><p>Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions 提供的多載，以 AddScoped 為例：<br><code>public static IServiceCollection AddScoped&lt;TService&gt;(this IServiceCollection services, Func&lt;IServiceProvider, TService&gt; implementationFactory) where TService : class</code>  </p>
<p>第二個參數提供一個工廠方法來決定要使用哪種實作。  </p>
<p><strong>優點</strong>  </p>
<ul>
<li>非常簡單。</li>
</ul>
<p><strong>缺點與限制</strong></p>
<ul>
<li>只適用於在注入時就知道要用什麼規則決定使用哪個實作。</li>
<li>彈性低，雖然簡單但是適用情境狹窄。</li>
</ul>
<h3 id="注入-IEnumerable"><a href="#注入-IEnumerable" class="headerlink" title="注入 IEnumerable"></a>注入 IEnumerable<t></t></h3><p>註冊多個實作，使用時注入 <code>IEnumerable&lt;I&gt;</code> 後再決定要使用哪個實作，可以搭配一個欄位用來標示該實作的名字 (要用類別名稱來標示也可以)。  </p>
<p>註冊服務：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	services.AddControllers();</span><br><span class="line"></span><br><span class="line">	services.AddSingleton&lt;IFoo, Foo1&gt;();</span><br><span class="line">	services.AddSingleton&lt;IFoo, Foo2&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注入與使用：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> IEnumerable&lt;IFoo&gt; _allFoo;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">IEnumerable&lt;IFoo&gt; allFoo</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_allFoo = allFoo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">HttpGet</span>]</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> foo = _allFoo.FirstOrDefault(r =&gt; r.Name == name);</span><br><span class="line">		sb.Append(foo?.Hi());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Ok(sb.ToString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>優點</strong>  </p>
<ul>
<li>簡單。</li>
<li>彈性高。</li>
</ul>
<p><strong>缺點與限制</strong></p>
<ul>
<li>因為是注入所有的實作後再挑出要使用的那一個，其他的都用不到，會有浪費資源的疑慮，所以通常搭配 AddSingleton 使用。</li>
<li>每次搜尋 ( <code>_allFoo.FirstOrDefault(r =&gt; r.Name == name)</code> )的時間複雜度都是 O(n)，需要多次搜尋時這個缺點會更明顯。</li>
</ul>
<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><p>註冊成一個 Dictionary 或類似的物件。  </p>
<p>註冊服務：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	services.AddControllers();</span><br><span class="line"></span><br><span class="line">	services.AddScoped&lt;IBar, Bar1&gt;();</span><br><span class="line">	services.AddScoped&lt;IBar, Bar2&gt;();</span><br><span class="line">	services.AddScoped&lt;IReadOnlyDictionary&lt;<span class="keyword">string</span>, IBar&gt;&gt;(provider =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> allBar = provider.GetService&lt;IEnumerable&lt;IBar&gt;&gt;();</span><br><span class="line">		<span class="keyword">return</span> allBar.ToDictionary(bar =&gt; bar.Name, bar =&gt; bar);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注入與使用：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> IReadOnlyDictionary&lt;<span class="keyword">string</span>, IBar&gt; _allBar;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">IReadOnlyDictionary&lt;<span class="keyword">string</span>, IBar&gt; allBar</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_allBar = allBar;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">HttpGet</span>]</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// bar</span></span><br><span class="line">		_allBar.TryGetValue(name, <span class="keyword">out</span> IBar bar);</span><br><span class="line">		sb.Append(bar?.Hello());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Ok(sb.ToString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>優點</strong>  </p>
<ul>
<li>簡單。</li>
<li>彈性高。</li>
<li>可擴充性高，如果是作為一個套件，即使沒提供適合的實作，使用者仍然可以自己實作 <code>IBar</code> 後注入。</li>
<li>只有第一次初始化的時候將 <code>IEnumerable&lt;T&gt;</code> 轉成 Dictionary 時比較耗時，之後每次取用的時間複雜度都是 O(1)，在生命週期範圍內多次取用的效能優於 <code>IEnumerable&lt;T&gt;</code>。</li>
</ul>
<p><strong>缺點與限制</strong></p>
<ul>
<li>沒有那麼直覺，對於使用者來說要記得注入時要注入為 <code>IReadOnlyDictionary&lt;string, IBar&gt;</code>。</li>
</ul>
<h3 id="透過另一個類別來轉接-橋接模式"><a href="#透過另一個類別來轉接-橋接模式" class="headerlink" title="透過另一個類別來轉接 (橋接模式)"></a>透過另一個類別來轉接 (橋接模式)</h3><p>這種做法的概念在於提供一個橋接用的類別來使用那些實作。  </p>
<p>註冊服務：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	services.AddControllers();</span><br><span class="line"></span><br><span class="line">	services.AddScoped&lt;IBaz, Baz1&gt;();</span><br><span class="line">	services.AddScoped&lt;IBaz, Baz2&gt;();</span><br><span class="line">	services.AddScoped&lt;IBazBridge, BazBridge&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注入與使用：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> IBazBridge _bazBridge;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">IBazBridge bazBridge</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_bazBridge = bazBridge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">HttpGet</span>]</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// baz</span></span><br><span class="line">		sb.Append(_bazBridge.Hey(name));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Ok(sb.ToString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bridge 相關類別：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBazBridge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">Hey</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BazBridge</span> : <span class="title">IBazBridge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IReadOnlyDictionary&lt;<span class="keyword">string</span>, IBaz&gt; _allBazDictionary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BazBridge</span>(<span class="params">IEnumerable&lt;IBaz&gt; allBaz</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _allBazDictionary = allBaz.ToDictionary(baz =&gt; baz.Name, baz =&gt; baz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Hey</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _allBazDictionary.TryGetValue(name, <span class="keyword">out</span> IBaz baz);</span><br><span class="line">        <span class="keyword">return</span> baz?.Hey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果有多個情境要使用 Bridge，可以將建構子中轉換 <code>IEnumerable&lt;T&gt;</code> 為 Dictionary 的部分抽成 <code>BridgeBase</code>，提供給所有 Bridge 繼承。</p>
</blockquote>
<p><strong>優點</strong>  </p>
<ul>
<li>彈性極高，Brige 中甚至可以做各種轉接與變化。  </li>
<li>可擴充性高，如果是作為一個套件，即使沒提供適合的實作，使用者仍然可以自己實作 <code>IBaz</code> 後注入。</li>
<li>只有第一次初始化的時候將 <code>IEnumerable&lt;T&gt;</code> 轉成 Dictionary 時比較耗時，之後每次取用的時間複雜度都是 O(1)，在生命週期範圍內多次取用的效能優於 <code>IEnumerable&lt;T&gt;</code>。</li>
<li>相較於之前的注入 Dictionary 的解法，這種高彈性/擴充性的作法更適合放在套件中，這種設計相似於 <code>HttpClient</code> 與 <code>IHttpClientFactory</code> 之間的關係，所以相對於之前 Dictionary 的解法來說，使用上不直覺的問題相對低了一些。  </li>
</ul>
<p><strong>缺點與限制</strong></p>
<ul>
<li>複雜很多。</li>
<li>多個介面需要套用時會需要很多組 Bridge。</li>
<li>註冊較不友善，<code>services.AddScoped&lt;IBazBridge, BazBridge&gt;();</code> 這邊使用者要認識具體實作 <code>BazBridge</code>。</li>
</ul>
<h3 id="透過另一個類別來管理-Provider"><a href="#透過另一個類別來管理-Provider" class="headerlink" title="透過另一個類別來管理 (Provider)"></a>透過另一個類別來管理 (Provider)</h3><p>這種做法的概念在於提供一個管理用的類別來提供那些實作。  </p>
<p>註冊服務：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	services.AddControllers();</span><br><span class="line"></span><br><span class="line">	services.AddScoped&lt;IQux, Qux1&gt;();</span><br><span class="line">	services.AddScoped&lt;IQux, Qux2&gt;();</span><br><span class="line">	services.AddScoped&lt;IProvider&lt;IQux&gt;, Provider&lt;IQux&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">, ``</span><br><span class="line"></span><br><span class="line">注入與使用：  </span><br><span class="line">``` csharp</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> IProvider&lt;IQux&gt; _quxProvider;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">IProvider&lt;IQux&gt; quxProvider</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_quxProvider = quxProvider;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">HttpGet</span>]</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// baz</span></span><br><span class="line">		sb.Append(_quxProvider.Get(name).Yo());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Ok(sb.ToString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Provider 相關類別：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface IProvider&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T : INameable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Provider&lt;T&gt; : IProvider&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T : INameable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IReadOnlyDictionary&lt;<span class="keyword">string</span>, T&gt; _dictionary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Provider</span>(<span class="params">IEnumerable&lt;T&gt; nameable</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _dictionary = nameable.ToDictionary(n =&gt; n.Name, n =&gt; n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _dictionary.TryGetValue(name, <span class="keyword">out</span> T imp);</span><br><span class="line">        <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>優點</strong>  </p>
<ul>
<li>有幾乎等同 <code>Bridge</code> 解法的優點 (除了彈性略低)。 </li>
<li>泛用性極高，可重複套用在任何單介面多實作的情境。</li>
</ul>
<p><strong>缺點與限制</strong></p>
<ul>
<li>因為不需要實作各種 <code>Bridge</code>，彈性較 <code>Bridge</code> 解法低一點。  </li>
<li>註冊較不友善，<code>services.AddScoped&lt;IProvider&lt;IQux&gt;, Provider&lt;IQux&gt;&gt;();</code> 這邊使用者要認識具體實作 <code>Provider&lt;T&gt;</code>，且兩層泛型參數比較不好閱讀。  </li>
</ul>
<h3 id="綜合以上最佳化使用者體驗"><a href="#綜合以上最佳化使用者體驗" class="headerlink" title="綜合以上最佳化使用者體驗"></a>綜合以上最佳化使用者體驗</h3><p>這是我用在一個套件 - <a href="https://github.com/ronsun/MoreNet.DependencyInjection" target="_blank" rel="noopener">MoreNet.DependencyInjection</a> 上的作法，介紹直接看 GitHub。 </p>
<p><strong>優點</strong>  </p>
<ul>
<li>泛用性極高，可重複套用在任何單介面多實作的情境。</li>
<li>註冊簡易，對使用者比較友善。</li>
</ul>
<p><strong>缺點與限制</strong></p>
<ul>
<li>實作很複雜。</li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>方法很多種，大致可以分為兩個面向</p>
<ol>
<li>注入全部後再挑選。</li>
<li>提供管理用的類別 (不論是工廠/橋接或是其他模式)。</li>
</ol>
<p>上面的範例只是為了展示這兩個大方向，實際運用時需要視情境變化調整，例如<a href="https://medium.com/geekculture/net6-dependency-injection-one-interface-multiple-implementations-983d490e5014" target="_blank" rel="noopener">這篇文章提到幾種做法</a>，都和上面範例不太一樣但大方向是一致的。  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0#service-registration-methods-1" target="_blank" rel="noopener">Service registration methods</a>  </p>
<p><a href="https://medium.com/geekculture/net6-dependency-injection-one-interface-multiple-implementations-983d490e5014" target="_blank" rel="noopener">.NET6 Dependency Injection — One Interface, Multiple Implementations</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[基於 ASP.NET Core WebAPI 讀取 Request / Response Body]]></title>
      <url>/content/20210626-aspnetcore-webapi-read-body.html</url>
      <content type="html"><![CDATA[<p>之前在 <a href="/content/20181118-webapi-get-request-body-safety.html" title="WebAPI 安全的取得 Request Body">WebAPI 安全的取得 Request Body</a> 這篇文章有提到讀取 Request Body 的方式, Response 的部分其實大同小異, 且在 ASP.NET Core 中也是相同邏輯(即使實作可能不同), 但有個不同的地方是 ASP.NET Core 中的 request body 預設是讀完無法回捲的(也就是讀完後指標會在 stream 最後面, 無法重複讀取), 且 response body 是唯寫 (WriteOnly) 的, 所以無法讀取, 就需要一點小技巧.  </p>
<a id="more"></a>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><p>這邊直接實作在 Middleware 為例:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestResponseMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestResponseMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InvokeAsync</span>(<span class="params">HttpContext httpContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> Request part</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> request = httpContext.Request;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重要, 才能允許回捲 (request.Body.Seek(0, SeekOrigin.Begin))</span></span><br><span class="line">        request.EnableBuffering();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> requestReader = <span class="keyword">new</span> StreamReader(request.Body, leaveOpen: <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> body = <span class="keyword">await</span> requestReader.ReadToEndAsync();</span><br><span class="line">        request.Body.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">        Debug.WriteLine(body);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response = httpContext.Response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> originalStream = response.Body;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> readableBodyStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            response.Body = readableBodyStream;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> _next(httpContext);</span><br><span class="line"></span><br><span class="line">            response.Body.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> responseReader = <span class="keyword">new</span> StreamReader(response.Body, leaveOpen: <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">var</span> responseBody = <span class="keyword">await</span> responseReader.ReadToEndAsync();</span><br><span class="line"></span><br><span class="line">            Debug.WriteLine(responseBody);</span><br><span class="line"></span><br><span class="line">            response.Body.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> readableBodyStream.CopyToAsync(originalStream);</span><br><span class="line">            <span class="comment">// 即使沒有換回原本的物件, 得到的回傳仍然不會有錯, 猜測是回傳的內容是直接參考 response.Body 所指的物件,</span></span><br><span class="line">            <span class="comment">// 因此 response.Body 被換掉不會影響結果(反而上面的 stream copy 才是必要的), 但為了完整還是會把它換回來. </span></span><br><span class="line">            response.Body = originalStream;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> Response part</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面來說, Request 部分就 <code>request.EnableBuffering()</code> 最重要, 不然讀完回無法回捲, Response 的話 <code>await readableBodyStream.CopyToAsync(originalStream)</code> 和 <code>response.Body = originalStream</code> 這兩行算是比較特別的, 如註解中所述.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>細節很多很難解釋, 只好貼 code 解決, 希望不會以後自己看不懂… </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Friend Assembly]]></title>
      <url>/content/20210606-use-friend-assembly.html</url>
      <content type="html"><![CDATA[<p>如果組件 A 是組件 B 的 Friend Assembly, 則在組件 A 中能存取別的組件內的 <code>internal</code> 類別或成員, 更多細節在<a href="https://docs.microsoft.com/en-us/dotnet/standard/assembly/friend" target="_blank" rel="noopener">官方介紹</a>.  </p>
<a id="more"></a>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>加上一行 <code>[assembly: InternalsVisibleTo(&quot;AssemblyName&quot;)]</code> 就好, 建議放在 Properties 資料夾下的 AssemblyInfo.cs 檔案中.</p>
<h3 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h3><p>目前有想到適合的情境是</p>
<ol>
<li><strong>跨組件的內部 API</strong>: 拆分成好幾個組件組合成一個完整產品, 希望給在這個產品中讓特定組件能跨組件存取, 但又不希望用 <code>plubic</code> .  </li>
<li><strong>測試目的</strong>: 因為測試的目的, 需要開放給測試專案存取.  </li>
</ol>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>使用上很簡單, 但是比較需要想的是試用在甚麼情境, 目前也就為了給測試專案存取而使用有用到而已.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/standard/assembly/friend" target="_blank" rel="noopener">Friend assemblies</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[傳遞依賴 (transitive dependency)]]></title>
      <url>/content/20210523-transitive-dependency.html</url>
      <content type="html"><![CDATA[<p>為了降低多個專案間的複雜度, 我們通常會謹慎的控制專案之間的依賴, 但在最近新開案的 .NET Core 一系列的新專案中發現傳遞依賴會讓專案之間產生預期外的依賴.  </p>
<a id="more"></a>
<p>傳遞依賴 (transitive dependency) 指的是, 當 A 專案依賴 B 專案, 而 B 專案依賴 C 專案時, A 專案會傳遞依賴 C 專案 (即在 A 專案中能存取 C 專案的公開成員), 用下面的圖當範例說明 </p>
 <img src="/content/20210523-transitive-dependency/dependency.jpg">   
<h3 id="專案間的傳遞依賴"><a href="#專案間的傳遞依賴" class="headerlink" title="專案間的傳遞依賴"></a>專案間的傳遞依賴</h3><p>就上圖的例子, 現在三層都是我們自己建立的專案, WebAPI 依賴 Service, 而 Service 依賴 Data Access, 本來不希望能從 WebAPI 中直接存取到 Data Access, 但卻因為傳遞依賴而失算.  </p>
<p>現在直接依賴的關係是這樣的:  </p>
<blockquote>
<p>WebAPI (project) –&gt; Service (project) –&gt; Data Access (project)</p>
</blockquote>
<p>解決方式是要在 <strong>WebAPI 專案的 csproj 檔案中</strong>將傳遞依賴關閉, 如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">DisableTransitiveProjectReferences</span>&gt;</span>true<span class="tag">&lt;/<span class="name">DisableTransitiveProjectReferences</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="專案間和套件的傳遞依賴"><a href="#專案間和套件的傳遞依賴" class="headerlink" title="專案間和套件的傳遞依賴"></a>專案間和套件的傳遞依賴</h3><p>這個情境的直接依賴的關係是這樣的, 假設 Data Access 是一個套件 (就叫 DataAccess 好了), Service 透過 NuGet 安裝並使用他  </p>
<blockquote>
<p>WebAPI (project) –&gt; Service (project) –&gt; Data Access (Package)</p>
</blockquote>
<p>這時候 <code>&lt;DisableTransitiveProjectReferences&gt;</code> 是沒有用的, 解決方式就變成要在 <strong>Service 專案的 csproj 檔案中</strong> 用 <code>&lt;PrivateAssets&gt;</code> 排除, 如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"DataAccess"</span> <span class="attr">Version</span>=<span class="string">"1.1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PrivateAssets</span>&gt;</span>all<span class="tag">&lt;/<span class="name">PrivateAssets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PackageReference</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>關於 <code>&lt;PackageReference&gt;</code> 更細緻的設定可以看<a href="https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets" target="_blank" rel="noopener">這裡官方相關的介紹</a>.  </p>
<h3 id="套件間的傳遞依賴"><a href="#套件間的傳遞依賴" class="headerlink" title="套件間的傳遞依賴"></a>套件間的傳遞依賴</h3><p>最後一種情況, 套件之間的傳遞依賴, 現在 Service 也是個套件, 但他依賴 Data Access  </p>
<blockquote>
<p>WebAPI (project) –&gt; Service (Package) –&gt; Data Access (Package)</p>
</blockquote>
<p>其實這個跟上個情境是一樣的, 就是在 Service 中加上 <code>PrivateAssets</code>, 但如果們是站在 WebAPI 專案開發者而不是套件 (本例中的 Service) 開發者的角度, 就目前所知是無能為力, 只能期待後面維護的人不要誤用.  </p>
<h3 id="真實情境"><a href="#真實情境" class="headerlink" title="真實情境"></a>真實情境</h3><p>現實中遇到的情境是這樣的, 某項任務中要用到一個公司內部的套件, 而這個套件依賴了一個 JSON 的序列化套件 <code>Jil</code>, 那問題在於 Visual Studio 的提示功能可能會引導開發者使用 <code>Jil</code> 提供的類別, 但我們專案內部其實是用 <code>Json.NET</code>, 如果維護的人不小心就跟著 Visual Studio 的提示用了, 就變成一個功能用兩種套件處理而容易亂.  </p>
<p>另外一個疑慮是, 就算我們真的也是用 <code>Jil</code>, 如果有天我們移除對這個內部套件的依賴, 或是更版後內部套件不使用 <code>Jil</code> 了, 那就會讓我們因為升版一個套件而造成另一個套件的使用問題, 雖然不難解決, 但多個疑慮總不是好事.  </p>
<p>還有第三個疑慮最麻煩, 今天如果使用 A 和 B 兩個套件, 而他們分別依賴不同版本的 <code>Jil</code> 的時候就很糟了, 稍微用簡單情境實測一下是<strong>會使用高版的 <code>Jil</code></strong>, 這意味著, 當你依賴 A 套件並透過傳遞依賴使用 <code>Jil</code> 時, 可能會因為後來依賴 B 套件而讓 <code>Jil</code> 被升版.<br><strong>而 A 套件在執行階段其實是呼叫到被升版的 <code>Jil</code>, 這會使得 A 套件的執行結果可能被改變或因為新版 <code>Jil</code> 的 breaking changes 而在執行階段拋出例外</strong>. </p>
<p>綜合以上疑慮, 可以考慮不要透過傳遞依賴而是直接依賴該套件, 這樣版本衝突時在安裝套件過程 <strong>有 機 會</strong> 能發現.  </p>
<blockquote>
<p>是的, 只是有機會能發現, 如果專案直接依賴高版本, 傳遞依賴低版本, 是不會警示的, 這種情境下最後還是會使用高版本的套件, 上面的疑慮還是無法獲得解決.  </p>
</blockquote>
<p>套件版本衝突的問題在 <a href="/content/20200301-dependent-assembly-issue.html" title="套件相依性問題">套件相依性問題</a> 這邊已經遇過, 而且這還是直接依賴的還算好掌握, 如果是透過傳遞依賴使用的掌握上就困難了.  </p>
<p><a href="https://github.com/ronsun/BlogDemo.TransitiveDependency" target="_blank" rel="noopener">我在 GitHub 上有放一個專案來展示這些疑慮</a>.  </p>
<h3 id="其他可能的做法"><a href="#其他可能的做法" class="headerlink" title="其他可能的做法"></a>其他可能的做法</h3><p>主要是參考這篇 <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/dependencies" target="_blank" rel="noopener">NuGet &gt; Dependencies</a>.  </p>
<h4 id="限定套件版本範圍"><a href="#限定套件版本範圍" class="headerlink" title="限定套件版本範圍"></a>限定套件版本範圍</h4><p>如範例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Accepts 1.0 up to 1.x, but not 2.0 and higher. --&gt;</span><br><span class="line">&lt;PackageReference Include=&quot;ExamplePackage&quot; Version=&quot;[1.0,2.0)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Accepts exactly 1.0. --&gt;</span><br><span class="line">&lt;PackageReference Include=&quot;ExamplePackage&quot; Version=&quot;[1.0]&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>這個想法是限定套件版本讓版號衝突時直接失敗, 但是這樣可能會導致多個套件很難一起運作,  <strong>而且官方不建議</strong>.  </p>
<h4 id="用一個獨立專案管理套件依賴"><a href="#用一個獨立專案管理套件依賴" class="headerlink" title="用一個獨立專案管理套件依賴"></a>用一個獨立專案管理套件依賴</h4><p>這個之前有實驗過, 就是開一個 Shared 專案, 他會被很多專案依賴, 而套件依賴都在 Shared 專案內管理再讓依賴他的其他專案們都能使用一致的套件組, 但是副作用是其他專案可能會存取到設計上不允許存取的套件, 以下面為例: </p>
<blockquote>
<p>WebAPI (project) –&gt; Service (project) –&gt; Data Access (project) –&gt; Shared (Project)<br>Service (project) –&gt; Shared (Project)<br>WebAPI (project) –&gt; Shared (Project)  </p>
</blockquote>
<p> 如上的多層式設計, 且 Shared (Project)  –&gt; Entity Framework Core (Package), 這時候很容易有人跳過中間幾層直接從 WebAPI 層用 Entity Framwork Core 存取資料庫, 所以需要依照真實情境去部分限縮傳遞依賴, 比較麻煩.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>接下來可能會做一些內部套件類的專案, 還是要稍微注意一下傳遞依賴的問題, 避免讓使用者依賴到沒必要依賴的套件引發維護上的困擾.   </p>
<p>而在使用套件時也應該要更謹慎, 以用最少量的多功能套件解決最多的問題, 不然引發的問題都是很難發現的, breaking changes 造成執行階段才拋例外已經不是好現象了, 萬一問題是得到錯誤的結果而非拋錯那真的會哭哭.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/a/60852224/8223582" target="_blank" rel="noopener">Transitive project references (<code>ProjectReference</code>)</a>: 這篇很完整</p>
<p><a href="(https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets">Controlling dependency assets</a>)  </p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/dependencies" target="_blank" rel="noopener">NuGet &gt; Dependencies</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Encoding.UTF8 vs new UTF8Encoding() 和 xml 序列化的可能問題]]></title>
      <url>/content/20210510-encoding-utf8-vs-new-utf8encoding-about-preamble.html</url>
      <content type="html"><![CDATA[<p><code>Encoding.UTF8</code> 和 <code>new UTF8Encoding()</code> 所建立的物件內容是極其相似的, 甚至有些問答網站是說完全一樣, 但實際上有個小小不同的地方, 雖然多數時候不會造成影響, 但前陣子在寫 xml 序列化的測試的時候就出現結果不同的情境, 所以稍微紀錄一下.   </p>
<a id="more"></a>
<h3 id="問題點"><a href="#問題點" class="headerlink" title="問題點"></a>問題點</h3><p>我們用下面的範例來做實驗 (示範用的, 忽略 clean code 的要求), 範例是基於 .Net Core 3.1.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FakeString &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"A"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(FakeClass));</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> FakeClass();</span><br><span class="line">        <span class="keyword">var</span> xmlWriterSettings = <span class="keyword">new</span> XmlWriterSettings() &#123; Encoding = Encoding.UTF8 &#125;;</span><br><span class="line">        <span class="keyword">var</span> b = Serialize(serializer, xmlWriterSettings, obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xmlWriterSettings2 = <span class="keyword">new</span> XmlWriterSettings() &#123; Encoding = <span class="keyword">new</span> UTF8Encoding() &#125;;</span><br><span class="line">        <span class="keyword">var</span> b2 = Serialize(serializer, xmlWriterSettings2, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] Serialize&lt;T&gt;(XmlSerializer serializer, XmlWriterSettings xmlWriterSettings, T obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> xmlWriter = XmlWriter.Create(ms, xmlWriterSettings))</span><br><span class="line">        &#123;</span><br><span class="line">            serializer.Serialize(xmlWriter, obj);</span><br><span class="line">            <span class="keyword">return</span> ms.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從上面的範例可以發現, <code>b</code> 和 <code>b2</code> 的內容是不一樣的, 其中 <code>b</code> (使用<code>Encoding.UTF8</code>) 的最前面多了 BOM (三個 bytes, 內容就是 <code>Encoding.UTF8.GetPreamble()</code>), 雖然看起來沒有問題, 但是如同 <a href="/content/20181203-xml-serialize-deserialize.html" title="XmlSerializer 的序列化/反序列化 與 BOM">XmlSerializer 的序列化/反序列化 與 BOM</a> 這一篇提到的, 如果合作對象無法反序列化含 BOM 的 xml 時, 在資料交換過程就會有很多阻礙, 且含 BOM 的 XML 在文字編輯器上是無法用肉眼看出來的 (除非有特別設定顯示特殊字元).   </p>
<p>另外一件有趣的事, 只要 bytes 內容一樣, 兩種方式轉成字串得到的內容是相同的, 亦即 <code>Encoding.UTF8.GetString(b) == new UTF8Encoding().GetString(b)</code> 且 <code>Encoding.UTF8.GetString(b2) == new UTF8Encoding().GetString(b2)</code>.  </p>
<p>相關內容之前那篇提過, 這篇主要是要稍微將範圍縮小到 <strong>Encoding.UTF8 和 new UTF8Encoding() 不完全一樣</strong> 這件事上.  </p>
<h3 id="看看原始碼"><a href="#看看原始碼" class="headerlink" title="看看原始碼"></a>看看原始碼</h3><h4 id="Net-Core"><a href="#Net-Core" class="headerlink" title=".Net Core"></a>.Net Core</h4><p>那既然從執行結果知道這兩者不同, 那就令人好奇這兩者的差別到底有多大了, 這時候就需要看看原始碼長怎樣了.  </p>
<p>先從 <code>Encoding.UTF8</code> 開始, 從 <a href="https://source.dot.net/#System.Private.CoreLib/Encoding.cs,a10eb90a3d884500" target="_blank" rel="noopener">.NET Source Browser</a> 往下追蹤, 可以發現最後使用的是呼叫  <code>UTF8Encoding(bool encoderShouldEmitUTF8Identifier)</code> 這個建構子, 參數帶的是 <code>true</code>, 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UTF8Encoding</span>(<span class="params"><span class="keyword">bool</span> encoderShouldEmitUTF8Identifier</span>) :</span></span><br><span class="line"><span class="function">	<span class="title">this</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_emitUTF8Identifier = encoderShouldEmitUTF8Identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然後是 <code>new UTF8Encoding()</code>, <a href="https://source.dot.net/#System.Private.CoreLib/UTF8Encoding.cs,21efe420a875356a,references" target="_blank" rel="noopener">.NET Source Browser</a> 往下追蹤, 可以發現呼叫的是 <code>UTF8Encoding()</code> 這個建構子, 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UTF8Encoding</span>(<span class="params"></span>) :</span></span><br><span class="line"><span class="function">	<span class="title">base</span>(<span class="params">UTF8_CODEPAGE</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到這兩個情境只差別會不會將 <code>_emitUTF8Identifier</code> 設為 <code>true</code> 而已.  </p>
<h4 id="Net-Framework"><a href="#Net-Framework" class="headerlink" title=".Net Framework"></a>.Net Framework</h4><p>在 .Net Framework 上更簡單, 如下兩段對比一目瞭然<br><a href="https://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs,a10eb90a3d884500" target="_blank" rel="noopener">Encoding.UTF8</a> 對比 <a href="https://referencesource.microsoft.com/#mscorlib/system/text/utf8encoding.cs,21efe420a875356a,references" target="_blank" rel="noopener">new UTF8Encoding()</a>.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這個差別很隱諱, 而且使用起來雖然大多情境都沒問題, 但遇到問題時容易卡住很久找不到主因, 尤其是跟外部廠商交互過程遇到這種問題真的要靠大量溝通加一點通靈能力才能找到.  </p>
<p>另外如果沒看錯的話, UTF 系列的只有 UTF8 會有這個小差異, UTF7 和 UTF32 使用 Encoding.UTF7 / Encoding.UTF32 都各自和直接透過 UTF7Encoding / UTF32Encoding 無參數建構子得到的實例 (instance) 是一樣的.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://source.dot.net/" target="_blank" rel="noopener">.NET Source Browser</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[跨組件反射的注意事項]]></title>
      <url>/content/20200802-cross-assembly-reflection.html</url>
      <content type="html"><![CDATA[<p>問題的起源在於某次搬遷程式碼的時候, 雖然看起來只是將一個方法移動到別的專案, 卻不小心讓一個有使用反射的方法在執行階段拋錯, 雖然查明後發現不是太刁鑽的問題, 但卻是容易不小心出錯的, 所以稍微紀錄一下.  </p>
<a id="more"></a>
<h3 id="問題點"><a href="#問題點" class="headerlink" title="問題點"></a>問題點</h3><p>當時的情況是有兩個專案, 假設是 <code>LogicLayer</code> 和 <code>Shared</code>, 要將一個 <code>Create(string typeName)</code> 方法從原本的 <code>LogicLayer</code> 專案搬到 <code>Shared</code> 中, 讓這個共用的工具方法能建立在正確的專案上, 方法如下:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T must be base type of typeName</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T Create&lt;T&gt;(<span class="keyword">string</span> typeName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> type = Type.GetType(typeName);</span><br><span class="line">    <span class="keyword">return</span> (T)Activator.CreateInstance(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呼叫端則是這樣呼叫的: </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typeName = <span class="string">"LogicLayer.DerivedModel"</span>;</span><br><span class="line"><span class="keyword">var</span> type = Create&lt;BaseModel&gt;(typeName);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Create&lt;T&gt;(string typeName)</code> 方法沒有這麼單純, 範例只是為了描述問題, 而 “LogicLayer.DerivedModel” 是存在資料庫中的資料, 被取出來後做為引數代入 <code>Create&lt;T&gt;(string typeName)</code> 方法中.  </p>
</blockquote>
<p>當時覺得就只是將方法原封不動的搬去 <code>Shared</code> 專案中, 編譯和單元測試都有過也就不應該出什麼問題, 沒想卻在執行階段卻出現 Exception.  </p>
<h3 id="原因與解決方式"><a href="#原因與解決方式" class="headerlink" title="原因與解決方式"></a>原因與解決方式</h3><p>主要是因為 <code>typeName</code> 並不是目前組件 <code>Shared</code> 中的類別, 所以 <code>Type.GetType(typeName)</code> 會回傳 <code>null</code>, 導致接下來的 NullReferenceException.  </p>
<p>由於這個 <code>Create&lt;T&gt;(string typeName)</code> 方法必須在 <code>Shared</code> 專案才合理, 不能因為這樣不搬 ; 而如果使用完整的組件限定名稱 (assembly-qualified name), 像這個樣子 <code>LogicLayer.DerivedModel, LogicLayer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</code> 也不適當, 因為這個值是存在資料庫中的, 在相容舊資料的限制下不能這樣做.  </p>
<p>最後是把 <code>Create&lt;T&gt;(string typeName)</code> 改成 <code>Create&lt;T&gt;(Type type)</code>, 由呼叫端取得 <code>Type</code> 後再傳入, 由於目前系統的前提是 typeName 必定屬於 <code>LogicLayer</code> 專案中的類別, 所以這樣做是合理的.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實是低級錯誤, 因為這個方法其實是有做單元測試的, 但是測資 (<code>typeName</code>) 用了完整的組件限定名稱, 跟資料庫的真實資料格式不一樣, 所以測了也是白測才會拖到執行階段才發現錯誤.  </p>
<p>另外題外話就是, 把類別名稱 (type name) 存在資料庫後再拿出來反射, 就我目前的觀點是很不好的行為, 因為這樣子會讓資料庫的資料本身跟應用程式的語言特性產生依賴, 別說應用程式換語言的時候這個資料就不能用了 (或是需要經過轉換才能用) , 就算只要類別改名都能讓舊資料直接造成在執行階段出錯, 變成類別的命名與資料庫資料這兩個八竿子打不著的事情產生依賴, 提高維護的風險與成本.  </p>
<blockquote>
<p>不只是類別名稱與反射, 應該要避免跟程式語言或框架執行有關的資料進資料庫進而產生依賴, 就算特殊情境也應該特別拿出來專門討論後面的維護風險以及是否有適合的替代方案.  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[NUnit 中一次性初始化的涵蓋範圍]]></title>
      <url>/content/20200606-nunit-one-time-setup-level.html</url>
      <content type="html"><![CDATA[<p>一般來說套件的使用方式沒什麼好寫的, 但是使用 NUnit 的 OneTimeSetUp 時, 究竟是在多大的範圍做一次性的行為會根據這個特性 (Attribute) 的使用位置而不同, 這部分文件是放在 <a href="https://github.com/nunit/docs/wiki/SetUpFixture-Attribute" target="_blank" rel="noopener">SetUpFixture Attribute 一節</a> 說明, 不過沒有所有情境的範例程式, 所以做了一些實驗來簡單紀錄一下更細節的部分.  </p>
<a id="more"></a>
<h3 id="使用方式與範圍"><a href="#使用方式與範圍" class="headerlink" title="使用方式與範圍"></a>使用方式與範圍</h3><p>OneTimeSetUp 根據所使用的位置不同, 涵蓋的範圍會不同, 主要有三種: </p>
<ul>
<li><strong>類別層級 :</strong><br>該類別下加上 OneTimeSetUp 特性的方法只會執行一次.  </li>
<li><strong>命名空間層級 :</strong><br>該命名空間下加上 OneTimeSetUp 特性的方法只會執行一次, 且該類別上需要加 SetUpFixture 特性, <strong>包含子命名空間</strong>, 例如命名空間 <code>NS</code> 下的 OneTimeSetUp 在 <code>NS</code> 和 <code>NS.Sub</code> 命名空間總共只會執行一次.  </li>
<li><strong>組件層級 :</strong><br>若不在任何命名空間下, 則加上 OneTimeSetUp 特性的方法在整個組件中只會執行一次, 而該類別上也需要加 SetUpFixture 特性.  </li>
</ul>
<h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> NUnit.Framework;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SetUpFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OneTimeSetupClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">OneTimeSetUp</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OneTimeSetupMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Print(<span class="string">$"-- Assembly wide one-time setup."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NS</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SetUpFixture</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OneTimeSetupClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">OneTimeSetUp</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OneTimeSetupMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"-- Namespace wide one-time setup."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestFixture</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">OneTimeSetUp</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OneTimeSetupMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"-- Class wide one-time setup."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NS.TestClass1.TestMethod1()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NS.TestClass1.TestMethod2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestFixture</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass2</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">OneTimeSetUp</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OneTimeSetupMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"-- Class level one-time setup 2."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NS.TestClass2.TestMethod1()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NS.TestClass2.TestMethod2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NS.Sub</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestFixture</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NS.Sub.TestClass1.TestMethod1()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NS.Sub.TestClass1.TestMethod2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NotNS</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestFixture</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NotNS.TestClass1.TestMethod1()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Test</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Debug.Print(<span class="string">$"Executeing NotNS.TestClass1.TestMethod2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是示範程式碼, 可以從下方的輸出訊息中看出一次性行為的範圍:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- Assembly wide one-time setup.</span><br><span class="line">Executeing NotNS.TestClass1.TestMethod1()</span><br><span class="line">Executeing NotNS.TestClass1.TestMethod2()</span><br><span class="line">-- Namespace wide one-time setup.</span><br><span class="line">Executeing NS.Sub.TestClass1.TestMethod1()</span><br><span class="line">Executeing NS.Sub.TestClass1.TestMethod2()</span><br><span class="line">-- Class wide one-time setup.</span><br><span class="line">Executeing NS.TestClass1.TestMethod1()</span><br><span class="line">Executeing NS.TestClass1.TestMethod2()</span><br><span class="line">-- Class level one-time setup 2.</span><br><span class="line">Executeing NS.TestClass2.TestMethod1()</span><br><span class="line">Executeing NS.TestClass2.TestMethod2()</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>因為 OneTimeSetUp 是根據所使用的位置不同而有不同的涵蓋範圍, 所以一開始有點不確定怎麼用, 就稍微寫一下簡單的筆記紀錄一下.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://github.com/nunit/docs/wiki/SetUpFixture-Attribute" target="_blank" rel="noopener">SetUpFixture Attribute</a>  </p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Aggregate Services 收斂依賴注入的物件]]></title>
      <url>/content/20200403-dependency-injection-aggregate-services.html</url>
      <content type="html"><![CDATA[<p>這篇是為了紀錄依賴注入時, 利用建構子注入的情境下, 當注入到有繼承關係的類別時所引發的維護上的困擾與解決方案.  </p>
<a id="more"></a>
<h3 id="問題背景"><a href="#問題背景" class="headerlink" title="問題背景"></a>問題背景</h3><p>考慮下面的程式碼  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseServcie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFooDAO _fooDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseServcie</span>(<span class="params">IFooDAO fooDAO</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _fooDAO = fooDAO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedService</span> : <span class="title">BaseServcie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IBarDAO _barDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedService</span>(<span class="params">IFooDAO fooDAO, IBarDAO barDAO</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">fooDAO</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _barDAO = barDAO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由於這個情境下, 父類別 (基底類別) 只有一個有參數的建構子, 所以不會從編譯器取得公開無參數建構子 (註1) , 而子類別 (衍生類別) 的建構子必須明確指定所要使用的父類別的建構子.  </p>
<blockquote>
<p>註1:<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-constructors" target="_blank" rel="noopener">Unless the class is static, classes without constructors are given a public parameterless constructor by the C# compiler in order to enable class instantiation</a>  </p>
</blockquote>
<p>這樣的問題在於, 當父類別的建構子參數數量改變時, 所有子類別的建構子要同時修改, 如果子類別很多的話, 必然會造成維護上的困擾. 直覺上當然可以改用其他注入方式, 例如直接從 DI 套件提供的 service provider 去取得實體, 但這樣會有比較難做單元測試的缺點, 不是優先選項.  </p>
<h3 id="Aggregate-Service"><a href="#Aggregate-Service" class="headerlink" title="Aggregate Service"></a>Aggregate Service</h3><p>要避免這樣的問題的切入點就是 <code>讓父類別的參數數量固定一個就好</code>, 也就是 Aggregate Service 的概念, 這樣子不管之後要怎麼改動父類別所依賴的物件數量, 不論是父類別還是廣大的子類別們都不需要修改任何建構子的參數列.  </p>
<h4 id="通用作法"><a href="#通用作法" class="headerlink" title="通用作法"></a>通用作法</h4><p>如下程式碼: </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseServcie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFooDAO _fooDAO;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseServcie</span>(<span class="params">AggregateBaseServiceDAO aggregateDAO</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _fooDAO = aggregateDAO.FooDAO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedService</span> : <span class="title">BaseServcie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IBarDAO _barDAO;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedService</span>(<span class="params">AggregateBaseServiceDAO aggregateDAO, IBarDAO barDAO</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">aggregateDAO</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _barDAO = barDAO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AggregateBaseServiceDAO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AggregateBaseServiceDAO</span>(<span class="params">IFooDAO _fooDAO</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FooDAO = _fooDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IFooDAO FooDAO &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IFooDAO</code> 收納進 <code>AggregateBaseServiceDAO</code> 成為一個屬性, 就算之後 <code>BaseServcie</code> 需要增加其他的依賴, <code>BaseServcie</code> 和 <code>DerivedService</code> 的建構子也都不會受到影響.<br>這個通用做法也不是什麼特別的概念, 就是在建構子注入的基礎下加上一點變化而已, 理論上也不會受限於使用哪一個 DI 套件.  </p>
<blockquote>
<p>如果沒必要的話, 不一定要多新增一個介面 <code>IAggregateBaseServiceDAO</code> 來讓 <code>AggregateBaseServiceDAO</code> 實作.  </p>
</blockquote>
<h4 id="Autofac-的-RegisterAggregateService"><a href="#Autofac-的-RegisterAggregateService" class="headerlink" title="Autofac 的 RegisterAggregateService"></a>Autofac 的 RegisterAggregateService</h4><p>Autofac 提供了比較方便的用法, Aggregate Service 簡化成如下面這樣, 但是 <strong>Aggregate Service 必須是介面</strong>, 且除了 Autofac 本身外需要安裝另外一個套件 Autofac.Extras.AggregateService.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAggregateBaseServiceDAO</span></span><br><span class="line">&#123;</span><br><span class="line">    IFooDAO FooDAO &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外, 註冊的時候要改用 <code>RegisterAggregateService</code> 方法如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.RegisterAggregateService&lt;IAggregateBaseServiceDAO&gt;();</span><br></pre></td></tr></table></figure></p>
<p>這邊可以看到 Autofac 簡化了 Aggregate Service 內部的建構子注入的部分, 讓使用的時候不會覺得為了封裝這些物件而需要多做很多事, 限制 Aggregate Service 必須是介面且不需要實作類別, 某種程度上也有暗示後面維護者不要去誤用它的效果, 比起前面介紹的通用型 Aggregate Service 來說優點更多.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>總體來說, 如果用 Autofac 且多安裝一個套件 Autofac.Extras.AggregateService 不會造成困擾的話, 用 Autofac 的作法會比較漂亮一點. 但如果 DI 套件沒有相關功能的話, 用通用的作法也是很不錯的.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://autofaccn.readthedocs.io/en/latest/advanced/aggregate-services.html" target="_blank" rel="noopener">Autofac Aggregate Services</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[套件相依性問題]]></title>
      <url>/content/20200301-dependent-assembly-issue.html</url>
      <content type="html"><![CDATA[<p>這個問題比較複雜, 一開始引發問題的情境是  </p>
<blockquote>
<p>A 專案依賴 B 專案, 且雙方都依賴同一個套件, 但卻是不同版本的套件</p>
</blockquote>
<p>由於情境比較複雜, 所以我開了一個<a href="https://github.com/ronsun/Demo/tree/master/DependentAssemblyIssue" target="_blank" rel="noopener">範例專案 DependentAssemblyIssue</a> 來做示範, 內文會依照情境來描述處理方式以及所造成的後遺症.  </p>
<a id="more"></a>
<h3 id="初始可運作的情境"><a href="#初始可運作的情境" class="headerlink" title="初始可運作的情境"></a>初始可運作的情境</h3><p>以範例專案中, 第一個 commit <code>1c5d263</code> 為例, 依賴關係如下:  </p>
<ul>
<li>Client.MVC 依賴 Library</li>
<li>Client.MVC 依賴 Newtonsoft.Json 6.0.1 版</li>
<li>Library 依賴 Newtonsoft.Json 6.0.1 版</li>
</ul>
<p>其中在 Client.MVC 專案的 <code>Global.asax.cs</code> 中呼叫 Library 專案的靜態方法 <code>Worker.Do()</code> 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AreaRegistration.RegisterAllAreas();</span><br><span class="line">    FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);</span><br><span class="line">    RouteConfig.RegisterRoutes(RouteTable.Routes);</span><br><span class="line">    BundleConfig.RegisterBundles(BundleTable.Bundles);</span><br><span class="line"></span><br><span class="line">    Worker.Do();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Worker.Do()</code> 會在 Client.MVC 開啟後在 Visual Studio 的 Output 視窗印一行 log, 可以正常運作.  </p>
<h3 id="升版-Library-依賴的-Newtonsoft-Json-引發錯誤"><a href="#升版-Library-依賴的-Newtonsoft-Json-引發錯誤" class="headerlink" title="升版 Library 依賴的 Newtonsoft.Json 引發錯誤"></a>升版 Library 依賴的 Newtonsoft.Json 引發錯誤</h3><p>接下來我們假設維護 Library 專案的小組將 Newtonsoft.Json 的版本升級到 8.0.1 (commit <code>89d3eb9</code>), 這時候 Client.MVC 還是依賴 6.0.1 版, 而當其呼叫 <code>Worker.Do()</code> 時, 就會拋出例外<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.IO.FileLoadException: &apos;Could not load file or assembly &apos;Newtonsoft.Json, Version=8.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed&apos; or one of its dependencies. The located assembly&apos;s manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)&apos;</span><br></pre></td></tr></table></figure></p>
<p>這是因為 Client.MVC 在編譯期間根據 <code>Web.config</code> 中的設定將對版本 0.0.0.0 到 6.0.0.0 (oldVersion) 的參考導向 6.0.0 (newVersion) 但是 Library 專案依賴的是 8 版的關係.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependentAssembly</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assemblyIdentity</span> <span class="attr">name</span>=<span class="string">"Newtonsoft.Json"</span> <span class="attr">publicKeyToken</span>=<span class="string">"30ad4fe6b2a6aeed"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bindingRedirect</span> <span class="attr">oldVersion</span>=<span class="string">"0.0.0.0-6.0.0.0"</span> <span class="attr">newVersion</span>=<span class="string">"6.0.0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependentAssembly</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h3><p>解決方式有兩個方向, 但是都有相對的副作用.  </p>
<h4 id="修改-oldVersion"><a href="#修改-oldVersion" class="headerlink" title="修改 oldVersion"></a>修改 oldVersion</h4><p>將 <code>bindingRedirect</code> 的屬性 <code>oldVersion</code> 改成 <code>0.0.0.0-8.0.0.0</code>, 將 8 版以下的 Newtonsoft.Json 依賴繫結到 6 版, 如 commit <code>b827286</code> 或下方所示.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bindingRedirect</span> <span class="attr">oldVersion</span>=<span class="string">"0.0.0.0-8.0.0.0"</span> <span class="attr">newVersion</span>=<span class="string">"6.0.0.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是這會有個嚴重的副作用, 由於編譯出來後是使用 6 版的套件, 當 Library 專案中呼叫了 8 版的套件的新 API 時, 會發生編譯時期甚至單元測試都沒問題, 但是卻在 Client.MVC 的執行階段發生錯誤, 如 commit <code>2cc0617</code> 所示.  </p>
<p>另一個更難除錯的情境的是, 當所使用的 API 接口沒有改變, 但是改變了實作細節導致新舊版本執行結果不同的時候, 可能連錯誤訊息都沒有就更難除錯了(這部分沒找到適合展示與驗證的 API, 只是推測).  </p>
<h4 id="同時升版-Client-MVC-依賴的-Newtonsoft-Json"><a href="#同時升版-Client-MVC-依賴的-Newtonsoft-Json" class="headerlink" title="同時升版 Client.MVC 依賴的 Newtonsoft.Json"></a>同時升版 Client.MVC 依賴的 Newtonsoft.Json</h4><p>這就像 commit <code>4ec7c50</code> 這樣, 直接將 Client.MVC 所依賴的套件版本升到跟 Library 相同版本, 另外 <code>bindingRedirect</code> 也要修改如下.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bindingRedirect</span> <span class="attr">oldVersion</span>=<span class="string">"0.0.0.0-8.0.0.0"</span> <span class="attr">newVersion</span>=<span class="string">"8.0.0.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但這也意味了 Library 所依賴的套件版本更改時, Client.MVC 也需要修改相應的套件版本, 這在維護上是很容易忽略的細節, 而如果 Library 和 Client.MVC 是兩個不同的小組維護的時候, 這個問題就更容易延後發現了.  </p>
<p>除了維護不方便的問題外, Client.MVC 修改相應的套件版本也就意味著他直接使用該套件的程式碼都需要重新測試, 避免新版本的 API 與舊版本運作結果不同.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這個問題發生的時候其實花了不少時間去找, 因為對於 Client.MVC 來說是明明什麼都沒做但他就壞了, <code>Web.config</code> 中的設定是一開始引入套件時就自動加好的, 所以也沒有想到有這一段.  </p>
<p>事後其實有想過怎麼在未來預防這類的問題, 目前來說還沒想到如何簡單又漂亮的完全避開這個問題, 一個想法就是盡量避免這樣的依賴關係, 從簡化專案與套件的依賴這個角度可以有一定程度的效果, 但無法完全避免, 因為從現實專案來看就真的兩個專案都要直接依賴 Newtonsoft.Json, 而特別幫 Newtonsoft.Json 做一層隔離層讓兩個專案依賴也是一種方式, 但如果類推到每個套件都要做公用的隔離層那改動就比較大了.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/redirect-assembly-versions#redirecting-assembly-versions-by-using-publisher-policy" target="_blank" rel="noopener">Redirecting Assembly Versions</a>  </p>
<p><a href="https://stackoverflow.com/questions/16578819/understanding-a-csproj-assembly-reference/16580870" target="_blank" rel="noopener">Understanding a csproj assembly reference</a>  </p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[透過 Jenkins 開關 dotnet core 應用程式]]></title>
      <url>/content/20200120-dotnet-command-by-jenkins.html</url>
      <content type="html"><![CDATA[<p>前陣子做了一個 dotnet core 的新專案, 上線前需要先跟 Jenkins 佈署流程整合, 本來很單純的想說用 <code>dotnet MyCore.dll</code> 指令開啟應用程式, 至於停止的時候就暴力用 <code>kill</code> 指令來關閉 (當然這種暴力解只是在實驗階段用來建立信心的, 接下來還是要找看有沒有其他更好的做法).  </p>
<p>沒想到連信心都建立不起來, 透過 Jenkin 用  <code>kill</code> 指令時, 會出現錯誤 (沒有把錯誤細節記錄下來, 反正用 <code>kill</code> 也太暴力, 終究還是要換個方法的, 所以就果斷放棄去找尋新方法了).  </p>
<a id="more"></a>
<h3 id="使用-dotnet-指令"><a href="#使用-dotnet-指令" class="headerlink" title="使用 dotnet 指令"></a>使用 dotnet 指令</h3><p>方便歸方便, 但如同一開始說的, 跟 Jenkins 整合的時候會有問題, 這裡就是順便紀錄一下指令而已, 沒什麼特別的.  </p>
<h4 id="開啟應用程式"><a href="#開啟應用程式" class="headerlink" title="開啟應用程式"></a>開啟應用程式</h4><p><code>dotnet MyCore.dll &gt; /dev/null 2&gt;&amp;1 &amp;</code></p>
<h4 id="停止應用程式"><a href="#停止應用程式" class="headerlink" title="停止應用程式"></a>停止應用程式</h4><p><code>kill -9 11905</code></p>
<blockquote>
<p>11905 是 pid</p>
</blockquote>
<h3 id="用-systemctl-指令管理"><a href="#用-systemctl-指令管理" class="headerlink" title="用 systemctl 指令管理"></a>用 systemctl 指令管理</h3><h4 id="建立服務"><a href="#建立服務" class="headerlink" title="建立服務"></a>建立服務</h4><p><strong>新增 MyCore.service</strong><br><code>vim /etc/systemd/system/MyCore.service</code></p>
<p><strong>編輯內容</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=This is MyCore</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/usr/dotnet/MyCore/</span><br><span class="line">ExecStart=/usr/bin/dotnet /usr/dotnet/MyCore/MyCore.dll</span><br><span class="line">Environment=ASPNETCORE_ENVIRONMENT=Development</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>這裡要注意的是環境變數要設定在服務檔裡面才有效.  </li>
<li>上面服務檔的範例只是極簡版, 能動而已, <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.1#create-the-service-file" target="_blank" rel="noopener">官方範例參考這裡</a>  </li>
</ol>
</blockquote>
<p><strong>啟用</strong><br>用 <code>systemctl</code> 開關應用程式.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start MyCore  </span><br><span class="line">systemctl stop MyCore</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>如果會用 linux 的話其實不用特別紀錄, 只要知道用 <code>systemctl</code> 取代 <code>dotnet</code> 來開關應用程式就好, 但是我很不會用 linux, 所以還是要備忘一下, 免得下次遇到一樣的問題要 google 連關鍵字都不會下.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://kimsereyblog.blogspot.com/2018/05/manage-kestrel-process-with-systemd.html" target="_blank" rel="noopener">Manage Kestrel process with systemd</a><br><a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.1#create-the-service-file" target="_blank" rel="noopener">Host ASP.NET Core on Linux with Nginx</a><br><a href="https://swimburger.net/blog/dotnet/how-to-run-aspnet-core-as-a-service-on-linux" target="_blank" rel="noopener">How to run ASP.NET Core as a service on Linux (RHEL)</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[追蹤與反組譯 C# 程式碼]]></title>
      <url>/content/20191229-trace-csharp-source-code.html</url>
      <content type="html"><![CDATA[<p>在開發 C# 程式或是學習過程, 會用到許多不是由我們開發的框架或套件, 很多時候會需要知道內部的運作方式, 這篇紀錄幾個方式來讓我們能知道套件內部究竟做了什麼.  </p>
<a id="more"></a>
<h3 id="官方原始碼"><a href="#官方原始碼" class="headerlink" title="官方原始碼"></a>官方原始碼</h3><p>最準確的方式, 直接看官方提供的原始碼, 可能存放在 GitHub 或其他儲存庫, 一般小型第三方套件應該都能快速了解, 但是如果要看的是 .NET Framework 或是超大型套件時, 就會比較費神, 而且也無法期待所有套件都有開源.  </p>
<p>另外 .NET Framework 和 .NET Core 都有原始碼查詢網站, 可以快速找到原始碼的實作內容.  </p>
<ul>
<li><a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">.NET Framework Reference Source</a>  </li>
<li><a href="https://source.dot.net/" target="_blank" rel="noopener">.NET Core Source Browser</a></li>
</ul>
<h3 id="Visual-Studio-2019"><a href="#Visual-Studio-2019" class="headerlink" title="Visual Studio 2019"></a>Visual Studio 2019</h3><p>直接內建在 Visual Studio 中, GoToDefinition (F12) 進入就可以看到, 設定方式也很簡單:<br><code>Tools &gt; Options &gt; Text Editor &gt; C# &gt; Advanced &gt; enable navigation to decompiled sources (experimental)</code>  </p>
<p>但是這個功能在 .NET Core 的專案上無法反組譯出正確內容, 選項上也標明 experimental.  </p>
<img src="/content/20191229-trace-csharp-source-code/vs_decompil_001.png">   
<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><h4 id="ILSpy"><a href="#ILSpy" class="headerlink" title="ILSpy"></a>ILSpy</h4><p>第三方反組譯工具很多, 其中我最推薦的是 ILSpy, 可在 <code>Extensions &gt; Manage Extensions</code> 裡面找到並安裝, 能在 Visual Studio 直接按右鍵開啟 ILSpy 非常方便.<br><img src="/content/20191229-trace-csharp-source-code/ilspy_decompil_001.png">   </p>
<p>開啟後也可以選擇 C# 版本<br><img src="/content/20191229-trace-csharp-source-code/ilspy_decompil_002.png">   </p>
<p>另外也可以選擇 C# 跟 IL 同時顯示, 可以對照著看, 了解不同寫法編譯後是不是一樣的內容, 看不懂 IL Code 也沒關係, 滑鼠移過去還會出現說明框, 點擊後會開啟瀏覽器導頁到 msdn, 這部分在實驗學習的過程很好用.  </p>
<img src="/content/20191229-trace-csharp-source-code/ilspy_decompil_003.png">   
<h4 id="dotPeek-和-JustDecompile"><a href="#dotPeek-和-JustDecompile" class="headerlink" title="dotPeek 和 JustDecompile"></a>dotPeek 和 JustDecompile</h4><p>比起 ILSpy 介面好看很多, 很多方便的功能, 如果是要仔細看程式流程的話, 這兩者更適合.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>反組譯工具所產生的程式碼不一定跟原本的內容一樣, 如果真的要研究實作方式等細節的話, 還是直接看開源的程式碼內容比較準確.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://github.com/icsharpcode/ILSpy" target="_blank" rel="noopener">ILSpy</a><br><a href="https://www.jetbrains.com/decompiler/" target="_blank" rel="noopener">dotPeek</a><br><a href="https://www.telerik.com/products/decompiler.aspx" target="_blank" rel="noopener">JustDecompile</a>  </p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Json.NET 反序列化數字時, 尾數 0 可能被捨棄]]></title>
      <url>/content/20191126-json-net-trailing-zero-number-problem.html</url>
      <content type="html"><![CDATA[<p>用 Json.NET 來將 JSON 字串反序列化成物件是很典型的做法, 以前也沒出過什麼問題, 但在某些使用方式下, 會出現數字的尾數 0 被移除的狀況, 例如: 10.00 會被轉成 10, 而 10.10 會被轉成 10.1.  </p>
<p>雖然這個結果乍看之下沒什麼影響, 但如果資料是在跟第三方 API 介接時, 簽章 (sign) 所需要的欄位時, 就會直接導致簽章檢核錯誤.  </p>
<a id="more"></a>
<h3 id="正常情境"><a href="#正常情境" class="headerlink" title="正常情境"></a>正常情境</h3><p>以我之前習慣將 JSON 字串反序列化成 Model 的用法來說, 是不會有這個問題的, 如下.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonProperty(<span class="meta-string">"money"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> jsonString = <span class="string">"&#123;\"money\":10.10&#125;"</span>;</span><br><span class="line">    <span class="keyword">var</span> data = JsonConvert.DeserializeObject&lt;Data&gt;(jsonString);</span><br><span class="line">    <span class="comment">// output: 10.10</span></span><br><span class="line">    Console.WriteLine(data.Money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出問題的情境"><a href="#出問題的情境" class="headerlink" title="出問題的情境"></a>出問題的情境</h3><h4 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h4><p>如果我們的 API 接受大量來自外部的呼叫, 且 JSON 的欄位名稱與結構不固定, 我們可能不希望建立大量的 Model 來反序列化, 那程式碼可能會變成下面這樣: </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> jsonString = <span class="string">"&#123;\"money\":10.10&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> data = JObject.Parse(jsonString);</span><br><span class="line"><span class="comment">// output: 10.1</span></span><br><span class="line">Console.WriteLine(data.GetValue(<span class="string">"money"</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不只是直接用 <code>JObject</code> 取值的情境, 要把 JSON 字串轉成一個 <code>Dictionary</code> 或類似情境時, 都會碰到這個問題.  </p>
</blockquote>
<h4 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h4><p>雖然複雜很多, 但用在解析不固定結構的 JSON 字串 (<code>jsonString</code>) 並取出特定欄位或所有欄位時很方便, 且要取出的欄位名稱可做為參數也支援巢狀的結構(只要符合 JSONPath expression 的規則).  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> jsonString = <span class="string">"&#123;\"money\":10.10&#125;"</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StringReader(jsonString))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> jr = <span class="keyword">new</span> JsonTextReader(sr))</span><br><span class="line">&#123;</span><br><span class="line">    jr.FloatParseHandling = FloatParseHandling.Decimal;</span><br><span class="line">    <span class="keyword">var</span> jsonContent = JToken.ReadFrom(jr);</span><br><span class="line">    <span class="keyword">var</span> target = jsonContent.SelectToken(<span class="string">"money"</span>);</span><br><span class="line">    <span class="comment">// output: 10.10</span></span><br><span class="line">    Console.WriteLine(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>一般情境下, 反序列化還是建議盡量轉換成 Model, 後續會好操作很多, 且可以減少用 <code>JObject</code> 等方式操作造成執行階段容易出錯的疑慮. 但在現實專案中, 條件總是比較複雜, 還要考慮原本系統的設計與現況, 所以還是可能會遇到不適合反序列化成特定 Model 的情境, 就需要靈活變化了.  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Packages </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[不依賴 DDEX provider 使用 Entity Framework 操作 SQLite]]></title>
      <url>/content/20191017-manually-use-sqlite-with-ef.html</url>
      <content type="html"><![CDATA[<p>在之前的文章 <a href="/content/20190907-use-sqlite-with-ef-and-vs2017.html" title="在 vs2017 中使用 Entity Framework 操作 SQLite">在 vs2017 中使用 Entity Framework 操作 SQLite</a> 使用方式雖然方便, 但是相對的非常依賴工具, 所以這篇用來記錄用盡量少的工具來使用 Entity Framework 操作 SQLite.    </p>
<a id="more"></a>
<h3 id="套件與工具安裝"><a href="#套件與工具安裝" class="headerlink" title="套件與工具安裝"></a>套件與工具安裝</h3><p>不同於之前, 這次只需要</p>
<ul>
<li><a href="https://github.com/ErikEJ/SqlCeToolbox/wiki/EF6-workflow-with-SQLite-DDEX-provider#install-systemdatasqlite-nuget-package" target="_blank" rel="noopener">安裝 NuGet 套件 System.Data.Sqlite</a><br>System.Data.Sqlite 會一併安裝依賴的套件與 Entity Framework 本身.  </li>
</ul>
<h3 id="設定-App-config"><a href="#設定-App-config" class="headerlink" title="設定 App.config"></a>設定 App.config</h3><p>App.config 中主要有三個部分要設定, 有些在安裝 System.Data.Sqlite 與 Entity Framework 時會有預設的內容, 預設內容可能需要調整, 可運作的版本如下:  </p>
<h4 id="lt-providers-gt-區塊"><a href="#lt-providers-gt-區塊" class="headerlink" title="&lt;providers&gt; 區塊"></a><code>&lt;providers&gt;</code> 區塊</h4><p>這個區塊在 <code>&lt;entityFramework&gt;&lt;/entityFramework&gt;</code> 中, 安裝完 Entity Framework 會自動生成一組範本, 修改後只留必要的.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">provider</span> <span class="attr">invariantName</span>=<span class="string">"SQLiteProvider"</span> <span class="attr">type</span>=<span class="string">"System.Data.SQLite.EF6.SQLiteProviderServices, System.Data.SQLite.EF6"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="lt-system-data-gt-區塊"><a href="#lt-system-data-gt-區塊" class="headerlink" title="&lt;system.data&gt; 區塊"></a><code>&lt;system.data&gt;</code> 區塊</h4><p>這個區塊在 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system.data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DbProviderFactories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"SQLite Data Provider"</span> <span class="attr">invariant</span>=<span class="string">"SQLiteProvider"</span> <span class="attr">description</span>=<span class="string">".NET Framework Data Provider for SQLite"</span> <span class="attr">type</span>=<span class="string">"System.Data.SQLite.SQLiteFactory, System.Data.SQLite"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">DbProviderFactories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system.data</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="lt-connectionStrings-gt-區塊"><a href="#lt-connectionStrings-gt-區塊" class="headerlink" title="&lt;connectionStrings&gt; 區塊"></a><code>&lt;connectionStrings&gt;</code> 區塊</h4><p>這個區塊在 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中, 跟 <code>&lt;system.data&gt;</code> 同一層.  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"NorthwindConnection"</span> <span class="attr">providerName</span>=<span class="string">"SQLiteProvider"</span> <span class="attr">connectionString</span>=<span class="string">"data source=C:\Users\Ron\Desktop\SqliteDemo\SqliteDemo\Northwind.sqlite"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h4><p>相較於之前透過工具產生的內容, 這邊手動調整後簡短很多, 要注意的大概就是 providerName, invariant 和 invariantName 要對得起來, connectionString 寫好就好.  </p>
<h3 id="新增-Model"><a href="#新增-Model" class="headerlink" title="新增 Model"></a>新增 Model</h3><p>以北風資料庫中的 Category 表為例, 新增一個相應的 Model 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Category</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> CategoryName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="新增-NorthwindContext"><a href="#新增-NorthwindContext" class="headerlink" title="新增 NorthwindContext"></a>新增 NorthwindContext</h3><p>繼承 <code>DbContext</code> 並覆寫 <code>OnModelCreating(DbModelBuilder)</code> 方法, 設定資料表跟 Model 的對應, 並增加相應的 <code>DbSet&lt;T&gt;</code>.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">NorthwindContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NorthwindContext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"><span class="string">"name=NorthwindConnection"</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">DbModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        modelBuilder.Entity&lt;Category&gt;().ToTable(<span class="string">"Category"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> DbSet&lt;Category&gt; Categories &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DbContext</code> 的部分就我目前理解是 UnitOfWork Pattern 的實作, 而 <code>DbSet&lt;T&gt;</code> 則像是 Generic Repository.  </p>
</blockquote>
<h3 id="寫段程式用用看"><a href="#寫段程式用用看" class="headerlink" title="寫段程式用用看"></a>寫段程式用用看</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> NorthwindContext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> categories = context.Categories.ToList();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> category <span class="keyword">in</span> categories)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$"<span class="subst">&#123;category.CategoryName&#125;</span>: <span class="subst">&#123;category.Description&#125;</span>"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>用這種方式來優點就是彈性, 減少開發工具的相容性的問題, 另一方面, 實作過程能更清楚每個環節的角色, 即使不完全了解細節也能避免過度依賴工具自動產生程式碼而忘記要去了解內容. </p>
<p>缺點也是顯而易見的, 資料庫欄位變動後都需要手動維護 Model 和 <code>NorthwindContext</code>, 沒有工具幫忙同步, 維護成本高.</p>
<p>總結來說, 用在產品開發上太耗時間有點不實際, 但作為工具限制下的方案或是學習用途還是很適合的.  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在 vs2017 中使用 Entity Framework 操作 SQLite]]></title>
      <url>/content/20190907-use-sqlite-with-ef-and-vs2017.html</url>
      <content type="html"><![CDATA[<p>有時候做一些實驗的時候會需要用到資料庫, 但是為了實驗特別架一個 SQL Server 的環境實在是很麻煩, 電腦重灌或是虛擬機重裝的時候重建也麻煩, 所以就把腦筋動到 SQLite 上了, 不過操作上沒有想像中的簡單呢.  </p>
<p>因為是為了建構實驗用的資料庫, 不希望花太多時間, 希望能盡可能方便的將資料存取層建起來, 所以採用資料庫優先 (database first) 的方式來建立 ADO.NET Entity Data Model (*.edmx).   </p>
<a id="more"></a>
<h3 id="套件與工具安裝"><a href="#套件與工具安裝" class="headerlink" title="套件與工具安裝"></a>套件與工具安裝</h3><p>System.Data.SQLite DDEX provider 不支援 Visual Studio 2017, 所以需要借助其他套件的幫忙, <a href="https://github.com/ErikEJ/SqlCeToolbox/wiki/EF6-workflow-with-SQLite-DDEX-provider" target="_blank" rel="noopener">SqlCeToolbox</a> 提供套件支援與安裝教學, 內容很完整, 所以這邊只稍微列一下步驟.  </p>
<ul>
<li><p><a href="https://github.com/ErikEJ/SqlCeToolbox/wiki/EF6-workflow-with-SQLite-DDEX-provider#install-latest-toolbox" target="_blank" rel="noopener">安裝 SqlCeToolbox</a></p>
</li>
<li><p><a href="https://github.com/ErikEJ/SqlCeToolbox/wiki/EF6-workflow-with-SQLite-DDEX-provider#install-sqlite-in-gac" target="_blank" rel="noopener">安裝 SQLite 到 GAC</a><br>這邊要注意只能安裝特定版本才行, 特定版本會有下面的標註 (粗體放大應該不難找), 我是安裝 <strong>Setups for 32-bit Windows (.NET Framework 4.6)</strong> 這個版本.  </p>
<blockquote>
<p>This is the only setup package that is capable of installing the design-time components for Visual Studio 2015. </p>
</blockquote>
</li>
<li><p><a href="https://github.com/ErikEJ/SqlCeToolbox/wiki/EF6-workflow-with-SQLite-DDEX-provider#install-systemdatasqlite-nuget-package" target="_blank" rel="noopener">安裝 NuGet 套件 System.Data.Sqlite</a><br>System.Data.Sqlite 會一併安裝依賴的套件與 Entity Framework 本身.  </p>
</li>
</ul>
<h3 id="新增-ADO-NET-Entity-Data-Model-edmx"><a href="#新增-ADO-NET-Entity-Data-Model-edmx" class="headerlink" title="新增 ADO.NET Entity Data Model (*.edmx)"></a>新增 ADO.NET Entity Data Model (*.edmx)</h3><img src="/content/20190907-use-sqlite-with-ef-and-vs2017/edmx_1.png">
<img src="/content/20190907-use-sqlite-with-ef-and-vs2017/edmx_2.png">
<img src="/content/20190907-use-sqlite-with-ef-and-vs2017/edmx_3.png">
<img src="/content/20190907-use-sqlite-with-ef-and-vs2017/edmx_4.png">  
<img src="/content/20190907-use-sqlite-with-ef-and-vs2017/edmx_5.png">
<p>這些步驟有些地方要稍微注意一下</p>
<ul>
<li><p><strong>NorthwindContext</strong> 會成為 App.config 中 <code>connectionStrings</code> 這一段的預設名字, 如下:<br>  <strong>App.config</strong></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"NorthwindContext"</span> <span class="attr">connectionString</span>=<span class="string">"metadata=res://*/DataAccess.Northwind.csdl|res://*/DataAccess.Northwind.ssdl|res://*/DataAccess.Northwind.msl;provider=System.Data.SQLite.EF6;provider connection string=&amp;quot;data source=C:\Users\Ron\Desktop\SqliteDemo\SqliteDemo\Northwind.sqlite;version=3&amp;quot;"</span> <span class="attr">providerName</span>=<span class="string">"System.Data.EntityClient"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  <strong>Northwind.Context.cs</strong></p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">NorthwindContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NorthwindContext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"><span class="string">"name=NorthwindContext"</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// skip...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Model Namespace 一欄的值 <strong>“Northwind”</strong> 會在 Northwind.edmx 中用來作為命名空間, 取個合理的名字就好.  </p>
</li>
</ul>
<h3 id="寫段程式用用看"><a href="#寫段程式用用看" class="headerlink" title="寫段程式用用看"></a>寫段程式用用看</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> NorthwindContext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> categories = context.Categories.ToList();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> category <span class="keyword">in</span> categories)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$"<span class="subst">&#123;category.CategoryName&#125;</span>: <span class="subst">&#123;category.Description&#125;</span>"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>沒意外的話, 會拋出 Exception, 預設在 App.config 中填入的設定是需要一些調整的.  </p>
<h3 id="調整-App-config"><a href="#調整-App-config" class="headerlink" title="調整 App.config"></a>調整 App.config</h3><h4 id="調整"><a href="#調整" class="headerlink" title="調整"></a>調整</h4><p>調整一下 App.config 中,<br><strong>DbProviderFactories</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DbProviderFactories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remove</span> <span class="attr">invariant</span>=<span class="string">"System.Data.SQLite.EF6"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"SQLite Data Provider"</span> <span class="attr">invariant</span>=<span class="string">"System.Data.SQLite.EF6"</span> <span class="attr">description</span>=<span class="string">".NET Framework Data Provider for SQLite"</span> <span class="attr">type</span>=<span class="string">"System.Data.SQLite.SQLiteFactory, System.Data.SQLite"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DbProviderFactories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="App-config-相關內容"><a href="#App-config-相關內容" class="headerlink" title="App.config 相關內容"></a>App.config 相關內容</h4><p>節錄:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">entityFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultConnectionFactory</span> <span class="attr">type</span>=<span class="string">"System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parameters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">parameter</span> <span class="attr">value</span>=<span class="string">"mssqllocaldb"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">parameters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultConnectionFactory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">invariantName</span>=<span class="string">"System.Data.SqlClient"</span> <span class="attr">type</span>=<span class="string">"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">invariantName</span>=<span class="string">"System.Data.SQLite.EF6"</span> <span class="attr">type</span>=<span class="string">"System.Data.SQLite.EF6.SQLiteProviderServices, System.Data.SQLite.EF6"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entityFramework</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system.data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DbProviderFactories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remove</span> <span class="attr">invariant</span>=<span class="string">"System.Data.SQLite.EF6"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"SQLite Data Provider"</span> <span class="attr">invariant</span>=<span class="string">"System.Data.SQLite.EF6"</span> <span class="attr">description</span>=<span class="string">".NET Framework Data Provider for SQLite"</span> <span class="attr">type</span>=<span class="string">"System.Data.SQLite.SQLiteFactory, System.Data.SQLite"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DbProviderFactories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system.data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"NorthwindContext"</span> <span class="attr">connectionString</span>=<span class="string">"metadata=res://*/DataAccess.Northwind.csdl|res://*/DataAccess.Northwind.ssdl|res://*/DataAccess.Northwind.msl;provider=System.Data.SQLite.EF6;provider connection string=&amp;quot;data source=C:\Users\Ron\Desktop\SqliteDemo\SqliteDemo\Northwind.sqlite;version=3&amp;quot;"</span> <span class="attr">providerName</span>=<span class="string">"System.Data.EntityClient"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>&lt;provider invariantName=&quot;System.Data.SQLite.EF6&quot;&gt;</code> 中 <code>invariantName</code> 會被以下幾個地方參考, 要換名字的話四個地方都要換, 不然執行階段會拋例外 </p>
<ul>
<li><code>&lt;DbProviderFactories&gt;</code> 下的 <code>&lt;add&gt;</code> 的屬性 <code>invariant</code>  </li>
<li><code>&lt;connectionStrings&gt;</code> 下的 <code>&lt;add&gt;</code> 的屬性 <code>connectionString</code> 內的 <code>provider</code> </li>
<li>Northwind.edmx 中 <code>&lt;Schema&gt;</code> 的屬性 <code>Provider</code></li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這種做法對於快速開發應用來說很適合, 畢竟工具已經幫忙產出大部分的設定與程式碼.  </p>
<p>但也由於很多內容是自動產生的, 所以如果沒有特別去研究, 會不知道究竟自動產生了什麼設定與程式, 不知道相關細節修改起來就容易出錯, 而且自動產生 *.edmx 還要看所用版本的 visual stuio 有沒有支援, 如果用到不支援的版本就會變得很麻煩.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://github.com/ErikEJ/SqlCeToolbox/wiki/EF6-workflow-with-SQLite-DDEX-provider#install-systemdatasqlite-nuget-package" target="_blank" rel="noopener">EF6 workflow with SQLite DDEX provider</a><br><a href="https://system.data.sqlite.org/index.html/doc/trunk/www/downloads.wiki" target="_blank" rel="noopener">SQLite</a><br><a href="https://erazerbrecht.wordpress.com/2015/06/11/sqlite-entityframework-6-tutorial/" target="_blank" rel="noopener">SQLite EntityFramework 6 Tutorial</a><br><a href="https://github.com/jpwhite3/northwind-SQLite3" target="_blank" rel="noopener">northwind-SQLite3</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在 WebAPI 中處理 multipart/form-data 資料]]></title>
      <url>/content/20190826-handle-multipart-formdata-by-webapi.html</url>
      <content type="html"><![CDATA[<p>在跟外部廠商介接的過程發現少數廠商在發送到我們的 WebAPI 的 request 是 <code>multipart/form-data</code> 的, 以前舊的老專案中要處理這種資料還要透過第三方套件, 後來在遷移到 .NET 的過程中發現,用 .NET 處理這類型的資料是可以不用第三方套件的, 所以紀錄一下碰到的幾種情境的處理方式.  </p>
<a id="more"></a>
<p>這邊除了用 <code>MultipartFormDataContent</code> 和 <code>HttpClient</code> 來模擬客戶端呼叫我們的 WebAPI 之外, 也會用 postman 模擬 (比較方便不用寫程式), 而用 postman 模擬要注意不要額外將 <code>content-type</code> 設成 <code>multipart/form-data</code>, 理由<a href="https://stackoverflow.com/questions/24503961/invalid-httpcontent-instance-provided-it-does-not-have-a-multipart-content/43868741#43868741" target="_blank" rel="noopener">這篇討論的回應</a>中有提到.  </p>
<h3 id="包含-FileName"><a href="#包含-FileName" class="headerlink" title="包含 FileName"></a>包含 FileName</h3><p>客戶端呼叫 API 的程式碼約略如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent())</span><br><span class="line">&#123;</span><br><span class="line">	content.Add(<span class="keyword">new</span> StringContent(<span class="string">"key1"</span>), <span class="string">"value1"</span>, <span class="string">"file1.txt"</span>);</span><br><span class="line">	content.Add(<span class="keyword">new</span> StringContent(<span class="string">"key2"</span>), <span class="string">"value2"</span>, <span class="string">"file2.txt"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> req = <span class="keyword">new</span> HttpClient();</span><br><span class="line">	req.PostAsync(<span class="string">"http://localhost:50640/api/multipart"</span>, content).Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用 postman 模擬的話會是這樣:<br><img src="/content/20190826-handle-multipart-formdata-by-webapi/multipart-with-file.png">   </p>
<p>而 body 的內容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--29874ecd-2a56-406a-a2c0-18eff0d3ae85</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Disposition: form-data; name=value1; filename=file1.txt; filename*=utf-8&apos;&apos;file1.txt</span><br><span class="line"></span><br><span class="line">key1</span><br><span class="line">--29874ecd-2a56-406a-a2c0-18eff0d3ae85</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Disposition: form-data; name=value2; filename=file2.txt; filename*=utf-8&apos;&apos;file2.txt</span><br><span class="line"></span><br><span class="line">key2</span><br><span class="line">--29874ecd-2a56-406a-a2c0-18eff0d3ae85--</span><br></pre></td></tr></table></figure></p>
<h4 id="從-ApiController-Request-取得資料"><a href="#從-ApiController-Request-取得資料" class="headerlink" title="從 ApiController.Request 取得資料"></a>從 ApiController.Request 取得資料</h4><p>這個情境下 <code>ApiController.Request.Content.IsMimeMultipartContent()</code> 會回傳 <code>true</code>, 可用這個方法來作為判斷基準.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">GetMultipartFromHttpRequestMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Debug.WriteLine(<span class="string">"===== Get from HttpRequestMessage (multipart) ====="</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> multi = <span class="keyword">await</span> Request.Content.ReadAsMultipartAsync();</span><br><span class="line">	Debug.WriteLine(<span class="string">"===== Get from file ====="</span>);</span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">var</span> content <span class="keyword">in</span> multi.Contents)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">string</span> key = content.Headers.ContentDisposition.Name;</span><br><span class="line">		<span class="keyword">string</span> <span class="keyword">value</span> = <span class="keyword">string</span>.Empty;</span><br><span class="line">		<span class="keyword">using</span> (Stream s = content.ReadAsStreamAsync().Result)</span><br><span class="line">		<span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(s))</span><br><span class="line">		&#123;</span><br><span class="line">			s.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">			<span class="keyword">value</span> = sr.ReadToEnd();</span><br><span class="line">			Debug.WriteLine(<span class="string">$"key: <span class="subst">&#123;key&#125;</span>, value: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不含-filename"><a href="#不含-filename" class="headerlink" title="不含 filename"></a>不含 filename</h3><p>客戶端呼叫 API 的程式碼約略如下, 差別在於 <code>contnet.Add(...)</code> 沒有帶第三個參數:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent())</span><br><span class="line">&#123;</span><br><span class="line">	content.Add(<span class="keyword">new</span> StringContent(<span class="string">"key1"</span>), <span class="string">"value1"</span>);</span><br><span class="line">	content.Add(<span class="keyword">new</span> StringContent(<span class="string">"key2"</span>), <span class="string">"value2"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> req = <span class="keyword">new</span> HttpClient();</span><br><span class="line">	req.PostAsync(<span class="string">"http://localhost:50640/api/multipart"</span>, content).Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用 postman 模擬的話會是這樣, 差別在不是用檔案上傳:<br><img src="/content/20190826-handle-multipart-formdata-by-webapi/multipart.png">   </p>
<p>而 body 的內容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--9b753acb-2b3a-4214-bfc4-47b25799436f</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Disposition: form-data; name=value1</span><br><span class="line"></span><br><span class="line">key1</span><br><span class="line">--9b753acb-2b3a-4214-bfc4-47b25799436f</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Disposition: form-data; name=value2</span><br><span class="line"></span><br><span class="line">key2</span><br><span class="line">--9b753acb-2b3a-4214-bfc4-47b25799436f--</span><br></pre></td></tr></table></figure></p>
<p>雖然跟上一個例子比起來, 似乎只少了 Content-Disposition 中的 filename 一段, 但這會讓我們在取資料上變得更方便.  </p>
<h4 id="從-ApiController-Request-取得資料-1"><a href="#從-ApiController-Request-取得資料-1" class="headerlink" title="從 ApiController.Request 取得資料"></a>從 ApiController.Request 取得資料</h4><p>在不含 filename 的情境下,  <code>ApiController.Request.Content.IsMimeMultipartContent()</code> 依然會是 <code>true</code>, 所以上一個情境的解法依然適用.  </p>
<h4 id="從-HttpContext-Current-Request-取得資料"><a href="#從-HttpContext-Current-Request-取得資料" class="headerlink" title="從 HttpContext.Current.Request 取得資料"></a>從 HttpContext.Current.Request 取得資料</h4><p>在不含 filename 的情境下, 操作上可以視同一般的 form post 來取得資料, 不用做額外的處理, 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetFormFromHttpRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Debug.WriteLine(<span class="string">"===== Get from HttpRequestMessage (form) ====="</span>);</span><br><span class="line">	<span class="keyword">var</span> formData = HttpContext.Current.Request.Form;</span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">var</span> key <span class="keyword">in</span> formData.AllKeys)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">string</span> <span class="keyword">value</span> = formData[key];</span><br><span class="line">		Debug.WriteLine(<span class="string">$"key: <span class="subst">&#123;key&#125;</span>, value: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有趣的地方是雖然操作上跟一般 form post 一樣, 但是如果試圖透過 <code>ApiController.Request.Content.ReadAsFormDataAsync()</code> 取得資料是會拋出例外, 且<br><code>ApiController.Request.Content.IsFormData()</code> 的回傳值是 <code>false</code>.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>目前因為確定合作廠商使用 <code>multipart/form-data</code> 的情境都不會帶 filename, 所以是視同一般 form post 直接從<code>HttpContext.Current.Request</code> 中取得資料, 省去額外的判斷跟處理.  </p>
<p>但嚴格來說, 不管是不是有 filename 這段, 都應該用 <code>ApiController.Request.Content.ReadAsMultipartAsync()</code> 來處理比較恰當, 目前的做法比較像是因為剛好可以相容又可以省事, 就這樣用了.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/questions/24503961/invalid-httpcontent-instance-provided-it-does-not-have-a-multipart-content/43868741#43868741" target="_blank" rel="noopener">24503961</a><br><a href="https://stackoverflow.com/questions/41713215/how-to-get-string-representation-of-a-multipartformdatacontent" target="_blank" rel="noopener">How to get string representation of a MultipartFormDataContent</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET core 測試專案版本不符]]></title>
      <url>/content/20190622-dotnetcore-testproject-cs1705.html</url>
      <content type="html"><![CDATA[<p>前陣子的新專案用的是 .NET core 2.1, 在加測試專案的時候發現測試專案編譯無法通過, 拋出類似於版本衝突/版本錯誤之類的錯誤 (錯誤碼忘了, 不知道是不是 CS1705), 經過檢查後發現產品專案和測試專案的相關組件版本都一樣, 一時間還真的找不到方向.  </p>
<a id="more"></a>
<p>不過很快的就靠谷歌大神找到了答案, 雖然一般來說這麼容易找到的答案實在不用記, 又遇到就再找就好, 不過這個情境比較特殊, 萬一再遇到沒下好關鍵字說不定就找不到了, 想想還是速記一下好了.  </p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>總之就是手動編輯 csproj 檔, 在 ItemGroup 裡面加上一段引用如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>解決這個問題我自己是完全沒分析什麼, 就完全是剛好找到相關的文章, 而且正好命中問題一下就解決了, 神奇的是, 事後要在家裡重現問題都無法重現, 也不知道是不是特殊條件才會觸發這個問題, 就這樣留下一個謎…</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="http://marcus116.blogspot.com/2019/03/version-conflicts-in-test-project-on-aspnetcore-2.2.html" target="_blank" rel="noopener">[UnitTest] ASP.NET Core 2.2 測試專案中的版本衝突</a><br><a href="https://github.com/dotnet/sdk/issues/2253" target="_blank" rel="noopener">Version conflicts in test project depending on a Microsoft.AspNetCore.App project</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET Core </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在建構子中取得 WebAPI 的 request 內容]]></title>
      <url>/content/20190526-get-request-in-constructor-of-derived-ApiController.html</url>
      <content type="html"><![CDATA[<p>事情是這樣的, 有一天我需要在某個共用的 BaseApiController 中取得 request 中的內容並做一些操作, 所以寫下了像是這樣的內容, 然後 <del>他就死掉了</del> 就出現 <code>NullReferenceException</code> 了.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseApiController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseApiController</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> request = Request;</span><br><span class="line">		<span class="comment">// do someting from request, ex: read headers</span></span><br><span class="line">		<span class="keyword">var</span> myHeader = request.Headers.GetValues(<span class="string">"MyHeader"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="改用-HttpContext-Current-Request"><a href="#改用-HttpContext-Current-Request" class="headerlink" title="改用 HttpContext.Current.Request"></a>改用 HttpContext.Current.Request</h3><p>發生這個問題其實一開始有點驚訝, 畢竟以前在 Action 中操作 <code>ApiController.Request</code> 都非常順利, 接著很快的在網路上查到了<a href="(https://stackoverflow.com/questions/20428305/request-is-always-null-in-web-api">一個相同的提問</a>, 表示改用 <code>HttpContext.Current.Request</code> 就好了, 然後問題就解決了.  </p>
<p>根據討論串的說法, <code>ApiController.Request</code> 不能在建構子中使用, 因為在這個階段他還沒被初始化, 所以必然是 null.</p>
<h3 id="兩者有什麼差別"><a href="#兩者有什麼差別" class="headerlink" title="兩者有什麼差別?"></a>兩者有什麼差別?</h3><p>接著試著了解一下 <code>HttpContext.Current.Request</code> 和 <code>ApiController.Request</code> 之間的差別.  </p>
<p>首先可以發現 <code>ApiController.Request</code> 回傳了一個 HttpRequestMessage 物件, 且這個屬性是可讀寫的, 而 <code>HttpContext.Current.Request</code> 回傳的是 HttpRequest 物件, 但這個屬性是唯讀的, 另外從下面的原始碼可以看到 HttpRequestMessage 是回傳 <code>ControllerContext.Request</code> 且往上可以追朔到 ActionContext, 由此”推測” <code>ApiController.Request</code> 比較適合在 Action 中使用.  </p>
<blockquote>
<p>推測跟框架的生命週期與相關成員的初始化時間有關, 但要驗證的話要去爬 code, 目前沒這個需要就先偷懶一下了, 至於 HttpRequest 和 HttpRequestMessage 的差別在 <a href="https://stackoverflow.com/questions/15718468/httprequest-vs-httprequestmessage-vs-httprequestbase" target="_blank" rel="noopener">HttpRequest vs HttpRequestMessage vs HttpRequestBase</a> 這篇文章有稍微提到, 不過沒講得太深入.  </p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy from https://github.com/aspnet/AspNetWebStack/blob/master/src/System.Web.Http/ApiController.cs</span></span><br><span class="line"><span class="keyword">public</span> HttpRequestMessage Request</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ControllerContext.Request;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> Error.PropertyNull();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		HttpRequestContext contextOnRequest = <span class="keyword">value</span>.GetRequestContext();</span><br><span class="line">		HttpRequestContext contextOnController = RequestContext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (contextOnRequest != <span class="literal">null</span> &amp;&amp; contextOnRequest != contextOnController)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Prevent unit testers from setting conflicting requests contexts.</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(SRResources.RequestContextConflict);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ControllerContext.Request = <span class="keyword">value</span>;</span><br><span class="line">		<span class="keyword">value</span>.SetRequestContext(contextOnController);</span><br><span class="line"></span><br><span class="line">		RequestBackedHttpRequestContext requestBackedContext =</span><br><span class="line">			contextOnController <span class="keyword">as</span> RequestBackedHttpRequestContext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (requestBackedContext != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			requestBackedContext.Request = <span class="keyword">value</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>會碰到這個大概就是對於相似的成員之間的差異與生命週期不了解, 可能要找個時間好好了解一下了. <del>不過不知道這個 <code>//TODO</code> 會拖多久就是</del>.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/questions/20428305/request-is-always-null-in-web-api" target="_blank" rel="noopener">Request is always null in web api?</a><br><a href="https://stackoverflow.com/questions/15718468/httprequest-vs-httprequestmessage-vs-httprequestbase" target="_blank" rel="noopener">HttpRequest vs HttpRequestMessage vs HttpRequestBase</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[RSA 加解密與簽名]]></title>
      <url>/content/20190518-rsa-by-dotnet.html</url>
      <content type="html"><![CDATA[<p>.NET 提供的 RSACryptoServiceProvider 用來做 RSA 加解密與驗簽非常方便, 相關的網路資源也很多, 本來是沒什麼好寫的畢竟隨便 google 一下都有, 但是最近發現不知道為什麼用一次查一次然後忘一次, 想想還是稍微紀錄一下用法方便以後速查好了.  </p>
<a id="more"></a>
<h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><h4 id="使用-XML-格式的公私鑰"><a href="#使用-XML-格式的公私鑰" class="headerlink" title="使用 XML 格式的公私鑰"></a>使用 XML 格式的公私鑰</h4><p>沒什麼特別的, 就是用 RSACryptoServiceProvider 加解密.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RSAEncryptFromXMLKey</span>(<span class="params"><span class="keyword">string</span> publicKey, <span class="keyword">string</span> plaintext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">	rsa.FromXmlString(publicKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> plaintextBytes = Encoding.UTF8.GetBytes(plaintext);</span><br><span class="line">	<span class="keyword">var</span> ciphertextBytes = rsa.Encrypt(plaintextBytes, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">var</span> ciphertext = Convert.ToBase64String(ciphertextBytes);</span><br><span class="line">	<span class="keyword">return</span> ciphertext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RSADecryptFromXMLKey</span>(<span class="params"><span class="keyword">string</span> privateKey, <span class="keyword">string</span> ciphertext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">	rsa.FromXmlString(privateKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ciphertextBytes = Convert.FromBase64String(ciphertext);</span><br><span class="line">	<span class="keyword">var</span> plaintextBytes = rsa.Decrypt(ciphertextBytes, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">var</span> plaintext = Encoding.UTF8.GetString(plaintextBytes);</span><br><span class="line">	<span class="keyword">return</span> plaintext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="載入-pfx-檔"><a href="#載入-pfx-檔" class="headerlink" title="載入 pfx 檔"></a>載入 pfx 檔</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RSAEncryptFromPFX</span>(<span class="params"><span class="keyword">string</span> plaintext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	X509Certificate2 certificate = <span class="keyword">new</span> X509Certificate2(<span class="string">"path/to/certificate.pfx"</span>, <span class="string">"password"</span>);</span><br><span class="line">	<span class="keyword">var</span> rsa = (RSACryptoServiceProvider)certificate.PublicKey.Key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> plaintextBytes = Encoding.UTF8.GetBytes(plaintext);</span><br><span class="line">	<span class="keyword">var</span> ciphertextBytes = rsa.Encrypt(plaintextBytes, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">var</span> ciphertext = Convert.ToBase64String(ciphertextBytes);</span><br><span class="line">	<span class="keyword">return</span> ciphertext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RSADecryptFromPFX</span>(<span class="params"><span class="keyword">string</span> ciphertext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	X509Certificate2 certificate = <span class="keyword">new</span> X509Certificate2(<span class="string">"path/to/certificate.pfx"</span>, <span class="string">"password"</span>);</span><br><span class="line">	<span class="keyword">var</span> rsa = (RSACryptoServiceProvider)certificate.PrivateKey;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ciphertextBytes = Convert.FromBase64String(ciphertext);</span><br><span class="line">	<span class="keyword">var</span> plaintextBytes = rsa.Decrypt(ciphertextBytes, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">var</span> plaintext = Encoding.UTF8.GetString(plaintextBytes);</span><br><span class="line">	<span class="keyword">return</span> plaintext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>註:  </p>
<ol>
<li>方便示範所以把一些參數與物件都寫死在方法中, 實務上該抽參數或是抽離出 X509Certificate2 的操作等都要再考慮</li>
</ol>
</blockquote>
<h3 id="簽名與驗簽"><a href="#簽名與驗簽" class="headerlink" title="簽名與驗簽"></a>簽名與驗簽</h3><h4 id="使用-XML-格式的公私鑰-1"><a href="#使用-XML-格式的公私鑰-1" class="headerlink" title="使用 XML 格式的公私鑰"></a>使用 XML 格式的公私鑰</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RSASignFromXMLKey</span>(<span class="params"><span class="keyword">string</span> privateKey, <span class="keyword">string</span> plaintext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">	rsa.FromXmlString(privateKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> plaintextBytes = Encoding.UTF8.GetBytes(plaintext);</span><br><span class="line">	<span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="keyword">new</span> SHA1CryptoServiceProvider());</span><br><span class="line">	<span class="keyword">var</span> sign = Convert.ToBase64String(signBytes);</span><br><span class="line">	<span class="keyword">return</span> sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">RSAVerifyFromXMLKey</span>(<span class="params"><span class="keyword">string</span> publicKey, <span class="keyword">string</span> sign, <span class="keyword">string</span> data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">	rsa.FromXmlString(publicKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> signBytes = Convert.FromBase64String(sign);</span><br><span class="line">	<span class="keyword">var</span> dataBytes = Encoding.UTF8.GetBytes(data);</span><br><span class="line">	<span class="keyword">bool</span> isValid = rsa.VerifyData(dataBytes, <span class="keyword">new</span> SHA1CryptoServiceProvider(), signBytes);</span><br><span class="line">	<span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這也沒什麼難的, 不過 VerifyData 這個方法第一個參數是明文, 第三個參數是簽名後的密文比較容易弄反.  </p>
<p>另外一個有趣的地方是 VerifyData 的第二個參數和 SignData 的第二個參數型別是 <code>object</code>, 這意味著他可以接受任意型別的輸入, 例如: <code>new SHA1CryptoServiceProvider()</code> 或 <code>&quot;sha1&quot;</code>(不分大小寫的字串), 在使用上我會傾向在封裝 wrapper 時刻意限縮個參數的的型別, 否則呼叫端會很難預期傳入的值是不是正確的, 例如以上例為延伸, 下面的每一行程式碼如果沒經過實測很道運作結果是否一樣(而事實上結果是一樣的).  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="string">"sha1"</span>);</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="string">"SHA1"</span>);</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="string">"SHa1"</span>);</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, SHA1.Create());</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="keyword">new</span> SHA1Managed());</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="keyword">new</span> SHA1CryptoServiceProvider());</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="keyword">new</span> SHA1Cng());</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="keyword">typeof</span>(SHA1));</span><br><span class="line"><span class="keyword">var</span> signBytes = rsa.SignData(plaintextBytes, <span class="keyword">typeof</span>(SHA1Managed));</span><br><span class="line"><span class="comment">// etc...</span></span><br></pre></td></tr></table></figure>
<h4 id="載入-pfx-檔-1"><a href="#載入-pfx-檔-1" class="headerlink" title="載入 pfx 檔"></a>載入 pfx 檔</h4><p>用私鑰簽名時載入 pfx 擋的方式跟加解密時一樣, 簽名與驗簽的相關方法都跟上例一樣, 就不重複貼程式碼了.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>目前只知道 XML 格式的公私鑰和 PFX 格式的憑證擋在 .NET 下是最方便操作的, 如果還要讀取自其他格式的檔案或公私鑰內容(例如 PEM), 大多要靠其他套件才比較好做, 例如: <a href="https://github.com/bcgit/bc-csharp" target="_blank" rel="noopener">Bouncy Castle</a>.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3>]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 語言特性更新 - C# 6]]></title>
      <url>/content/20190322-csharp-language-specification-6.html</url>
      <content type="html"><![CDATA[<p>C# 的版本最近幾年更新的越來越頻繁, 雖然官方有提供<a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history" target="_blank" rel="noopener">版本歷程</a>以及各版本的新特性, 但是還是想整理起來, 在官方提供的語言特性說明外多一點思考並紀錄自己使用上的想法.  </p>
<p>本篇是 C# 6.0</p>
<a id="more"></a>
<h3 id="C-6"><a href="#C-6" class="headerlink" title="C# 6"></a>C# 6</h3><h4 id="唯讀屬性-Read-only-auto-properties"><a href="#唯讀屬性-Read-only-auto-properties" class="headerlink" title="唯讀屬性 (Read-only auto-properties)"></a>唯讀屬性 (Read-only auto-properties)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#read-only-auto-properties" target="_blank" rel="noopener">Read-only auto-properties</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>雖然舊版可以用 <code>public string Name { get; private set; }</code> 最大限度的限縮寫入權, 但仍然不是唯讀(只允許在建構子中改變屬性值), 硬要拆成私有唯讀欄位 (<code>private readonly fieldName</code>) 和 getter 方法的組合又失去了自動實作屬性的優點, 難免可惜.  </p>
<p>這個特性讓我們能更精細的控制屬性的存取範圍, 用在需要嚴謹的控制屬性的存取範圍的時候很好用.  </p>
<h4 id="屬性初始化器-Auto-property-initializers"><a href="#屬性初始化器-Auto-property-initializers" class="headerlink" title="屬性初始化器 (Auto-property initializers)"></a>屬性初始化器 (Auto-property initializers)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#auto-property-initializers" target="_blank" rel="noopener">Auto-property initializers</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Ron"</span>;</span><br></pre></td></tr></table></figure>
<p>極相似於舊版在建構子中初始化屬性的做法, 舊版做法在建構子中初始化屬性的做法在屬性很多時, 排版上會影響可讀性.<br>這個特性能讓屬性初始化更為簡潔, 更容易避免舊的做法的潛在問題.  </p>
<blockquote>
<p>會說”極相似”從建構子初始化屬性代表還是有一點差異的  </p>
<ul>
<li>舊的做法: 從建構子初始化屬性其實是預設呼叫 setter 方法, 如果沒有 setter 方法則直接操作自動產生的欄位 (但舊版不支援唯讀屬性)</li>
<li>新特性: 直接操作自動產生的欄位, 不管有沒有 setter 方法</li>
</ul>
<p>以上結論是透過 Msiler 套件產生 IL 碼後觀察的結果</p>
</blockquote>
<h4 id="具有運算式主體的函式成員-Expression-bodied-function-members"><a href="#具有運算式主體的函式成員-Expression-bodied-function-members" class="headerlink" title="具有運算式主體的函式成員 (Expression-bodied function members)"></a>具有運算式主體的函式成員 (Expression-bodied function members)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#expression-bodied-function-members" target="_blank" rel="noopener">Expression-bodied function members</a>  </p>
<p>讓只有單一運算式的方法或唯讀屬性可以用較短的程式碼完成.  </p>
<p>這個特性我平常其實不太用, 因為下面這三行的長相太相似了, 在閱讀上比較容易造成混淆, 且如果不小心用錯雖然不會造成編譯錯誤, 但含意卻會完全不同, 而增加的方便性給我的感受不是很強烈.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> FirstName =&gt; <span class="string">"Ron"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> _lastName = <span class="string">"Sun"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetFullName</span>(<span class="params"></span>) </span>=&gt; <span class="string">$"<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;_lastName&#125;</span>"</span>;</span><br></pre></td></tr></table></figure></p>
<p>不小心手滑用錯的範例如下, 看起來很詭異, 但依然能正常運作:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "=&gt;" 變成 "=" 從唯讀屬性變成欄位</span></span><br><span class="line"><span class="comment">// FirstName 現在看起來像公開欄位, 是私有欄位寫錯變公開了?  </span></span><br><span class="line"><span class="comment">// 還是應該是唯讀屬性, 只是不小心少了一個 "&gt;"?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> FirstName = <span class="string">"Ron"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "=" 變成 "=&gt;" 從欄位變成唯讀屬性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> _lastName =&gt; <span class="string">"Sun"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 少了 "()" 從方法變成唯讀屬性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> GetFullName =&gt; <span class="string">$"<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;_lastName&#125;</span>"</span>;</span><br></pre></td></tr></table></figure></p>
<p>其實如果專案有良好的程式碼規範, 從命名基本上就可以分辨出這個成員應該要是欄位, 屬性還是方法, 加上工程師如果夠謹慎, 上面的失誤應該不會發生, 但假設專案沒有良好的規範又加上手滑打錯的狀況, 後面維護的人就可能會很混亂.</p>
<p>這不是說這個特性不好, 如果對團隊成員的嚴謹度與基礎有信心, 用這個特性也是很不錯的.  </p>
<h4 id="using-static"><a href="#using-static" class="headerlink" title="using static"></a>using static</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#using-static" target="_blank" rel="noopener">using static</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> ConsoleApp1.Person;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nestedPerson = <span class="keyword">new</span> NestedPerson();</span><br><span class="line">        <span class="keyword">var</span> fullName = GetFullName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetFullName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Ron Sun"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NestedPerson</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Ron"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上面的例子來說, 舊的做法如果要初始化 <code>NestedModel</code> 要寫成 <code>new Model.NestedModel</code>, 呼叫靜態方法 <code>GetFullName()</code> 要寫成 <code>Model.GetFullName()</code></p>
<p>這個特性我比較不喜歡, 主要是巢狀類別跟靜態方法這樣使用或呼叫的話, 外觀上跟一般類別或該類別內的方法呼叫一樣, 閱讀時如果沒有進去類別或方法中看, 難以分辨他究竟是不是該類別內部的方法.  </p>
<h4 id="Null-條件運算子-Null-conditional-operators"><a href="#Null-條件運算子-Null-conditional-operators" class="headerlink" title="Null 條件運算子 (Null-conditional operators)"></a>Null 條件運算子 (Null-conditional operators)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#null-conditional-operators" target="_blank" rel="noopener">Null-conditional operators</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> name = person?.Name;</span><br><span class="line"><span class="keyword">string</span> nameWithDefault = person?.Name ?? <span class="string">"John"</span>;</span><br><span class="line"><span class="keyword">var</span> company = person?.Team?.Company;</span><br><span class="line"><span class="keyword">int</span>? age = dictionary?[<span class="string">"Ron"</span>];</span><br><span class="line"><span class="keyword">int</span> ageWithDefault = dictionary?[<span class="string">"Ron"</span>] ?? <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>用來省下空值判斷, 要取得物件中的屬性值的時候很好用, 也可以用在需要存取陣列或是索引子(indexer) 的情境.  </p>
<p><strong>這個特性神好用, 搭配 <code>??</code> 更神</strong>, 可以縮短非常多空值判斷的程式碼, 尤其是像 <code>model.Nested.Property</code> 這種巢狀的存取更明顯, 就上面的範例來說, 舊的做法就明顯冗長, 如下面比較:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string name = person?.Name;</span></span><br><span class="line"><span class="keyword">string</span> name = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(person != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    name = person.Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string nameWithDefault = person?.Name ?? "John";</span></span><br><span class="line"><span class="keyword">string</span> nameWithDefault = <span class="string">"John"</span>;</span><br><span class="line"><span class="keyword">if</span>(person != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nameWithDefault = person.Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Company company = person?.Team?.Company;</span></span><br><span class="line">Company company = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(person != <span class="literal">null</span> &amp;&amp; person.Team != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    company = person.Team.Company;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int? age = dictionary?["Ron"];</span></span><br><span class="line"><span class="comment">// int ageWithDefault = dictionary?["Ron"] ?? -1;</span></span><br><span class="line"><span class="comment">// ...依此類推</span></span><br></pre></td></tr></table></figure>
<p>舊的做法的範例還是為了避免巢狀 if-else 而簡化過的, 如果是直覺式的 if-else 一層層科下去, 差異就更明顯了.  </p>
<h4 id="字串插補-String-interpolation"><a href="#字串插補-String-interpolation" class="headerlink" title="字串插補 (String interpolation)"></a>字串插補 (String interpolation)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#string-interpolation" target="_blank" rel="noopener">String interpolation</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> FullName =&gt; <span class="string">$"<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>神好用, 真心不騙</strong>, 這個範例看起來可能沒有感覺, 會覺得用 <code>string.Format()</code> 做也不錯啊, 但情境夠複雜的話無疑是海放最古典的字串相加, 也避免了 <code>string.Format()</code> 遇到大量參數的時候容易排錯順序的問題, 如果有用過組過 SOAP 用的 XML 內容的話, 就能明顯感受到它的威力了.  </p>
<p>另外, 搭配 <code>@</code> 使用, 效果更好.  </p>
<p>這個特性還有有很多進階用法, 官方資源如下:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/intro-to-csharp/interpolated-strings" target="_blank" rel="noopener">Use string interpolation to construct formatted strings</a>  </li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated" target="_blank" rel="noopener">$ - string interpolation (C# Reference)</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/string-interpolation#how-to-specify-a-format-string-for-an-interpolated-expression" target="_blank" rel="noopener">String interpolation in C#</a></li>
</ul>
<h4 id="例外狀況篩選條件-Exception-filters"><a href="#例外狀況篩選條件-Exception-filters" class="headerlink" title="例外狀況篩選條件 (Exception filters)"></a>例外狀況篩選條件 (Exception filters)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#exception-filters" target="_blank" rel="noopener">Exception filters</a>  </p>
<p>這個特性還沒機會用到, 不過目前看起來有兩個好處:  </p>
<ul>
<li>讓 Catch 區塊的情境更精細, 減少 Catch 區塊內的條件判斷.  </li>
<li>攔截例外前多了一個機制可以判斷真的要攔截這個例外或是讓他繼續往外拋, 可以<strong>避免掉有條件重拋例外所造成的 StackTrace 被改變的問題</strong>, 重拋例外產生的問題之前寫過一篇 <a href="/content/20180131-correctly-re-throw-exception.html" title="正確重拋例外">正確重拋例外</a>.  </li>
</ul>
<h4 id="nameof-運算式-The-nameof-expression"><a href="#nameof-運算式-The-nameof-expression" class="headerlink" title="nameof 運算式 (The nameof expression)"></a>nameof 運算式 (The nameof expression)</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#the-nameof-expression" target="_blank" rel="noopener">The nameof expression</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output: Method</span></span><br><span class="line">Console.WriteLine(<span class="keyword">nameof</span>(Class1.Method));</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: Property</span></span><br><span class="line">Console.WriteLine(<span class="keyword">nameof</span>(Class1.Property));</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: Property</span></span><br><span class="line">Console.WriteLine(<span class="keyword">nameof</span>(Class1.NestedClass.Property));</span><br></pre></td></tr></table></figure>
<p>好東西, 這個特性比較偏可維護性的優化, 很在意可維護性的工程師會很愛用.  </p>
<p>需要在字串中放型別名稱, 方法名稱, 欄位名稱, 屬性名稱等等的情境時, 舊方法都是直接寫死字串, 這樣會導致重新命名的時候 visual studio 會將這些字串忽略掉, 老舊專案的 log 中就很常出現與實際不吻合的方法名稱.  </p>
<p>另外一個情境是反射, 如果專案中有用反射存取特定成員或呼叫方法, 在重新命名的時候往往會被忽略, 偏偏這種情境只能等到執行階段才會被發現, 導致重新命名風險提高, 但使用 <code>nameof</code> 之後, 可以避免這類問題, 重新命名時也可以更安心.  </p>
<h4 id="Catch-和-Finally-區塊中的-Await"><a href="#Catch-和-Finally-區塊中的-Await" class="headerlink" title="Catch 和 Finally 區塊中的 Await"></a>Catch 和 Finally 區塊中的 Await</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#await-in-catch-and-finally-blocks" target="_blank" rel="noopener">Await in Catch and Finally blocks</a>  </p>
<h4 id="Initialize-associative-collections-using-indexers"><a href="#Initialize-associative-collections-using-indexers" class="headerlink" title="Initialize associative collections using indexers"></a>Initialize associative collections using indexers</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#initialize-associative-collections-using-indexers" target="_blank" rel="noopener">Initialize associative collections using indexers</a>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta"><span class="meta-string">"key1"</span></span>] = <span class="string">"value1"</span>,</span><br><span class="line">    [<span class="meta"><span class="meta-string">"key2"</span></span>] = <span class="string">"value2"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>舊的寫法是如下面這樣.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">"key1"</span>, <span class="string">"value1"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"key2"</span>, <span class="string">"value2"</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>恩…乍看之下就是用換個初始化的語法, 但內部運作卻是不一樣的, 讓我們繼續看下去…  </p>
<p>透過工具看了一下編譯出來的 IL 碼發現兩者實際的運作並不同, 舊的做法呼叫的是 <code>Add(System.String,System.String)</code> 方法, 而 C# 6 的語法呼叫的是 <code>set_Item(System.String,System.String)</code>, 而這樣的差別會在某些情境下使得運作結果不同.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// var dic = new Dictionary&lt;string, string&gt;()</span><br><span class="line">// &#123;</span><br><span class="line">// &#123; &quot;key1&quot;, &quot;value1&quot; &#125;</span><br><span class="line">// &#125;;</span><br><span class="line">IL_002B newobj    System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::.ctor()</span><br><span class="line">IL_0030 dup</span><br><span class="line">IL_0031 ldstr     &quot;key1&quot;</span><br><span class="line">IL_0036 ldstr     &quot;value1&quot;</span><br><span class="line">IL_003B callvirt  System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::Add(System.String,System.String)</span><br><span class="line">IL_0040 nop</span><br><span class="line">IL_0041 stloc.0</span><br><span class="line">// var dic2 = new Dictionary&lt;string, string&gt;()</span><br><span class="line">// &#123;</span><br><span class="line">// [&quot;key1&quot;] = &quot;value1&quot;</span><br><span class="line">// &#125;;</span><br><span class="line">IL_0042 newobj    System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::.ctor()</span><br><span class="line">IL_0047 dup</span><br><span class="line">IL_0048 ldstr     &quot;key1&quot;</span><br><span class="line">IL_004D ldstr     &quot;value1&quot;</span><br><span class="line">IL_0052 callvirt  System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::set_Item(System.String,System.String)</span><br><span class="line">IL_0057 nop</span><br><span class="line">IL_0058 stloc.1</span><br></pre></td></tr></table></figure></p>
<p>根據官方說明, 新的語法是個 “Index Initializers”, 搭配 <a href="http://www.informit.com/articles/article.aspx?p=2424333" target="_blank" rel="noopener">New Ways to Initialize Collections in C# 6</a> 這篇大神文章中的描述:</p>
<blockquote>
<p>There is one caution. The new initializer syntax calls the indexer method to add items to the collection. That same indexer method replaces items as well as adding items.  </p>
</blockquote>
<p>可以發現新的寫法由於是直接操作 indexer, 所以<strong>當索引 (key) 重複的時候會直接將值覆蓋, 不同於舊版做法的拋出例外</strong>, 可以由下面兩段程式碼來比較兩者差異<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throw an exception because of duplicate key</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">"k"</span>, <span class="string">"v1"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"k"</span>, <span class="string">"v2"</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(dic[<span class="string">"k"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dic2 = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta"><span class="meta-string">"k"</span></span>] = <span class="string">"v1"</span>,</span><br><span class="line">    [<span class="meta"><span class="meta-string">"k"</span></span>] = <span class="string">"v2"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// the value should be "v2" because the second value of key "k" replace first one</span></span><br><span class="line">Console.WriteLine(dic2[<span class="string">"k"</span>]);</span><br></pre></td></tr></table></figure></p>
<h4 id="Extension-Add-methods-in-collection-initializers"><a href="#Extension-Add-methods-in-collection-initializers" class="headerlink" title="Extension Add methods in collection initializers"></a>Extension Add methods in collection initializers</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#extension-add-methods-in-collection-initializers" target="_blank" rel="noopener">Extension Add methods in collection initializers</a>  </p>
<p>這個又需要<a href="http://www.informit.com/articles/article.aspx?p=2424333" target="_blank" rel="noopener">大神文章</a>救援了.  </p>
<p>總之就是讓下方語法預設呼叫另外寫的擴充方法 <code>Add</code> 使得初始化能在語意上更為順暢.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCollection = <span class="keyword">new</span> MyStringCollection()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Ron"</span>,</span><br><span class="line">    <span class="string">"Sun"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Improved-overload-resolution"><a href="#Improved-overload-resolution" class="headerlink" title="Improved overload resolution"></a>Improved overload resolution</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#improved-overload-resolution" target="_blank" rel="noopener">Improved overload resolution</a>  </p>
<h4 id="Deterministic-compiler-output"><a href="#Deterministic-compiler-output" class="headerlink" title="Deterministic compiler output"></a>Deterministic compiler output</h4><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#deterministic-compiler-output" target="_blank" rel="noopener">Deterministic compiler output</a></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>本來以為對 C# 特性已經算熟了, 沒想到還是有不少平常沒用到就以為他不存或是一直有錯誤理解的特性, 看來要找個時間一個一個仔細看看了.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="http://www.informit.com/articles/article.aspx?p=2424333" target="_blank" rel="noopener">New Ways to Initialize Collections in C# 6</a><br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6" target="_blank" rel="noopener">What’s New in C# 6</a></p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Web API 回傳資料的方式]]></title>
      <url>/content/20190317-webapi-response-data-format.html</url>
      <content type="html"><![CDATA[<p>這篇是要稍微記一下 Web API 回傳資料的幾種方式與格式, 會想要記這一篇是因為以前碰過的 Web API 專案都有統一的回傳 (response) 格式, 但是最近碰到一些專案的 Web API 在回傳資料時是沒有規範的, 例如直接就 <code>return true</code>, 所以就稍微整理一下回傳資料的幾種方式與優缺點.  </p>
<a id="more"></a>
<h3 id="直接回傳物件"><a href="#直接回傳物件" class="headerlink" title="直接回傳物件"></a>直接回傳物件</h3><p>這個就是上面說的, 直接像 <code>return anyObject</code> 這樣回傳, 如下面的程式碼</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DemoModel <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">new</span> DemoModel()</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"Ron"</span>,</span><br><span class="line">        Age = <span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta"><span class="meta-string">"Name"</span></span>] = <span class="string">"Ron"</span>,</span><br><span class="line">        [<span class="meta"><span class="meta-string">"Age"</span></span>] = <span class="string">"18"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="優缺點"><a href="#優缺點" class="headerlink" title="優缺點"></a>優缺點</h4><p><strong>優點</strong>  </p>
<ul>
<li>簡單直覺又方便</li>
</ul>
<p><strong>缺點</strong></p>
<ul>
<li>凌亂不統一, 回傳的資料可能出現原生型別, model 或是其他各種型別</li>
<li>只回傳資料, 沒有任何狀態類的欄位與 http status, 當 client 端收到空物件或例外時難以判斷問題  </li>
<li>後期需要加狀態時很麻煩, 例如每支 API 各自加狀態欄位容易亂, 如果要抽共用還要考慮資料的結構或階層被改變對客戶端的影響</li>
</ul>
<h4 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h4><p>這種做法適合用在</p>
<ul>
<li>簡單的小專案, 複雜度小就沒太大影響</li>
<li>Web API 只提供內部使用, client 跟 API 是同一組人開發的, 狀態類欄位的必要性不大</li>
</ul>
<h3 id="套用共用回傳物件與狀態"><a href="#套用共用回傳物件與狀態" class="headerlink" title="套用共用回傳物件與狀態"></a>套用共用回傳物件與狀態</h3><p>同時考慮回傳資料, http status 與例外內容三種情況, 如下</p>
<blockquote>
<p><code>IHttpActionResult</code> 是 Web API 2 的方式</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ResponseModel&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"0000"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Success"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Web API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponseMessage <span class="title">Get</span>(<span class="params"><span class="keyword">bool</span> isError</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> responseModel = <span class="keyword">new</span> ResponseModel&lt;DemoModel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isError)</span><br><span class="line">    &#123;</span><br><span class="line">        responseModel.Code = <span class="string">"0001"</span>;</span><br><span class="line">        responseModel.Message = <span class="string">"Prameter 'isError' should be false."</span>;</span><br><span class="line">        <span class="keyword">var</span> response = Request.CreateResponse(HttpStatusCode.BadRequest, responseModel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseModel.Data = <span class="keyword">new</span> DemoModel()</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"Ron"</span>,</span><br><span class="line">        Age = <span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request.CreateResponse(HttpStatusCode.OK, responseModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Web API 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IHttpActionResult <span class="title">Get</span>(<span class="params"><span class="keyword">bool</span> isError</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> responseModel = <span class="keyword">new</span> ResponseModel&lt;DemoModel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isError)</span><br><span class="line">    &#123;</span><br><span class="line">        responseModel.Code = <span class="string">"0001"</span>;</span><br><span class="line">        responseModel.Message = <span class="string">"Prameter 'isError' should be false."</span>;</span><br><span class="line">        <span class="keyword">return</span> Content(HttpStatusCode.BadRequest, responseModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseModel.Data = <span class="keyword">new</span> DemoModel()</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"Ron"</span>,</span><br><span class="line">        Age = <span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(responseModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="特別的-HttpResponseException"><a href="#特別的-HttpResponseException" class="headerlink" title="特別的 HttpResponseException"></a>特別的 HttpResponseException</h4><p>上面例子中, <code>HttpResponseException</code> 是一個很特別的例外, 這個例外不會被 <code>ExceptionFilterAttribute</code>, <code>ExceptionHandler</code> 或是 <code>ExceptionLogger</code> 所攔截, 所以在 service 層中使用 <code>HttpResponseException</code> 是一個很好的選項, 既能直接返回 http status 和內容, 又不會被全域例外處理機制攔截, 像是這樣 <code>throw new HttpResponseException(response)</code>.  </p>
<p>順帶一提, <code>ExceptionHandler</code> 和 <code>ExceptionLogger</code> 是實測的時候才發現會忽略 <code>HttpResponseException</code>, <a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/error-handling/exception-handling" target="_blank" rel="noopener">官方文件只提到 <code>ActionFilterAttribute</code> 的部分</a>, 節錄如下:  </p>
<blockquote>
<p>An exception filter is executed when a controller method throws any unhandled exception that is not an HttpResponseException exception. The HttpResponseException type is a special case, because it is designed specifically for returning an HTTP response.</p>
</blockquote>
<h4 id="優缺點-1"><a href="#優缺點-1" class="headerlink" title="優缺點"></a>優缺點</h4><p><strong>優點</strong></p>
<ul>
<li>明確回傳 http status, 對 client 端來說遇到問題容易釐清方向</li>
<li>細部狀態碼 (Code) 與訊息 (Message) 方便 client 端對接與使用</li>
</ul>
<p><strong>缺點</strong></p>
<ul>
<li>比較麻煩, 需要花時間了解並選擇適合的 http status, 也需要定義細部狀態碼 (Code) 與訊息 (Message)</li>
</ul>
<h4 id="共用回傳物件的幾種設計"><a href="#共用回傳物件的幾種設計" class="headerlink" title="共用回傳物件的幾種設計"></a>共用回傳物件的幾種設計</h4><p>回傳物件的共用部分要怎麼設計也是有幾種方式</p>
<p><strong>泛型版</strong><br>包一層 <code>ResponseModel&lt;T&gt;</code>, 可以直接套用到所有需要回傳物件的 API 上, 但是因為多包了一層, 序列化的結果會多一層, 如果套用在舊的 API 上會使得回傳資料的階層被改變, 會影響所有 client 端.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ResponseModel&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"0000"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Success"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不用泛型</strong><br>沒有泛型, <code>ResponseModel</code> 讓其他要回傳的 model 繼承或包含, 如果套用在舊的 API 上, 在序列化後只會增加欄位, 不會改變舊有欄位的階層, 對現存 API 的擴展很友善, 但是相對於泛型版比較不好用, 因為即使只是要回傳一個基本型別(bool / string) 也需要建立 model.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResponseModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"0000"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回傳物件型別有兩種使用 <code>ResponseModel</code> 的方法, 繼承或包含, 序列化結果不同, 視情境或團隊共識使用.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 繼承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoModel</span> : <span class="title">ResponseModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResponseModel Error &#123;<span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用時機-1"><a href="#使用時機-1" class="headerlink" title="使用時機"></a>使用時機</h4><p>這種做法適合用在</p>
<ul>
<li>邏輯複雜或是有各種驗證狀態與結果的 API</li>
<li>需要對外開放的 API (跨部門 / 公開 API)</li>
</ul>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>雖然稍微整理一下幾種做法與適用情境, 不過實際運用不太會照抄, 還是要視情況做細部的調整, 就跟設計模式在使用的時候常常需要配合專案需求變形過一樣.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/questions/10732644/best-practice-to-return-errors-in-asp-net-web-api" target="_blank" rel="noopener">Best practice to return errors in ASP.NET Web API</a><br><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/error-handling/exception-handling" target="_blank" rel="noopener">Exception Handling in ASP.NET Web API</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Web API 中的全域錯誤處理]]></title>
      <url>/content/20190308-global-exception-handle-in-webapi.html</url>
      <content type="html"><![CDATA[<p>在 Web API 中, 例外處理是一定會遇到的問題, 以前常常見到一些專案為了怕出現 unhandled exception 就地毯式的將所有方法都加上 try-catch, 但是這樣使用 try-catch 會有很大的副作用, 一來無差別的吃掉所有例外會導致程式不易除錯, 二來到處散布的 try-catch 和相關的 log 在維護上的成本也很高, 尤其是大型專案更是明顯, 第三也會使得商務邏輯跟這些例外處理混雜在一起 (try-catch 不是不能用, 但是他是有使用時機的).  </p>
<p>而 ASP.NET Web API 2 中其實提供了很多種全域的例外處理方式, 例如: <code>ExceptionFilterAttribute</code>, <code>ExceptionLogger</code>, <code>ExceptionHandler</code>, 能將攔截未處理的例外的任務抽離出來, 讓我們開發時能更專注在重要的商務邏輯上, 這篇主要紀錄一下這三種全域例外處理的方式與差別.  </p>
<a id="more"></a>
<h3 id="ExceptionFilterAttribute"><a href="#ExceptionFilterAttribute" class="headerlink" title="ExceptionFilterAttribute"></a>ExceptionFilterAttribute</h3><p> 在 <a href="/content/20180923-filters-of-webapi2.html" title="WebApi 2 中的 FilterAttribute 介紹與應用">WebApi 2 中的 FilterAttribute 介紹與應用</a> 這篇文章中已經有提到 FilterAttribute 的用法, 但是 <code>ExceptionFilterAttribute</code> 他在整個 <a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf" target="_blank" rel="noopener">Web API 的生命週期</a>中是比較後面的, 所以某些階段所引發的例外他無法捕捉到, <a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/error-handling/web-api-global-error-handling" target="_blank" rel="noopener">官方也明確指出了這個特性</a>, 節錄如下:</p>
<blockquote>
<p>Some unhandled exceptions can be processed via exception filters, but there are<br>a number of cases that <a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/error-handling/exception-handling" target="_blank" rel="noopener">exception filters</a> can’t handle. For example:</p>
<ol>
<li>Exceptions thrown from controller constructors.</li>
<li>Exceptions thrown from message handlers.</li>
<li>Exceptions thrown during routing.</li>
<li>Exceptions thrown during response content serialization.</li>
<li>We want to provide a simple, consistent way to log and handle (where possible)<br>these exceptions.</li>
</ol>
</blockquote>
<p><code>ExceptionFilterAttribute</code> 是個不錯的選項, 但受限於生命週期, 所以攔截的範圍沒那麼廣.  </p>
<h3 id="ExceptionLogger-ExceptionHandler"><a href="#ExceptionLogger-ExceptionHandler" class="headerlink" title="ExceptionLogger / ExceptionHandler"></a>ExceptionLogger / ExceptionHandler</h3><p><code>ExceptionLogger</code> 和 <code>ExceptionHandler</code> 能攔截 <code>ExceptionFilterAttribute</code> 所攔截不到的例外, 下面分別是 <code>ExceptionLogger</code> 和 <code>ExceptionHandler</code> 的實作方式.   </p>
<h4 id="實作方式"><a href="#實作方式" class="headerlink" title="實作方式"></a>實作方式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoExceptionHandler</span> : <span class="title">ExceptionHandler</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ExceptionHandlerContext context</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Debug.WriteLine(<span class="string">"======== DemoExceptionHandler ======="</span>);</span><br><span class="line"></span><br><span class="line">		context.Result = <span class="keyword">new</span> InternalServerErrorResult(context.Request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoExceptionLogger</span> : <span class="title">ExceptionLogger</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params">ExceptionLoggerContext context</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Debug.WriteLine(<span class="string">"======== DemoExceptionLogger ======="</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實作後要在 WebApiConfig.cs 中註冊.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WebApiConfig</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">HttpConfiguration config</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// skip...</span></span><br><span class="line"></span><br><span class="line">		config.Services.Replace(<span class="keyword">typeof</span>(IExceptionHandler), <span class="keyword">new</span> DemoExceptionHandler()</span><br><span class="line">		config.Services.Add(<span class="keyword">typeof</span>(IExceptionLogger), <span class="keyword">new</span> DemoExceptionLogger()););</span><br><span class="line"></span><br><span class="line">		<span class="comment">// skip...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外有幾個要注意的點:</p>
<ul>
<li><code>ExceptionHandler</code> 只能有一個, 所以呼叫 <code>config.Services.Replace()</code> </li>
<li><code>ExceptionLogger</code> 可以有多個, 所以呼叫 <code>config.Services.Add()</code>, 存在多個 <code>ExceptionLogger</code> 時, 先加入的先執行  </li>
<li><code>ExceptionLogger</code> 會比 <code>ExceptionHandler</code> 先執行</li>
<li><code>ExceptionLogger</code> 也可以呼叫 <code>config.Services.Replace()</code>, 不管之前加了幾個 <code>ExceptionLogger</code>, <code>config.Services.Replace()</code> 會將全部都取代成一個, 所以他不是換掉某一個而已 </li>
</ul>
<h4 id="差異"><a href="#差異" class="headerlink" title="差異"></a>差異</h4><p><code>ExceptionLogger</code> 是用於紀錄攔截到的例外, <code>ExceptionHandler</code> 是用於攔截到錯誤後的處理, 所以 <code>ExceptionHandlerContext</code> 中多了一個 <code>public IHttpActionResult Result { get; set; }</code> 屬性, 讓我們可以決定攔截到錯誤後要回傳什麼給客戶端, 這在上面程式碼中也可以看出差異.  </p>
<p>如果同時要紀錄攔截到的錯誤並回傳特定內容給客戶端, 目前我是只用 <code>ExceptionHandler</code> 處理, 沒有同時實作 <code>ExceptionLogger</code> 和 <code>ExceptionHandler</code>.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>以前都只用 <code>ExceptionFilterAttribute</code> 來攔截錯誤, 也沒有特別去找其他做法, 剛好跟別人聊天時有提到全域例外處理跟生命週期的話題才被提醒有這個差別, 意外賺到一個之前都不知道的好東西.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/error-handling/web-api-global-error-handling" target="_blank" rel="noopener">Global Error Handling in ASP.NET Web API 2</a><br><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/error-handling/exception-handling" target="_blank" rel="noopener">Exception Handling in ASP.NET Web API</a>  </p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[整合 DocFx 和 Visual Studio 並佈署上 GitHub Pages]]></title>
      <url>/content/20190124-docfx-with-visual-studio-on-github-pages.html</url>
      <content type="html"><![CDATA[<p>DocFx 是一個很方便的專案文件製作工具, 能將 <a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/xmldoc/xml-documentation-comments" target="_blank" rel="noopener">XML 文件註解</a>轉換成靜態網頁, 也可以轉化其他另外寫的 Markdown 格式的文件, 這篇主要的目的是紀錄如何將 DocFx 與 Visual Studio 整合, 在編譯後產出專案文件並佈署到 GitHub Pages.  </p>
<p>順便提一下, 適用情境是在 visual stuiod 上開發 .NET 專案, 並且希望能統一管理, 其他情境不一定適合這樣整合.  </p>
<a id="more"></a>
<h3 id="如何建立"><a href="#如何建立" class="headerlink" title="如何建立"></a>如何建立</h3><p><strong>建立工具專案</strong><br>建一個獨立的工具專案用來放 DocFx 需要的套件, 刻意跟產品專案分開的目的是希望文件建立工具與產品程式碼不要混在同一個專案, 另外這個工具專案不含程式碼但要是可以在 visual studio 中編譯的, 所以選用 Class Library.  </p>
<p>專案結構與 Demo 程式碼如下圖 (TryDocFx.DocFx 是工具專案, 而 TryDocFx.ClassLib 是產品專案):<br> <img src="/content/20190124-docfx-with-visual-studio-on-github-pages/docfx-projects.png">  </p>
<p>由於目標是能簡單佈署文件到 GitHub Pages 上, 所以這邊是<a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="noopener">用 docs 資料夾來做為 GitHub Pages 的根目錄</a>, 而不是 gh-pages 分支, 也因此資料夾結構是如下面所示: </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TryDocFx</span><br><span class="line">    |---- docs</span><br><span class="line">    |---- src</span><br><span class="line">           |---- TryDocFx.ClassLib</span><br><span class="line">           |---- TryDocFx.DocFx</span><br></pre></td></tr></table></figure>
<p><strong>安裝 docfx.console</strong><br>從 Nuget 中找到 docfx.console 並安裝在上一步建立好的工具專案 (TryDocFx.DocFx) 中, 安裝完後, 會自動在工具專案中建立必要的檔案, 如下圖:<br> <img src="/content/20190124-docfx-with-visual-studio-on-github-pages/docfx-installed-content.png">  </p>
<p><strong>修改設定</strong><br>設定檔是 docfx.json, <a href="https://dotnet.github.io/docfx/tutorial/docfx.exe_user_manual.html#3-docfxjson-format" target="_blank" rel="noopener">官方文件</a>有提供這個設定檔的說明, 以本例來說需要修改幾個地方.  </p>
<ol>
<li>因為產品程式碼不在目前專案中, 所以需要需要指定產品程式碼來源: <code>&quot;src&quot;: &quot;../TryDocFx.ClassLib&quot;</code>.  </li>
<li>套件預設會把靜態網頁放在目前專案的 _site 資料夾下, 因為我們要佈署到 GitHub Pages 上, 所以需要修改輸出路徑: <code>&quot;dest&quot;: &quot;../../docs&quot;</code>.  </li>
<li>exclude 的部分, 由於本例輸出路徑和工具專案是分開的, 所以可以從 exclude 設定中將 <code>&quot;_site/**&quot;</code> 拿掉. </li>
</ol>
<blockquote>
<p>其實整個設定檔應該可以更簡潔, 例如說在本文的情境中 exclude 節點可能是可以移除的, 不過細節要一一研究太花時間了, 如果之後工作上有用到再來詳細了解設定檔的完整內容吧.  </p>
</blockquote>
<p>修改後範例如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"metadata"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"files"</span>: [</span><br><span class="line">            <span class="string">"*.csproj"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"cwd"</span>: <span class="string">"."</span>,</span><br><span class="line">          <span class="attr">"exclude"</span>: [</span><br><span class="line">            <span class="string">"**/obj/**"</span>,</span><br><span class="line">            <span class="string">"**/bin/**"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"src"</span>: <span class="string">"../TryDocFx.ClassLib"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"dest"</span>: <span class="string">"obj/api"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"build"</span>: &#123;</span><br><span class="line">    <span class="attr">"content"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"files"</span>: [</span><br><span class="line">          <span class="string">"api/**.yml"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"cwd"</span>: <span class="string">"obj"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"files"</span>: [</span><br><span class="line">          <span class="string">"api/*.md"</span>,</span><br><span class="line">          <span class="string">"articles/**.md"</span>,</span><br><span class="line">          <span class="string">"toc.yml"</span>,</span><br><span class="line">          <span class="string">"*.md"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"exclude"</span>: [</span><br><span class="line">          <span class="string">"obj/**"</span> </span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"resource"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"files"</span>: [</span><br><span class="line">          <span class="string">"images/**"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"exclude"</span>: [</span><br><span class="line">          <span class="string">"obj/**"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"overwrite"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"files"</span>: [</span><br><span class="line">          <span class="string">"apidoc/**.md"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"exclude"</span>: [</span><br><span class="line">          <span class="string">"obj/**"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"dest"</span>: <span class="string">"../../docs"</span>,</span><br><span class="line">    <span class="attr">"template"</span>: [</span><br><span class="line">      <span class="string">"default"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>編譯專案</strong><br>改好設定後, 只要在 visual studio 中編譯 TryDocFx.DocFx 這個工具專案, 他就會根據設定將產品專案的 XML 文件註解轉換成靜態網頁並輸出到設定的輸出路徑中 (../../docs).<br>最後只要設定好 GitHub Pages 並將專案全部推上 GitHub 就完成了.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>可以將 C# 中的 XML 文件註解自動轉換成文件的方式很多, 不過如果要同時能整合 visual studio 又能包含自己寫的 Markdown 文件, 還得方便佈署的話, DocFx 是不錯的選擇.  </p>
<p>而從設定檔的結構與內容不難看出, 他的功能應該更強大, 不過這就等之後遇到複雜的情境時在來仔細研究了.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://dotnet.github.io/docfx/index.html" target="_blank" rel="noopener">DocFx</a></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[將 Stopwatch 封裝成小工具]]></title>
      <url>/content/20190112-stopwatch-util.html</url>
      <content type="html"><![CDATA[<p>Stopwatch 經常被用來觀察程式的運行時間, 在開發階段能協助我們抓出一些效能的問題, 不過他的基本使用方式不是很漂亮, 在程式碼中插入一堆 Stopwatch 會干擾開發或是不小心沒移除而 commit 上版控也不好.   </p>
<p>另一方面, 如果有需要用他來觀察 production 環境的運作效能的時候, 這些穿插在主要程式碼中的 Stopwatch 就更加干擾了, 所以找了兩個方法來將 Stopwatch 封裝成小工具.  </p>
<a id="more"></a>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>這個方式是將主要邏輯 <code>action()</code> 以及紀錄運行時間的方法 <code>report(ticks)</code> 做為 Action 傳進工具中執行, 並在執行前後加上 Stopwatch 計算運行時間後呼叫紀錄運行時間的方法 <code>report(ticks)</code>.  </p>
<p>其中第二個參數 <code>report(ticks)</code> 會存在主要是假設呼叫端對於回傳執行時間的所做的處理不同, 如果覺得兩個 Action 參數過於複雜, 可以把第二個參數改成選擇性參數, 沒傳入的話就執行預設的行為就好, 或者目前系統沒這個需求的話, 也可以不需要第二個參數.  </p>
<p>範例如下:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StopwatchReporter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">Action action, Action&lt;<span class="keyword">long</span>&gt; report</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> stopwatch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">        action();</span><br><span class="line"></span><br><span class="line">        stopwatch.Stop();</span><br><span class="line">        <span class="keyword">var</span> excusionTicks = stopwatch.ElapsedTicks;</span><br><span class="line"></span><br><span class="line">        report(excusionTicks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣封裝非常簡單易懂, 使用上也還算方便, 可以輕易的將主要邏輯與效能監控分開, 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StopwatchReporter.Execute(</span><br><span class="line">    () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do anything here</span></span><br><span class="line">    &#125;, </span><br><span class="line">    ticks =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Logging excusion time or something else here</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="實作-IDisposable"><a href="#實作-IDisposable" class="headerlink" title="實作 IDisposable"></a>實作 IDisposable</h3><p>上一個方法唯一的小缺點就是還是需要將主要流程包進 Action 裡面, 雖然 C# 提供的語法糖已經大幅提高可讀性了, 不過還是有其他方法能讓呼叫端看起來更簡潔.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StopwatchReporter</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _name;</span><br><span class="line">    <span class="keyword">private</span> Stopwatch _stopwatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StopwatchReporter</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        _stopwatch.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _stopwatch.Stop();</span><br><span class="line">        <span class="keyword">var</span> excusionTime = _stopwatch.ElapsedMilliseconds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// logging here</span></span><br><span class="line">        Debug.WriteLine(<span class="string">$"<span class="subst">&#123;_name&#125;</span> excusion time: <span class="subst">&#123;excusionTime&#125;</span> ms"</span>);</span><br><span class="line"></span><br><span class="line">        _name = <span class="literal">null</span>;</span><br><span class="line">        _stopwatch = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這種做法最大的優點就是呼叫端極致簡潔, 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> StopwatchReporter(<span class="string">"something"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Do anything here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但其實這種做法缺點比較多, 一來是實作複雜度提高很多, 且在我<a href="http://pietschsoft.com/post/2015/12/17/Code-Tip-Simpler-Performance-Timer-Logging-in-C" target="_blank" rel="noopener">所參考的文章下面的回覆中</a>有提到, 為了這個便利性而讓程式碼在釋放資源用的方法中去操作資源, 下面節錄自該則回覆:</p>
<blockquote>
<p>You implement IDisposable when you are managing resources. Implementing it communicates to other developers that you’re doing dealing with memory usage, and implies that you SHOULD call Dispose as soon as reasonably possible. Using it as syntactic sugar confuses that message.  </p>
<p>Patterns and interfaces communicate intent. Using a pattern because you like the way it reads while ignoring what the interface intends creates cluttered code.</p>
</blockquote>
<p>其實我個人是滿認同這則回覆的, 雖然對於呼叫端來說並不需要知道實作細節, 但就設計的角度來看, 的確是在一個釋放資源的 <code>Dispose()</code> 方法中做了意想不到的行為, 如果是單純把 Stopwatch 停止並釋放倒是還好, 但是如果要紀錄時間就可能會依賴其他組件, 當複雜度一提高, 這個做法的缺點就會更明顯.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>兩種做法要選的話, 我會選第一種用 Action 的作法, 比較合理好懂且呼叫方式也夠整潔.  </p>
<p>但總體來說, 目前為止對於特別封裝這麼一個工具我還是覺得有點雞肋, 只是說如果真的很必要在真實的 production 環境監控的話也是一種可行方案, 就先記起來備忘, 搞不好哪天真的會用上.    </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/a/969327/8223582" target="_blank" rel="noopener">Exact time measurement for performance testing</a><br><a href="http://pietschsoft.com/post/2015/12/17/Code-Tip-Simpler-Performance-Timer-Logging-in-C" target="_blank" rel="noopener">Code Tip: Simpler Performance Timer Logging in C#</a>  </p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[指示詞(#if) 和 ConditionalAttribute]]></title>
      <url>/content/20190111-if-directive-and-conditional.html</url>
      <content type="html"><![CDATA[<p>有時候我們會需要用到 C# 的<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/" target="_blank" rel="noopener">前置處理器指示詞(Preprocessor Directives)</a> 中的 #if 等相關指示詞, 最常見的就是用來區分 Debug 和 Release 的編譯模式.  </p>
<p>也有另外一種方式 (ConditionalAttribute) 可以達到類似的效果, 但兩種方式的運作機制是不一樣的.  </p>
<a id="more"></a>
<p>這類型的條件編譯最常用在環境區分, 而不管用 #if 還是 ConditionalAttribute, 都要定義專案在各種模式下的 compilation symbol, 要注意的是這部分是大小寫敏感, 雖然用小寫不會有問題, 但一般來說是用全大寫, 例如: DEBUG.  </p>
<p>設定方式如下:<br><img src="/content/20190111-if-directive-and-conditional/assign-symbol.gif"> </p>
<h3 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="#if, #elif, #else"></a>#if, #elif, #else</h3><h4 id="運作方式"><a href="#運作方式" class="headerlink" title="運作方式"></a>運作方式</h4><p>被 #if, #elif 包起來的區間不符合定義的 compilation symbol 時, 編譯時會直接略過區間內的程式碼, 也就是說不會被編譯, 以下面程式碼與 IL 為例  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Caller</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    Console.WriteLine(<span class="string">"DEBUG: IfDirective Executed"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> RELEASE</span></span><br><span class="line">    Console.WriteLine(<span class="string">"RELEASE: IfDirective: Executed"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    Console.WriteLine(<span class="string">"IfDirective Executed"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IL_0000 nop</span><br><span class="line">IL_0001 ldstr  &quot;DEBUG: IfDirective Executed&quot;</span><br><span class="line">IL_0006 call   System.Void System.Console::WriteLine(System.String)</span><br><span class="line">IL_000B nop</span><br><span class="line">IL_000C ret</span><br></pre></td></tr></table></figure>
<p>透過工具, 我們可以看到在 DEBUG 下編譯, 只剩 DEBUG 區塊的程式碼.</p>
<h4 id="優缺點"><a href="#優缺點" class="headerlink" title="優缺點"></a>優缺點</h4><p>這樣雖然不需要的程式碼不會被編譯, 但是從使用方式看來, 如果不小心使用的話很容易讓程式碼變得很髒亂, 到處都是 #if, #elif 和 #else.  </p>
<p>而從另外一個角度看, 因為不滿足條件的區塊不會被編譯, 所以很多 visual studio 提供的功能都會無法使用, 維護上很容易造成困擾, 例如在 DEBUG 下將一個方法重新命名, 結果這個方法在 RELEASE 區間有被呼叫到, 卻不會被修改到, 當切換到 RELEASE 的時候就無法通過編譯, 又例如尋找所有引用 (Find All References) 的功能也是一樣.  </p>
<h3 id="ConditionalAttribute"><a href="#ConditionalAttribute" class="headerlink" title="ConditionalAttribute"></a>ConditionalAttribute</h3><h4 id="運作方式-1"><a href="#運作方式-1" class="headerlink" title="運作方式"></a>運作方式</h4><p>當不符合 ConditionalAttribute 所套用的 compilation symbol 時, 編譯後會忽略呼叫端的呼叫, 但是保留被呼叫部分的程式碼, 以下面程式碼與 IL 為例  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Caller</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DebugConditional();</span><br><span class="line">    RELEASEConditional();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">"DEBUG"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DebugConditional</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"DEBUG: Conditional Executed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">"RELEASE"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RELEASEConditional</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"RELEASE: Conditional Executed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Selected method: LazyGuy.Demo.Caller</span><br><span class="line">IL_0000 nop</span><br><span class="line">IL_0001 ldarg.0</span><br><span class="line">IL_0002 call     System.Void LazyGuy.Demo::DebugConditional()</span><br><span class="line">IL_0007 nop</span><br><span class="line">IL_0008 ret</span><br><span class="line"></span><br><span class="line">// Selected method: LazyGuy.Demo.DebugConditional</span><br><span class="line">IL_0000 nop</span><br><span class="line">IL_0001 ldstr  &quot;DEBUG: Conditional Executed&quot;</span><br><span class="line">IL_0006 call   System.Void System.Console::WriteLine(System.String)</span><br><span class="line">IL_000B nop</span><br><span class="line">IL_000C ret</span><br><span class="line"></span><br><span class="line">// Selected method: LazyGuy.Demo.RELEASEConditional</span><br><span class="line">IL_0000 nop</span><br><span class="line">IL_0001 ldstr  &quot;RELEASE: Conditional Executed&quot;</span><br><span class="line">IL_0006 call   System.Void System.Console::WriteLine(System.String)</span><br><span class="line">IL_000B nop</span><br><span class="line">IL_000C ret</span><br></pre></td></tr></table></figure>
<p>透過工具, 我們可以看到在 DEBUG 下編譯, 呼叫端的呼叫只剩 <code>DebugConditional()</code>, 而 <code>RELEASEConditional()</code> 這個方法還是會被編譯, 只是沒被呼叫.  </p>
<h4 id="優缺點-1"><a href="#優缺點-1" class="headerlink" title="優缺點"></a>優缺點</h4><p>ConditionalAttribute 有很多使用限制</p>
<ul>
<li>只能加在 void method 以及 attribute class 上</li>
<li>不能加在實作介面的方法上</li>
<li>不能加在 override 方法上</li>
</ul>
<p>這個方法雖然限制很多, 但是也有很多好處如下:   </p>
<p>首先, 因為 ConditionalAttribute <strong>只能加在 void method 以及 attribute class 上</strong>, 所以變相強制我們將這些程式碼抽出成獨立的方法, 避免 #if 會產生的副作用.  </p>
<blockquote>
<p>即使將 #if 中的程式碼抽出成獨立方法, 但因為編譯時並不會移除呼叫端的呼叫, 所以會變成呼叫一個空方法, 也不是太好, 反之 ConditionalAttribute 就不會有這個問題.  </p>
</blockquote>
<p>第二, 他也不會有 #if 在使用 visual studio 的輔助功能時的問題.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>如果就這兩個來比較, 使用 ConditionalAtrribute 取代 #if 會比較好, 如果因為 ConditionalAtrribute 的限制而無法使用, 最後再改用 #if.<br>不過這種需要依照環境切換邏輯的情境, 我會優先往 config 或後臺設定的方向思考, 除非用設定還是處理的不夠好, 才會往 ConditionalAtrribute 的方向想.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="http://jaliyaudagedara.blogspot.com/2016/09/c-conditional-attribute-and-if-directive.html" target="_blank" rel="noopener">C# : Conditional Attribute and #if Directive</a><br><a href="https://blogs.msmvps.com/peterritchie/2011/11/24/if-you-re-using-if-debug-you-re-doing-it-wrong/" target="_blank" rel="noopener">If You’re Using “#if DEBUG”, You’re Doing it Wrong</a><br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if (C# Reference)</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/4xssyw96(v%3dvs.90" target="_blank" rel="noopener">Conditional (C# Programming Guide)</a>)<br><a href="https://stackoverflow.com/questions/3788605/if-debug-vs-conditionaldebug" target="_blank" rel="noopener">#if DEBUG vs. Conditional(“DEBUG”)</a>  </p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[將 RSA 金鑰轉成 XML 格式的少見問題]]></title>
      <url>/content/20190105-bouncycastle-rsa-key-with-leading-zero-to-xml.html</url>
      <content type="html"><![CDATA[<p>.NET 內建的 RSA 加解密相關元件可以用讀取憑證檔或是 XML 格式的金鑰的方式來初始化, 之前的專案都是用讀取 XML 的方式來操作, 讓管理者能夠方便的從後台來管理金鑰.  </p>
<p>而在 PEM 檔中, 金鑰的格式是 base64 字串, 這用 JAVA 是可以正常讀取的, 但卻不是 .NET 接受的 XML 格式, 因此用了一個第三方套件 <a href="https://github.com/bcgit/bc-csharp" target="_blank" rel="noopener">Bouncy Castle</a> 來幫忙轉換, 但是在一個少見的情境下 (其實也沒有多少見, 我用 OpenSSL 隨機生 500 組, 就有 10 組觸發), 轉換出來的 XML 是錯誤的, 且只有私鑰有發生過.  </p>
<a id="more"></a>
<h3 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h3><p>如果有在網路上找過金鑰轉換的方式的話, 應該不難找到下面段轉換私鑰的程式碼, 透過 <code>RSAPrivateKeyJava2DotNet(string privateKey)</code> 方法來將 base64 格式的私鑰轉換成 XML 格式.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">SignDataByPrivateKey</span>(<span class="params"><span class="keyword">string</span> data, <span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> xmlData = RSAPrivateKeyJava2DotNet(key);</span><br><span class="line">    RSACryptoServiceProvider privateKey = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">    privateKey.FromXmlString(xmlData);</span><br><span class="line">    <span class="keyword">var</span> signBytes = privateKey.SignData(Encoding.UTF8.GetBytes(data), <span class="string">"sha1"</span>);</span><br><span class="line">    <span class="keyword">return</span> Convert.ToBase64String(signBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RSAPrivateKeyJava2DotNet</span>(<span class="params"><span class="keyword">string</span> privateKey</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RsaPrivateCrtKeyParameters privateKeyParam = (RsaPrivateCrtKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKey));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>.Format(</span><br><span class="line">        <span class="string">"&lt;RSAKeyValue&gt;&lt;Modulus&gt;&#123;0&#125;&lt;/Modulus&gt;&lt;Exponent&gt;&#123;1&#125;&lt;/Exponent&gt;&lt;P&gt;&#123;2&#125;&lt;/P&gt;&lt;Q&gt;&#123;3&#125;&lt;/Q&gt;&lt;DP&gt;&#123;4&#125;&lt;/DP&gt;&lt;DQ&gt;&#123;5&#125;&lt;/DQ&gt;&lt;InverseQ&gt;&#123;6&#125;&lt;/InverseQ&gt;&lt;D&gt;&#123;7&#125;&lt;/D&gt;&lt;/RSAKeyValue&gt;"</span>,</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.Modulus.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.PublicExponent.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.P.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.Q.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.DP.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.DQ.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.QInv.ToByteArrayUnsigned()),</span><br><span class="line">        Convert.ToBase64String(privateKeyParam.Exponent.ToByteArrayUnsigned())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段程式碼一般情境下沒有問題, 但是如果用下面的測試私鑰來試, 就會在 <code>privateKey.FromXmlString(xmlData);</code> 這一行拋出 <code>CryptographicException</code> 且錯誤資訊只有短短的 “Bad Data.\r\n”.  </p>
<p><strong>Private Key</strong> :<br><code>MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAOEZbmixVVPO6Z96
sGqb8G3gBOgBuLc6o673GyxLZPXPk6VaBF+2LJ+WnIbuYu3iDE2pR1SHeA09BCyz
YJnJTYl77vqzRqyzf9lWHGJDkwpEnftlDfeIc5ICfWpu3bHuBuzmtIfqrErCbaJJ
3HkhOsuJ3oL8dAYQN5RTt66IpSn9AgMBAAECgYBEOuotj7sWeTx1W8IHvpbFJ0c1
b/gmif69dSdmaMAEhlPxpfR3cofaI9P0TmPsST2DeNEnPRzVnm4agpDAbLU0ana1
I8pfjRq3xrlTJkDjWKOyaFF2afo2y1pyIFsm1G5wVEFwKWSNUo/1Jy61H4snYxMk
/SCZqAYxO3S12jAFHQJBAP6Cv1MV8HcBMuDgyl9Obq/tU6r9zrGOmR1bWBA61DVw
jcWgMSpo8dkBAs0Hd5SfWNNzUIVH2gryAcy5Skyq8mMCQQDiaqBM2nCLfQ3EaLzy
e1tYZCuZYiZl60OX9nS9FNLFwSI6sFsy/+aGg1ivSVHvXpi9N1oaNgvSI13z9DT0
B/AfAkAArfqyzxkwSCmJnjAMJxp2j8ysZTcbFEVmZasLiAyvA9jtEStwcI1Mxgrq
3z07gV1sWx9466MyakkE8e233LD/AkEA244n+b6NCkZu1jn2l3CVaIZiXO93areT
qUV9eGk75jXdemnPVgoeQewWUIvZ3zOtCzcksWwdVF2lWs5Bly4nYwJBAK+niJt3
7jWf13muppL1aRN/i1otm3yNZuNGhrCZ/nEfehhBtege3IHn337fuyLhlXMc37OY
k1iKRpcW8kn4LFQ=</code>  </p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>當初也是找了很久, 最後發現 <code>privateKeyParam.DP.ToByteArrayUnsigned()</code> 中的 DP 只有 63 bytes, 少了一個位元組, 而造成這個現象的原因是因為 <code>privateKeyParam.DP</code> 是數值型態, <code>Org.BouncyCastle.Math.BigInteger</code> 在初始化的時候, 跳過了開頭的所有 0, 而且這個問題在 DP , DQ , Exponent , QInv 這四段上面都會發生.  </p>
<blockquote>
<p>根據<a href="http://www.bouncycastle.org/jira/browse/BMA-92?jql=project%20%3D%20BMA%20AND%20fixVersion%20%3D%201.8.0" target="_blank" rel="noopener">官方JIRA 上的單子 BMA-92</a> 可以看出是在 <code>Org.BouncyCastle.Math.BigInteger</code> 初始化過程造成的, 從原始碼中看起來也很合理(不過我只是<a href="https://github.com/bcgit/bc-csharp/blob/f18a2dbbc2c1b4277e24a2e51f09cac02eedf1f5/crypto/src/math/BigInteger.cs" target="_blank" rel="noopener">看看原始碼推測的</a>, 沒有直接拉下來驗證, 不保證真的是):<br>從 public BigInteger(byte[] bytes) : this(bytes, 0, bytes.Length)<br>=&gt; public BigInteger(byte[] bytes, int offset, int length)<br>=&gt; private static int[] MakeMagnitude(byte[]    bytes, int offset, int length)<br>中的 firstSignificant 這個 flag 以第一個非 0 位置為起點</p>
</blockquote>
<p>而用這個發現來推論, 也可以理解為什麼公鑰不會有這問題, 因為公鑰只有 Modulus 和 Exponent 這兩段.  </p>
<h3 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h3><p>其實這個轉換過程 Bouncy Castle 有提供更簡便的方式, 不需要自己串, 將 <code>RSAPrivateKeyJava2DotNet(string privateKey)</code> 改成像下面這樣(公鑰的部分也一併改了):  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">RSAPrivateKeyJava2DotNet</span>(<span class="params"><span class="keyword">string</span> privateKey</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RsaPrivateCrtKeyParameters privateKeyParam = (RsaPrivateCrtKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKey));</span><br><span class="line">    <span class="keyword">return</span> DotNetUtilities.ToRSA(privateKeyParam).ToXmlString(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">RSAPublicKeyJava2DotNet</span>(<span class="params"><span class="keyword">string</span> publicKey</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKey));</span><br><span class="line">    <span class="keyword">return</span> DotNetUtilities.ToRSA(publicKeyParam).ToXmlString(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有追進去<a href="https://github.com/bcgit/bc-csharp/blob/f18a2dbbc2c1b4277e24a2e51f09cac02eedf1f5/crypto/src/security/DotNetUtilities.cs" target="_blank" rel="noopener">原始碼</a>看可以發現, 他在要轉換成 XML 字串前, 將開頭有 0 被忽略的部分再補回來, 實測後也確實可以避免原本的問題, 他的 call stack 有點長, 這裡直接列出最關鍵的地方如下, 就是 <code>ConvertRSAParametersField</code> 這個方法才避免掉這個問題的:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RSAParameters <span class="title">ToRSAParameters</span>(<span class="params">RsaPrivateKeyStructure privKey</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RSAParameters rp = <span class="keyword">new</span> RSAParameters();</span><br><span class="line">    rp.Modulus = privKey.Modulus.ToByteArrayUnsigned();</span><br><span class="line">    rp.Exponent = privKey.PublicExponent.ToByteArrayUnsigned();</span><br><span class="line">    rp.P = privKey.Prime1.ToByteArrayUnsigned();</span><br><span class="line">    rp.Q = privKey.Prime2.ToByteArrayUnsigned();</span><br><span class="line">    rp.D = ConvertRSAParametersField(privKey.PrivateExponent, rp.Modulus.Length);</span><br><span class="line">    rp.DP = ConvertRSAParametersField(privKey.Exponent1, rp.P.Length);</span><br><span class="line">    rp.DQ = ConvertRSAParametersField(privKey.Exponent2, rp.Q.Length);</span><br><span class="line">    rp.InverseQ = ConvertRSAParametersField(privKey.Coefficient, rp.Q.Length);</span><br><span class="line">    <span class="keyword">return</span> rp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">ConvertRSAParametersField</span>(<span class="params">BigInteger n, <span class="keyword">int</span> size</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bs = n.ToByteArrayUnsigned();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bs.Length == size)</span><br><span class="line">        <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bs.Length &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Specified size too small"</span>, <span class="string">"size"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] padded = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    Array.Copy(bs, <span class="number">0</span>, padded, size - bs.Length, bs.Length);</span><br><span class="line">    <span class="keyword">return</span> padded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案外案-套件版本"><a href="#案外案-套件版本" class="headerlink" title="案外案 - 套件版本"></a>案外案 - 套件版本</h3><p><strong>但是</strong><br><strong>但是</strong><br><strong>但是</strong>  </p>
<p><strong>剛剛的解決方式只在 1.8.0 之後才有效, 1.7.x 以前的版本即使這樣使用還是會出錯.</strong>  </p>
<p>這部分從上面有出現過一個 <a href="http://www.bouncycastle.org/jira/browse/BMA-92?jql=project%20%3D%20BMA%20AND%20fixVersion%20%3D%201.8.0" target="_blank" rel="noopener">JIRA 的列表</a>就可以看到這個問題是 1.8.0 才修復的, 但是 GitHub 的時候已經是 1.8.0 版了, 所以如果真的想比對舊版的原始碼的話, 就要去<a href="https://www.bouncycastle.org/csharp/index.html" target="_blank" rel="noopener">官網</a>考古了.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實如果直接讀憑證檔, 就不會有這個問題, 但是專案特性的關係, 這個金鑰會常常新增或更新, 為了不要每次增加或修改都要重新佈署, 只能花時間下去找原因跟解法了.  </p>
<p>當時遇到這個問題的時候真的是很難過, 因為錯誤訊息超級少, 想找 google 都不知道關鍵字怎麼下, 還好弄了兩三天之後意外發現資料長度不對才有突破口, 這個專案中加解密的部分是存在好幾年的共用方法, 一直沒人遇到過這個情境, 既然被我踩到了也算是得到一個難得的經驗吧.  </p>
<p>另外, 既然套件有封裝好這麼方便的方法, 之後有需要寫類似的方法時, 就不用再用以前流傳的那種方式了, 直接用解法中的做法就好, 這也是在網路上搜尋解決方案的時候要注意的, 多找幾種解決方案比較過再決定, 會更有機會找到比較適合的解決方案.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://www.cryptosys.net/pki/rsakeyformats.html" target="_blank" rel="noopener">RSA Key Formats - Key File Encoding</a><br><a href="https://blog.csdn.net/yupu56/article/details/72624229" target="_blank" rel="noopener">C#和JAVA的RSA密钥、公钥转换</a><br><a href="http://www.bouncycastle.org/jira/browse/BMA-92?jql=project%20%3D%20BMA%20AND%20fixVersion%20%3D%201.8.0" target="_blank" rel="noopener">JIRA of Bouncy Castle</a>  </p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Packages </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SymmetricAlgorithm 中 Key 和 KeySize 的依賴造成的少見問題]]></title>
      <url>/content/20181230-interaction-between-key-and-keysize-in-symmetric-algorithm.html</url>
      <content type="html"><![CDATA[<p>之前在寫 AES 加解密用的工具方法的時候, 意外發現某個特殊的情境, 會導致解密時因為沒有 Key 而拋出例外 (但 Key 確實有設定).  </p>
<a id="more"></a>
<h3 id="問題解析"><a href="#問題解析" class="headerlink" title="問題解析"></a>問題解析</h3><p>首先要來看一下示意的程式碼 </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main logic</span></span><br><span class="line"><span class="keyword">var</span> aes = <span class="keyword">new</span> AesCryptoServiceProvider()</span><br><span class="line">&#123;</span><br><span class="line">    Mode = CipherMode.ECB,</span><br><span class="line">    Key = GenerateKey(<span class="number">128</span>),</span><br><span class="line">    KeySize = <span class="number">128</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> ciphertext = <span class="string">"jYCA05v0hL52/wT5WEJitQ=="</span>;</span><br><span class="line"><span class="keyword">string</span> plaintext = aes.Decrypt(ciphertext);</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extension method for decrypt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Decrypt</span>(<span class="params"><span class="keyword">this</span> SymmetricAlgorithm symmetric, <span class="keyword">string</span> ciphertext</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> plaintext = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    MemoryStream ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">    <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, symmetric.CreateDecryptor(), CryptoStreamMode.Write))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ciphertextBytes = Convert.FromBase64String(ciphertext);</span><br><span class="line"></span><br><span class="line">        cs.Write(ciphertextBytes, <span class="number">0</span>, ciphertextBytes.Length);</span><br><span class="line">        cs.FlushFinalBlock();</span><br><span class="line">        plaintext = Encoding.UTF8.GetString(ms.ToArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plaintext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著來分析一下錯誤內容<br><strong>錯誤訊息</strong>: System.Security.Cryptography.CryptographicException: ‘Decrypting a value requires that a key be set on the algorithm object.’<br><strong>堆疊追蹤最後一行</strong>:<br><code>at System.Security.Cryptography.AesCryptoServiceProvider.CreateDecryptor()</code></p>
<p>這看起來像是 Key 不存在, 但我們確實有指定 Key, 而用中斷點進去 <code>symmetric.CreateDecryptor()</code> 這一行的 <code>symmetric</code> 中卻發現 Key 的值已經不是一開始指定的值了.  </p>
<h3 id="問題點說明"><a href="#問題點說明" class="headerlink" title="問題點說明"></a>問題點說明</h3><p>總之是耗了一點時間在排除問題, 最後發現是 <code>KeySize = 128</code> 這一行導致的, 因為<strong>設定 KeySize 這件事本身會使得 Key 被釋放掉</strong>.  </p>
<p>這個現象要看官方的原始碼才能知道, 從 <a href="https://referencesource.microsoft.com/#System.Core/System/Security/Cryptography/AesCryptoServiceProvider.cs,123" target="_blank" rel="noopener">AesCryptoServiceProvider.cs</a> 中可以看到 KeySize 的 setter 會將一開始設定的 Key 釋放掉, 導致 <a href="https://referencesource.microsoft.com/#System.Core/System/Security/Cryptography/AesCryptoServiceProvider.cs,144" target="_blank" rel="noopener">AesCryptoServiceProvider.CreateDecryptor()</a> 執行時發現 <code>m_key</code> 沒有值而拋錯. </p>
<p>再更進一步去看父類別中 <a href="https://referencesource.microsoft.com/#mscorlib/system/security/cryptography/symmetricalgorithm.cs,158" target="_blank" rel="noopener">SymmetricAlgorithm 中的 KeySize</a> 就可以發現, 其實<strong>不只 AES, 整個 SymmetricAlgorithm 的衍生類別都會在 KeySize 的 setter 中清掉現有的 Key</strong> (除非有誰特別將這段邏輯覆寫掉).  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>相關的程式碼想看可以去上面那些連結裡面深入了解, 總之</p>
<ul>
<li><p>Key 和 KeySize 之間是有依賴的, 指定 Key 之前如果先指定 KeySize 沒有意義, 因為指定 Key 的時候, KeySize 也會被改變, 所以下面範例<strong>最後的 KeySize 是 256 而不是 128</strong>. </p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AesCryptoServiceProvider()</span><br><span class="line">&#123;</span><br><span class="line">    Mode = CipherMode.ECB,</span><br><span class="line">    KeySize = <span class="number">128</span>,</span><br><span class="line">    Key = GenerateKey(<span class="number">256</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同理, 如果指定了 Key, 就不可以在後面再指定 KeySize, 不然原本指定的 Key 會被清掉, 也就是本文遇到的問題. </p>
</li>
<li><p>需要指定 KeySize 的時機是, 加密時要指定 Key 的長度且不想自己產生 Key, 例如</p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AesCryptoServiceProvider()</span><br><span class="line">&#123;</span><br><span class="line">    Mode = CipherMode.ECB,</span><br><span class="line">    KeySize = <span class="number">128</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相關問題, 網路上也有人討論, 附在下方參考中</p>
</li>
</ul>
<p>其實這樣想起來也合理, Key 的值本身就可以算出 KeySize, 如果 KeySize 被指定時沒有清掉舊的 Key, 那就會可能發生 Key 的實際長度跟 KeySize 紀錄的長度不一樣的問題.  </p>
<p>然後 <a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">Reference Source</a> 和 <a href="https://source.dot.net/" target="_blank" rel="noopener">Source Browser - .net core</a> 真的是神物, 很多時候能靠這兩個東西了解細部的運作與問題發生的具體原因.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/questions/39275663/rijndaelmanaged-what-does-setting-keysize-property-do" target="_blank" rel="noopener">RijndaelManaged - What does setting KeySize property do?</a>  </p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[XSD 的使用與應用]]></title>
      <url>/content/20181225-use-xml-schema-definition.html</url>
      <content type="html"><![CDATA[<p>XSD 的文章很早之前就寫過, 但是當時剛開始寫部落格, 所以雖然寫了三篇但內容沒有編排又很亂, 因此最近想說稍微重寫一下, 留下重點就好.  </p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>XSD 全名為 XML Schema Definition, 用來定義並驗證一個 XML 文件的格式, 除此之外他對我們在 Visual Studio 中編寫 XML 的時候能提供很大的幫助如下: </p>
<ul>
<li>在 Visual Studio 中檢查 XML 的格式與內容是否符合定義. </li>
<li>在 Visual Studio 中使用自動提示 (Intellisence) 的功能來提示我們該怎麼寫. </li>
<li>移到自動提示的選項上還會顯示這個選項的註解(當然要先定義在 XSD 中), 滑鼠移過到上面也會跳出註解, 就像平常開發在呼叫 API 會有的自動提示和註解提示一樣.</li>
</ul>
<p>因此當一個專案需要依賴大量的 XML 設定檔去設定或是設定檔本身比較複雜的時候, 定義一份完整的 XSD 能讓設定檔在編寫時能有更充足的提示, 不用一直花時間去翻設定說明, 也可以避免花時間去抓因手誤造成的bug.  </p>
<p>本文會用之前為自訂 StyleCop 的規則需寫的 XML 所做的 XSD - <a href="https://github.com/ronsun/ExtendedStyleCopRules/blob/master/src/ExtendedStyleCopRules/NamingRules/ExtendedNamingRules.xml" target="_blank" rel="noopener">SourceAnalyzer.xsd</a> 來做<br>範例. </p>
<h3 id="建立一個新的-XSD-檔"><a href="#建立一個新的-XSD-檔" class="headerlink" title="建立一個新的 XSD 檔"></a>建立一個新的 XSD 檔</h3><p>在 Visual Studio 中開啟一個專案, 並加入一個 XML Schema 檔案, 預設內容如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">id</span>=<span class="string">"XMLSchema1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">targetNamespace</span>=<span class="string">"http://tempuri.org/XMLSchema1.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://tempuri.org/XMLSchema1.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mstns</span>=<span class="string">"http://tempuri.org/XMLSchema1.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的幾個屬性說明如下: </p>
<ul>
<li>targetNamespace: 目前文件命名空間. </li>
<li>elementFormDefault: 選填, qualified 或 unqualified, 預設是unqualified, 建議用 qualified. </li>
<li>xmlns / xmlns:mstns / xmlns:xs: 各種引用的 XSD 與命名空間, 其中 <a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a> 就是用來定義xsd的xsd schema, 這也是為什麼在 visual studio 中編寫 xsd 時能有自動提示與驗證. </li>
</ul>
<p>雖然預設的命名空間看起來是一個 URL, 但實際上命名空間只是用來做識別用的, 並非必要是 URL, 用 URL 的好處是可以提示使用者連上該網站得到更詳細的說明, 如下面範例.  </p>
<blockquote>
<p>URL 應該是放專案的 GitHub Pages 連結比較好, 不過這個專案我沒有建 GitHub Pages 所以就直接放 GitHub 專案的連結了.  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:schema id=&quot;SourceAnalyzer&quot;</span><br><span class="line">    targetNamespace=&quot;https://github.com/ronsun/ExtendedStyleCopRules&quot;</span><br><span class="line">    elementFormDefault=&quot;qualified&quot;</span><br><span class="line">    xmlns:this=&quot;https://github.com/ronsun/ExtendedStyleCopRules&quot;</span><br><span class="line">    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;/xs:schema&gt;</span><br></pre></td></tr></table></figure>
<h3 id="套用到-XML-上"><a href="#套用到-XML-上" class="headerlink" title="套用到 XML 上"></a>套用到 XML 上</h3><h4 id="如何套用"><a href="#如何套用" class="headerlink" title="如何套用"></a>如何套用</h4><p>XSD 寫好後, 在 Visual Studio 中點選 <strong>XML &gt; Schemas</strong> 可以看到這個 XSD 已經被自動套用了, 接著建立一個新的 XML 檔並指定 xmlns 為剛剛建立的 XSD 的 targetNamespace 就可以套用到該 XML 檔上了.  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">SourceAnalyzer</span> <span class="attr">Name</span>=<span class="string">"Extend Naming Rules"</span> <span class="attr">xmlns</span>=<span class="string">"https://github.com/ronsun/ExtendedStyleCopRules"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Description</span>&gt;</span></span><br><span class="line">    Extended naming rules.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Rule</span> <span class="attr">Name</span>=<span class="string">"PrivateFieldNamesMustStartWithUnderscore"</span> <span class="attr">CheckId</span>=<span class="string">"EA1301"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Context</span>&gt;</span>Private filed name must start with Underscore<span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Description</span>&gt;</span>Validates that names of private field must start with an underscore.<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Rule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Rules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SourceAnalyzer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="自動提示-Intellisence-與檢查"><a href="#自動提示-Intellisence-與檢查" class="headerlink" title="自動提示 (Intellisence) 與檢查"></a>自動提示 (Intellisence) 與檢查</h4><p>套用上之後就可以有自動提示與檢查功能.  </p>
<p><strong>不合規則時會有警示</strong><br>不合規則時, 右側卷軸會有一個淡藍色小點, 輸入的文字本身下面也會有一條淡藍色毛毛蟲, 滑鼠移過去可以看到詳細的警告描述, 且在 Error List 地方也會有警告, 非常方便.<br><img src="/content/20181225-use-xml-schema-definition/xsd-warning.png">  </p>
<p><strong>自動提示功能</strong><br>選到提示的選項時, 會彈出預先在 XSD 中寫好的註解.<br><img src="/content/20181225-use-xml-schema-definition/xsd-intellisence.png">  </p>
<p>滑鼠移過文字時, 會彈出預先在 XSD 中寫好的註解.<br><img src="/content/20181225-use-xml-schema-definition/xsd-annotation.png">  </p>
<h4 id="在程式碼中套用檢查規則"><a href="#在程式碼中套用檢查規則" class="headerlink" title="在程式碼中套用檢查規則"></a>在程式碼中套用檢查規則</h4><p>雖然 Visual Studio 會顯示警告, 但總有些時候有人會自動忽略警告, 無法提早發現錯誤, 這時候還可以在程式中檢查, 在應用程式啟動時, 直接呼叫驗證方法, 如果有違反就直接拋例外, 做為最後一道防線.  </p>
<p><strong>但其實我是覺得這一段程式碼沒必要, 應該是要參考 Warning 的資訊, 並盡可能不要讓 Warning 存在而不是忽略它才是比較嚴謹的做法.</strong>  </p>
<p>大致的程式碼如下, 邏輯上就是載入 XSD 與相關的 XML, 接著透過 <code>XDocument.Validate(...)</code> 方法來驗證.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckXML</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentAssembly = Assembly.GetExecutingAssembly();</span><br><span class="line"></span><br><span class="line">    XmlSchemaSet schemas = <span class="keyword">new</span> XmlSchemaSet();</span><br><span class="line">    Stream xsdStream = currentAssembly.GetManifestResourceStream(<span class="string">"ronsun.github.io.lab.SourceAnalyzer.xsd"</span>);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = XmlReader.Create(xsdStream))</span><br><span class="line">    &#123;</span><br><span class="line">        schemas.Add(<span class="string">"https://github.com/ronsun/ExtendedStyleCopRules"</span>, reader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Stream xmlStream = currentAssembly.GetManifestResourceStream(<span class="string">"ronsun.github.io.lab.ExtendedNamingRules.xml"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        XDocument.Load(xmlStream).Validate(schemas, (sender, e) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Actions for validate results</span></span><br><span class="line">            <span class="keyword">if</span> (e.Severity == XmlSeverityType.Error)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="學習資源"><a href="#學習資源" class="headerlink" title="學習資源"></a>學習資源</h3><p>XSD 相關的學習資源如下:<br><a href="https://www.tutorialspoint.com/xsd/index.htm" target="_blank" rel="noopener">tutorials point</a><br><a href="https://www.w3schools.com/xml/schema_intro.asp" target="_blank" rel="noopener">w3schools</a> (en)<br><a href="http://www.w3school.com.cn/schema/index.asp" target="_blank" rel="noopener">w3schools</a> (zh-cn)  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實 XSD 不算很常用的功能, 有些大型專案需要的 XML 也不一定有 XSD, 在寫設定檔的時候就只能依賴文件跟記憶力, 但如果時間允許, 我還是贊成補上 XSD 文件的, 一方面可以讓後面的人上手比較容易, 另一方面 XSD 本身也扮演著文件的角色了, 就比較不需要另外去維護文件來說明 XML 應該怎麼寫.  </p>
<p>不過, XSD 本身做為文件可讀性不好, 之前我也 <a href="https://github.com/ronsun/xs3p" target="_blank" rel="noopener">fork 出一個開源專案 xs3p 做了一些修改</a>, 可以將 XSD 傳換成 html 文件, 細節也曾經寫過一篇文章 <a href="/content/20170902-xsd-to-document-by-xs3p.html" title="利用xs3p將xsd轉換成文件">利用xs3p將xsd轉換成文件</a> 記錄. </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/how-to-validate-using-xsd-linq-to-xml" target="_blank" rel="noopener">How to: Validate Using XSD (LINQ to XML) (C#)</a>  </p>
<hr>
]]></content>
      
        <categories>
            
            <category> XML </category>
            
            <category> XSD </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Vsual Studio 中的工作清單(Task List)]]></title>
      <url>/content/20181213-use-task-list-in-visual-studio.html</url>
      <content type="html"><![CDATA[<p>在開發的過程, 常常有一些需要改進但現階段沒時間做的部分, 我們在上面加上一個 <code>// TODO:</code> 的註解來標註, 甚至依照特性的不同會用不一樣的語彙(Token)來標註, 例如: <code>// BadSmell:</code> 等等, Visual Studio 已經有內建幾個常用語彙, 除了這些內建語彙外我們也可以自己新增團隊內部使用的語彙.  </p>
<p>另一方面, 這些工作清單慢慢累積後就會變得不好管理, 這部分也可以通過 Visual Studio 提供的相關功能來協助我們管理.    </p>
<a id="more"></a>
<h3 id="語彙-Token-的種類"><a href="#語彙-Token-的種類" class="headerlink" title="語彙(Token)的種類"></a>語彙(Token)的種類</h3><p>Visual Studio 內建幾種語彙與建議使用方式如下  </p>
<ul>
<li>TODO: 未實作的功能.</li>
<li>HACK: 為了解決緊急問題而寫的程式, 但不是個適當的做法, 例如寫死一些變數或參數的數值先應急, 但這個數值不應該是寫死的.</li>
<li>UNDONE: 為了解決短期問題而移除或註解掉程式碼, 或是需要切換並觀察兩個不同的做法哪種比較好. </li>
<li>UnresolvedMergeConflict: 某一小段程式碼單獨運作良好, 但放到整個專案中運作會有問題, 需要 debug 找出問題. </li>
</ul>
<blockquote>
<p>UnresolvedMergeConflict 的情境看起來比較像單元測試都能過, 但是整個流程測下來有問題, 可能是跟依賴物件的互動不正確, 或是是依賴度太高, 導致很容易被流程或是依賴物件影響他的正確性.</p>
</blockquote>
<p>雖然說教學是這樣建議, 不過團隊如果有其他共識的話其實就大家說好就好, 另外, 這些語彙是不分大小寫的, 所以 TODO 和 ToDo 是一樣的, 但還是跟著團隊習慣, 盡量一致比較好.</p>
<h3 id="工作清單視窗-Task-List-Explorer"><a href="#工作清單視窗-Task-List-Explorer" class="headerlink" title="工作清單視窗 (Task List Explorer)"></a>工作清單視窗 (Task List Explorer)</h3><p>我們可以點選 <strong>View &gt; Task List</strong> 來打開工作清單視窗, 工作清單視窗中可以有篩選器或是關鍵字搜尋可以用, 很方便, 不需要用全域搜尋之類的方式找關鍵字.  </p>
<img src="/content/20181213-use-task-list-in-visual-studio/task-list-explorer.gif">  
<h3 id="自定義語彙"><a href="#自定義語彙" class="headerlink" title="自定義語彙"></a>自定義語彙</h3><p>我們可以在 <strong>Tools &gt; Options</strong> 中的 <strong>Task List</strong> 頁籤中增加自定義的語彙, 例如我們要加入一個語彙叫做 BadSmell, 用來表示程式碼中的壞味道, 方便之後重構或整理.  </p>
<blockquote>
<p>可以在 Task List 中改語彙的優先權(Piority), 但無法改名, 想要改名只能加上新的再刪掉舊的.  </p>
</blockquote>
<img src="/content/20181213-use-task-list-in-visual-studio/task-list-add.gif">  
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這篇也沒什麼特別難的, 主要是對於內建語彙的使用時機跟目的沒找到太多說明, 剛好有一本書有提到, 就稍微記一下, 而且自己平常很少用這個功能容易忘, 就順便備忘一下, 然後再順便試試一下用螢幕錄影轉 GIF 檔來說明操作流程的效果.</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://books.google.com.tw/books?id=XXtoCqnxXVUC&amp;printsec=frontcover&amp;hl=zh-TW#v=onepage&amp;q&amp;f=false" target="_blank" rel="noopener">Mastering Web Development with Microsoft Visual Studio 2005 (P.45-P.46)</a></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自訂 StyleCop 規則與測試方式]]></title>
      <url>/content/20181208-custom-stylecop-rules-and-testing.html</url>
      <content type="html"><![CDATA[<p>很多 .NET 開發人員對於 StyleCop 應該是不陌生, 它能有效地協助我們讓程式碼的風格保持一致, 預設的規則其實已經足夠了, 但有些團隊可能有自已的特殊編碼規範, 這些編碼規範甚至是跟預設的規則是衝突的, 這時候就需要自己寫規則來套用.  </p>
<p>這篇主要是針對自訂規則可能會面臨的問題所記錄的, 尤其是要怎麼測試這些規則沒寫錯, 所以對於一些 google 就可以很容易找到的部分只會簡單帶過, 另外由於 StyleCop 也滿大的, 所以有些太細的設定或是內部運作這篇也不打算深入探索, 等之後有需要或是有興趣再根據各個主題或面向來專題探討.  </p>
<a id="more"></a>
<h3 id="安裝-StyleCop"><a href="#安裝-StyleCop" class="headerlink" title="安裝 StyleCop"></a>安裝 StyleCop</h3><p>安裝 StyleCop 的方式隨便問一下 google 大師就有很多教學了, 可以從 NuGet 找到 StyleCop.Analyzers 裝在各自專案上也可以從 Tools &gt; Extensions and Updates 找到 StyleCop 裝到本機電腦上, 我會比較推薦從 Extensions and Updates 裡面裝, 因為只有需要裝一個 StyleCop 擴充元件就能夠套用到所有的專案上, 各專案只需要編輯各自的設定檔就可以了, 非常方便.  </p>
<p>安裝後的目錄在 <code>C:\Users\{username}\AppData\Local\Microsoft\VisualStudio\{version}\Extensions\{key}</code> 中, 其中 username 是本機使用者登入的名稱, version 是 visual studio 的版本號, key 是隨機產生的, 如果安裝很多擴充元件的話要一個個點進去找一下才知道哪個是 StyleCop 的.  </p>
<h3 id="使用-StyleCop"><a href="#使用-StyleCop" class="headerlink" title="使用 StyleCop"></a>使用 StyleCop</h3><p>都是 visual studio 上面點一點就好的, 教學資源也極多, 基本的使用就不多說了.  </p>
<h4 id="編輯-StyleCop-設定檔"><a href="#編輯-StyleCop-設定檔" class="headerlink" title="編輯 StyleCop 設定檔"></a>編輯 StyleCop 設定檔</h4><p>編輯 StyleCop 設定檔的方式一般只要從 visual studio 上開啟圖形介面就可以編輯專案要用的設定了, 另外一種方式是使用 StyleCop 的安裝目錄 (如上一段所說的位置) 中的 StyleCop.SettingsEditor.exe 來編輯, 雙擊設定檔或是用命令提示字元下 <code>StyleCop.SettingsEditor.exe Settings.StyleCop</code> 指令就可以, 其中 Settings.StyleCop 是設定檔的路徑, 這個工具是用來編輯設定檔的, 所以不能建立一個新的設定檔, 要編輯的設定檔也必須是符合規定的格式, 不然讀取會錯誤.  </p>
<p>比起在 visual studio 中開啟圖形介面編輯設定檔, 用工具編輯雖然看起來不實用, 但是在需要製作很多份不同設定檔的時候卻很適合 (例如要測試自訂規則的驗證結果時), 這部分後面會說.  </p>
<blockquote>
<p>如果覺得 StyleCop.SettingsEditor.exe 不能建立一個新的設定檔很不方便, 可以把原始碼 fork 出來, 自己改造成適用的小工具.  </p>
</blockquote>
<h3 id="自訂規則"><a href="#自訂規則" class="headerlink" title="自訂規則"></a>自訂規則</h3><p>自訂規則的部分步驟還不少, 而且很多情況下做錯也不會跳錯誤訊息, 所以花了不少時間在 try and error 上, <a href="https://github.com/ronsun/ExtendedStyleCopRules" target="_blank" rel="noopener">我在 GitHub 上面有放了一個簡單的自訂規則的專案 - ExtendedStyleCopRules</a>, 這一段的說明會以這個專案的內容當作範例.  </p>
<h4 id="依賴組件"><a href="#依賴組件" class="headerlink" title="依賴組件"></a>依賴組件</h4><p>有幾個需要依賴的組件</p>
<ul>
<li>StyleCop</li>
<li>StyleCop.CSharp</li>
</ul>
<p>依賴的組件可以選擇從 NuGet 裝, 也可以直接依賴到前面從 Extensions and Updates 裝好的 StyleCop 的安裝目錄下, <strong>這邊是建議直接從 NuGet 裝</strong>, 因為 StyleCop 擴充元件的安裝資料夾名稱是隨機的, 換台電腦就找不到引用了, 很難管理.  </p>
<p>另外這邊要注意一下, 依賴的組件如果是從 NuGet 抓的, 必須跟從 Extensions and Updates 上安裝的 StyleCop 版號一致, 例如: 如果我從 Extensions 上安裝 StyleCop 6.0, 開發自訂規則時依賴的是從 NuGet 上面安裝的 StyleCop, 這樣編譯出來的組件無法讓 StyleCop 正確載入.  </p>
<h4 id="規則設定檔"><a href="#規則設定檔" class="headerlink" title="規則設定檔"></a>規則設定檔</h4><p>要讓 StyleCop 能夠將自定規則的相關設定放在設定頁面, 需要一個 xml 格式的設定檔, 並將這個檔案屬性設定為編譯成 Embedded Resource, 這邊以 ExtendedNamingRules.xml 以及一張設定截圖為例.  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">SourceAnalyzer</span> <span class="attr">Name</span>=<span class="string">"Extend Naming Rules"</span> <span class="attr">xmlns</span>=<span class="string">"https://github.com/ronsun/ExtendedStyleCopRules"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Description</span>&gt;</span></span><br><span class="line">    Extended naming rules.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Rule</span> <span class="attr">Name</span>=<span class="string">"PrivateFieldNamesMustStartWithUnderscore"</span> <span class="attr">CheckId</span>=<span class="string">"EA1301"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Context</span>&gt;</span>Private filed name must start with Underscore<span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Description</span>&gt;</span>Validates that names of private field must start with an underscore.<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Rule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Rules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SourceAnalyzer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/content/20181208-custom-stylecop-rules-and-testing/customer-rules-setting.png"> 
<ul>
<li><code>xmlns=&quot;....&quot;</code> : 非必要, 只是沒有自動提示 (IntelliSense) 要寫這些 XML 太難過了, 所以自己刻了一個 <a href="https://github.com/ronsun/ExtendedStyleCopRules/blob/master/src/ExtendedStyleCopRules/SourceAnalyzer.xsd" target="_blank" rel="noopener">SourceAnalyzer.xsd</a> 來引用.  </li>
<li><code>Name=&quot;Extend Naming Rules&quot;</code> : 這個 SourceAnalyzer 的名字, 會顯示在圖中 A 點.  </li>
<li><code>&lt;Description&gt;Extended naming rules.&lt;/Description&gt;</code> : 這個 SourceAnalyzer 的描述, 點擊圖中 A 點時會顯示在圖中 C 點的位置.  </li>
<li><code>Name=&quot;PrivateFieldNamesMustStartWithUnderscore&quot;</code> : 規則名字, 顯示在圖中 B 點, 必須是大寫字母開頭.  </li>
<li><code>CheckId=&quot;EA1301&quot;</code> : 規則代號, 圖中 B 點, 也是違反規則時顯示在結果視窗中的代號, 必須是兩個大寫字母加四個數字.  </li>
<li><code>&lt;Context&gt;.....&lt;/Context&gt;</code> : 提示訊息, 違反規則時顯示在結果視窗中的訊息之一.  </li>
<li><code>&lt;Description&gt;Validates that names...&lt;/Description&gt;</code> : 規則描述, 點擊圖中 B 點時會顯示在圖中 C 點的位置.  </li>
</ul>
<blockquote>
<p>其實這個 XML 可以很複雜, 這個範例只是最簡單的情境, StyleCop 的官方文件區也有一些簡易說明, 不過如果要完整的內容的話, 可能需要去整合 StyleCop 所有規則的設定檔, 或是直接爬程式碼分析 XML 的完整結構了.  </p>
</blockquote>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><p>先上程式碼再來慢慢說明.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SourceAnalyzer(typeof(CsParser))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtendedNamingRules</span> : <span class="title">SourceAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AnalyzeDocument</span>(<span class="params">CodeDocument document</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CsDocument csdocument = (CsDocument)document;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (csdocument.RootElement != <span class="literal">null</span> &amp;&amp; !csdocument.RootElement.Generated)</span><br><span class="line">        &#123;</span><br><span class="line">            csdocument.WalkDocument(<span class="keyword">new</span> CodeWalkerElementVisitor&lt;<span class="keyword">object</span>&gt;(VisitElement));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">VisitElement</span>(<span class="params">CsElement element, CsElement parentElement, <span class="keyword">object</span> context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// not target element</span></span><br><span class="line">        <span class="keyword">if</span> (element.Generated ||</span><br><span class="line">            element.ElementType != ElementType.Field ||</span><br><span class="line">            element.AccessModifier != AccessModifierType.Private)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!element.Declaration.Name.StartsWith(<span class="string">"_"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            AddViolation(element, Rules.PrivateFieldNamesMustStartWithUnderscore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StyleCop 是把原始碼拆解成 Element, Statement 和 Expression, 然後走訪所有節點並根據委派方法決定驗證邏輯與行為.  </p>
<p>這個類別需要使用 SourceAnalyzer 這個 Attribute 並繼承 SourceAnalyzer 後覆寫相關的分析方法 <code>void AnalyzeDocument(CodeDocument document)</code>, 接著 <code>WalkDocument(...)</code> 這邊會開始走訪所有程式碼, 然後根據委派方法 <code>VisitElement(...)</code> 來判定違規與否以及添加違規訊息等, 另外 WalkDocument 方法還有其他多載能另外多帶兩個參數, 是用來驗證 Statement 和 Expression 的委派方法.  </p>
<blockquote>
<p>後來在 Element, Statement 和 Expression 外又多了一個 QueryClause, 看起來是針對 LINQ 語句做的, 例如 <code>var q = from prod in db.Prodcut where prod.Category == &quot;shoes&quot;</code>, WalkDocument 方法有一個多載提供委派方法 queryClauseCallback, 用途和其他委派應該差不多.  </p>
</blockquote>
<p>在刻這些規則時發現, 對於複雜一點的規則很難下手, 其中一個原因是不知道 StyleCop 是把程式碼拆解成什麼樣子, 驗證時需要用的拆解後的程式碼片段也不知道從哪裡得到, 這時候一個方法是去看 StyleCop 的原始碼, 或是偷懶一點, 利用測試在 debug 模式下看 CsDocument 的完整結構與相對應的值, 測試的方式後面會提到.  </p>
<h4 id="測試自訂規則"><a href="#測試自訂規則" class="headerlink" title="測試自訂規則"></a>測試自訂規則</h4><p>這個測試的目的是測試自訂規則是不是能正確驗證程式碼, 比較像整合測試.  </p>
<p>這邊的範例需要依賴一些組件, 從 NuGet 安裝即可</p>
<ul>
<li>StyleCop (必要)</li>
<li>NUnit (測試框架)</li>
<li>FluentAssertions (Assert 用的套件)</li>
</ul>
<p>下面是主要的程式碼片段與說明<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestFixture()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtendedStyleCopRulesTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestCaseSource(nameof(TestCase_RuleTest))</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RuleTest</span>(<span class="params"><span class="keyword">string</span> checkId, StyleCopViolations expectedValidationResult</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// arrange</span></span><br><span class="line">        Directory.CreateDirectory(Locations.ValidationResultDirectory);</span><br><span class="line">        <span class="keyword">string</span> validationResultPath = Path.Combine(Locations.ValidationResultDirectory, <span class="string">$"<span class="subst">&#123;checkId&#125;</span>.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> ruleSettingPath = Path.Combine(Locations.TestDataDirectory, checkId, <span class="string">$"<span class="subst">&#123;checkId&#125;</span>.StyleCop"</span>);</span><br><span class="line">        <span class="keyword">string</span> codePath = Path.Combine(Locations.TestDataDirectory, checkId, <span class="string">$"<span class="subst">&#123;checkId&#125;</span>.cs"</span>);</span><br><span class="line"></span><br><span class="line">        CodeProject project = <span class="keyword">new</span> CodeProject(</span><br><span class="line">            checkId.GetHashCode(),</span><br><span class="line">            Locations.BaseDirectory,</span><br><span class="line">            <span class="keyword">new</span> Configuration(<span class="literal">null</span>),</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        StyleCopConsole console = <span class="keyword">new</span> StyleCopConsole(</span><br><span class="line">            ruleSettingPath,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            validationResultPath,</span><br><span class="line">            Locations.AddInDirectory,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            Locations.BaseDirectory);</span><br><span class="line"></span><br><span class="line">        console.Core.Environment.AddSourceCode(project, codePath, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// act</span></span><br><span class="line">        console.Start(<span class="keyword">new</span> CodeProject[] &#123; project &#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        StyleCopViolations actualValidationResult;</span><br><span class="line">        <span class="keyword">using</span> (Stream s = <span class="keyword">new</span> FileStream(validationResultPath, FileMode.Open))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(StyleCopViolations));</span><br><span class="line">            actualValidationResult = (StyleCopViolations)serializer.Deserialize(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert</span></span><br><span class="line">        <span class="keyword">bool</span> testDataExist = File.Exists(ruleSettingPath) &amp;&amp; File.Exists(codePath);</span><br><span class="line">        testDataExist.Should().BeTrue();</span><br><span class="line">        actualValidationResult.ViolationItems.Should().BeEquivalentTo(expectedValidationResult.ViolationItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;<span class="keyword">object</span>[]&gt; TestCase_RuleTest()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> expectedValidationResult = <span class="keyword">new</span> StyleCopViolations() &#123; &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="keyword">object</span>[]&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            EA1301TestResource()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span>[] <span class="title">EA1301TestResource</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> checkId = <span class="string">"EA1301"</span>;</span><br><span class="line">        <span class="keyword">var</span> expectedValidationResult = <span class="keyword">new</span> StyleCopViolations()</span><br><span class="line">        &#123;</span><br><span class="line">            ViolationItems = <span class="keyword">new</span> List&lt;StyleCopViolations.Violation&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> StyleCopViolations.Violation()</span><br><span class="line">                &#123;</span><br><span class="line">                    LineNumber = <span class="string">"7"</span>,</span><br><span class="line">                    RuleNamespace = <span class="string">"ExtendedStyleCopRules.NamingRules.ExtendedNamingRules"</span>,</span><br><span class="line">                    Rule = Rules.PrivateFieldNamesMustStartWithUnderscore.ToString(),</span><br><span class="line">                    RuleId = checkId</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; checkId, expectedValidationResult &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>測試的部分是參考 StyleCope 原始碼中的測試專案, 其實主要功能 StyleCop 都有提供, 也就是上面程式碼中的 CodeProject 和 StyleCopConsole, 這一句 <code>console.Start(new CodeProject[] { project }, true)</code> 執行後會根據指定的程式碼檔案 (<code>codePath</code>) 以及套用的 StyleCop 規則 (<code>ruleSettingPath</code>) 健行驗證, 並將檢查結果輸出成 XML 存檔到指定位置 (<code>validationResultPath</code>), 接著我們再讀取檢查結果驗證是否符合預期.  </p>
<p>完整測試程式碼可以看 <a href="https://github.com/ronsun/ExtendedStyleCopRules/tree/master/src/ExtendedStyleCopRules.Tests" target="_blank" rel="noopener">GitHub</a>  </p>
<blockquote>
<p>其實 StyleCop 的測試專案是連預期驗證結果都寫成 XML 了, 比這個複雜多了, 不過以自己的小專案來說, 還是先簡單就好, 等規則多到像 StyleCop 那樣再說 (應該不可能).  </p>
</blockquote>
<h4 id="套用規則"><a href="#套用規則" class="headerlink" title="套用規則"></a>套用規則</h4><p>編譯好, 把 dll 放到 StyleCop 擴充元件的安裝目錄下, 然後重開 visual studio 就可以了.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>StyleCop 教學資源多集中在說明怎麼使用, 自訂規則的文章也不少, 但有提到測試的很少了, 所以乾脆直接跳進去看 StyleCop 內建的規則和測試是怎麼寫的, 順便整理了一下相關的 XML 規格刻個 XSD 來輔助使用, 而且測試的部分能協助我們在偵錯模式下去看被 StyleCop 拆解後的程式碼, 也更容易知道怎麼判斷程式碼是否違規.  </p>
<p>以往沒看套件原始碼的習慣, 雖然剛開始看覺得很有障礙, 不過當作觀摩練習也是不錯.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://www.tenlong.com.tw/products/9781782169543?list_name=srh" target="_blank" rel="noopener">Instant Stylecop Code Analysis How-to (書)</a><br><a href="https://github.com/StyleCop/StyleCop" target="_blank" rel="noopener">StyleCop</a><br><a href="https://sites.google.com/a/rees.biz/main/Home/customstylecoprules" target="_blank" rel="noopener">How to Implement a Custom StyleCop Rule</a><br><a href="https://www.codeproject.com/Articles/30762/C-Code-Reviews-using-StyleCop-Detailed-Article?msg=2803242#StyleCopCodeparsinglogic" target="_blank" rel="noopener">C# Code Reviews using StyleCop – Detailed Article</a><br><a href="http://www.lovethedot.net/2008/05/creating-custom-rules-for-microsoft.html" target="_blank" rel="noopener">Part I: Creating Custom Rules for Microsoft Source Analyzer</a><br><a href="http://www.lovethedot.net/2008/05/creating-custom-rules-for-microsoft_27.html" target="_blank" rel="noopener">Part II: Creating Custom Rules for Microsoft Source Analyzer</a><br><a href="http://www.lovethedot.net/2008/05/creating-custom-rules-for-microsoft_6976.html" target="_blank" rel="noopener">Part III: Creating Custom Rules for Microsoft Source Analyzer</a>  </p>
<blockquote>
<p>有些資料比較久了, 小細節和現在不一定相同, 不過說明很詳細, 對於了解 StyleCop 是很有幫助的</p>
</blockquote>
<hr>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[XmlSerializer 的序列化/反序列化 與 BOM]]></title>
      <url>/content/20181203-xml-serialize-deserialize.html</url>
      <content type="html"><![CDATA[<p>XmlSerializer 提供許多序列化和反序列化相關的多載, 都有各自的優缺點, 例如有些方式在某些編碼下會因為 BOM(byte order mark) 出現在開頭而導致反序列化出現 Exception 或是序列化出含有 BOM 的字串導致接收端無法成功解析, 而各種方式的彈性與易用性都略有不同, 所以稍微記錄幾種序列化和反序列化的方式與特徵.</p>
<a id="more"></a>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="XmlWriter"><a href="#XmlWriter" class="headerlink" title="XmlWriter"></a>XmlWriter</h4><p>這種做法最有彈性, 可以靠著改變 XmlWriterSettings 以及 XmlSerializerNamespaces 的設定去控制序列化出來的 XML 字串的格式與內容, 但要特別注意的是 XmlWriterSettings 預設是有 BOM 的 UTF-8 編碼, 如果接收資料的一方無法處理這種格式的話, 需要特別將 XmlWriterSettings.Encoding 設成無 BOM 的編碼格式, 例如: <code>var ws = new XmlWriterSettings() { Encoding = new UTF8Encoding() }</code>, 比較適合用在需要跟許多不同外部系統介接的模組上</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Serialize</span>(<span class="params">Encoding encoding</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(MyModel));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ws = <span class="keyword">new</span> XmlWriterSettings()</span><br><span class="line">	&#123;</span><br><span class="line">		Encoding = encoding</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ns = <span class="keyword">new</span> XmlSerializerNamespaces(<span class="keyword">new</span> XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> xw = XmlWriter.Create(ms, ws))</span><br><span class="line">	&#123;</span><br><span class="line">		serializer.Serialize(xw, <span class="keyword">new</span> MyModel(), ns);</span><br><span class="line">		<span class="keyword">return</span> ws.Encoding.GetString(ms.ToArray());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StreamWriter"><a href="#StreamWriter" class="headerlink" title="StreamWriter"></a>StreamWriter</h4><p>這種做法彈性小了一點, 只能用 XmlSerializerNamespaces 來控制 namespace, 比較難透過設定參數來改變輸出格式和內容, 但本例還是可以透過改變參數 encoding 自己決定編碼格式, 且另外一個建構子多載 <code>StreamWriter(Stream)</code> 預設就是無 BOM 的 UTF-8, 比起使用 XmlWriter 能更直覺的避免序列化時產生 BOM.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Serialize</span>(<span class="params">Encoding encoding</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(MyModel));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ns = <span class="keyword">new</span> XmlSerializerNamespaces(<span class="keyword">new</span> XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> sw = <span class="keyword">new</span> StreamWriter(ms, encoding)) <span class="comment">// 2nd arg default to utf-8 no BOM</span></span><br><span class="line">	&#123;</span><br><span class="line">		serializer.Serialize(sw, <span class="keyword">new</span> MyModel(), ns);</span><br><span class="line">		<span class="keyword">return</span> encoding.GetString(ms.ToArray());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>這種做法彈性就更小了, 只能用 XmlSerializerNamespaces 來控制 namespace, 除了比較難透過設定參數來改變輸出格式和內容外, 參數 <code>ecoding</code> 也只能是 UTF-8, 但另一方面, 程式碼比較簡短且序列化出來的 XML 字串不會有 BOM, 用在不需要跟外部系統介接的模組上非常適合.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Serialize</span>(<span class="params">Encoding encoding</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(MyModel));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ns = <span class="keyword">new</span> XmlSerializerNamespaces(<span class="keyword">new</span> XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">	&#123;</span><br><span class="line">		serializer.Serialize(ms, <span class="keyword">new</span> MyModel(), ns);</span><br><span class="line">		<span class="keyword">return</span> encoding.GetString(ms.ToArray());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h4><p>這種跟直接使用 Stream 的做法差不多都不容易改輸出格式和內容, 優點也一樣是簡短清晰且不用考慮 BOM 的問題, 而用 StringBuilder 比上面用 Stream 多了一個特性是連編碼格式都不用考慮, 同樣適合用在不需要跟外部系統介接的模組上. </p>
<blockquote>
<p>StringBuilder 預設的編碼格式是 UTF-16</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Serialize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(MyModel));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ns = <span class="keyword">new</span> XmlSerializerNamespaces(<span class="keyword">new</span> XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> sw = <span class="keyword">new</span> StringWriter(sb))</span><br><span class="line">	&#123;</span><br><span class="line">		serializer.Serialize(sw, <span class="keyword">new</span> MyModel(), ns);</span><br><span class="line">		<span class="keyword">return</span> sb.ToString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h4><p>每種做法都有各自的優缺點, 需要在輸出格式上滿足各種情境的話, 用 XmlWriter 操作是最適合的, 如果編碼與輸出格式單一且幾乎不會改變的話, 用 Stream 或 StringWriter 處理會更好懂. 如果使用 XmlWriter 或是 SreamWriter 兩個範例操作的話要注意序列化出來的內容是否有 BOM, 尤其是需要跟外部系統介接時.</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="XmlReader"><a href="#XmlReader" class="headerlink" title="XmlReader"></a>XmlReader</h4><p>XmlReader 是提供最多參數的方式, <code>XmlReader.Create(Stream, XmlReaderSettings)</code> 和 XmlReader.Create(TextReader, XmlReaderSettings) 的第二個參數有很多選項可以調整, 從方法定義可以看得出來 XmlReader.Create(…) 有很多多載可以用, 如果是從 Stream 讀取資料的話, 即使 XML 字串有 BOM 也不會出錯, 但如果從 StringReader 讀取, 在 XML 字串有 BOM 的情境下會拋出 Exception.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T DeSerialize_FromStream&lt;T&gt;(<span class="keyword">string</span> xml, Encoding encoding)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> xmlBytes = encoding.GetBytes(xml);</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream(xmlBytes))</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> xr = XmlReader.Create(ms))</span><br><span class="line">	&#123;</span><br><span class="line">		xr.Read();</span><br><span class="line">		<span class="keyword">var</span> result = serializer.Deserialize(xr);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T DeSerialize_FromStringReader&lt;T&gt;(<span class="keyword">string</span> xml)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StringReader(xml))</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> xr = XmlReader.Create(sr))</span><br><span class="line">	&#123;</span><br><span class="line">		xr.Read();</span><br><span class="line">		<span class="keyword">var</span> result = serializer.Deserialize(xr);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StreamReader-Stream"><a href="#StreamReader-Stream" class="headerlink" title="StreamReader / Stream"></a>StreamReader / Stream</h4><p>這兩種方式差不多, 即使 XML 字串有 BOM 也都不會出錯, 只差在 StreamReader 建構子的參數比較多, 如果對編碼格式沒特別的需求的話, 直接操作 Stream 比較單純.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T DeSerialize_StreamReader&lt;T&gt;(<span class="keyword">string</span> xml, Encoding encoding)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> xmlBytes = encoding.GetBytes(xml);</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream(xmlBytes))</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> tr = <span class="keyword">new</span> StreamReader(ms, encoding))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> result = serializer.Deserialize(tr);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T DeSerialize_Stream&lt;T&gt;(<span class="keyword">string</span> xml, Encoding encoding)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> xmlBytes = encoding.GetBytes(xml);</span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream(xmlBytes))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> result = serializer.Deserialize(ms);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h4><p>這種方法在 XML 字串有 DOM 的時候會出 Exception, 優點是不用考慮編碼格式, 只需要知道 XML 字串就可以了. </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T DeSerialize&lt;T&gt;(<span class="keyword">string</span> xml)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StringReader(xml))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> result = serializer.Deserialize(sr);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h4><p>反序列化大部分的做法都很簡單, 以目前實驗看來, 把 XML 字串先轉成 Stream 再處理都可以相容有 BOM 的資料來源, 需要考量的點似乎也比序列化時少很多.</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這篇只是要實驗各種序列化與反序列化的方式遇到 BOM 時候的結果, 所以沒有特別實驗各種不同方式在其他複雜的 XML 資料下的轉換結果, 如果之後有遇到其他問題的話再回來補.  </p>
<p>範例程式碼可參考 <a href="https://github.com/ronsun/Demo/tree/master/XmlSerializerAndBOM" target="_blank" rel="noopener">Demo</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[WebAPI 安全的取得 Request Body]]></title>
      <url>/content/20181118-webapi-get-request-body-safety.html</url>
      <content type="html"><![CDATA[<p>標題下的有點奇怪, 框架預設提供 Model Binding 來將請求內容(request body)綁定到參數中, 其實一般情境不需要手工去讀取它的. 但是之前遇到一個情境是需要在 ActionFilterAttribute 中取得請求內容並紀錄到日誌 (log) 中, 這時候問題就來了.  </p>
<a id="more"></a>
<p>先來段程式碼, 看起來很正常, 就是在 ActionFilterAttribute 中把請求內容抓出來, 然後記錄到日誌中收工, 但接下來有個問題…  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (Stream s = actionContext.Request.Content.ReadAsStreamAsync().Result)</span><br><span class="line">        <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(s))</span><br><span class="line">        &#123;</span><br><span class="line">            s.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">            <span class="keyword">var</span> body = sr.ReadToEnd();</span><br><span class="line">            <span class="comment">// Logging here...</span></span><br><span class="line">            logger.Info(body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面說到紀錄完日誌收工, 這時候我們回到 WebAPI 中的 Action 來看看下面這段程式碼, 可以看到 Action 中又再次讀取一次請求內容, 但是這次卻會拋出例外(exception), 這就是有問題的地方了.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">DemoActionFilter</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> data = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">using</span> (Stream s = Request.Content.ReadAsStreamAsync().Result)</span><br><span class="line">        <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(s))</span><br><span class="line">        &#123;</span><br><span class="line">            s.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">            data = sr.ReadToEnd();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Stream.Seek(0, SeekOrigin.Begin)</code> 是用來重置 stream 的讀取位置的, 也可以這樣寫 <code>Stream.Position = 0</code></p>
</blockquote>
<h3 id="不用-using"><a href="#不用-using" class="headerlink" title="不用 using"></a>不用 using</h3><p>簡單暴力的做法就是把 DemoActionFilterAttribute 中讀取時的 <code>using</code>拿掉, 這樣資源就不會被強制回收, 如下:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stream s = actionContext.Request.Content.ReadAsStreamAsync().Result;</span><br><span class="line">        StreamReader sr = <span class="keyword">new</span> StreamReader(s);</span><br><span class="line">        s.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">        <span class="keyword">string</span> body = sr.ReadToEnd();</span><br><span class="line">        <span class="comment">// Logging here...</span></span><br><span class="line">        logger.Info(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或是初始化 StreamReader 的時候要用參數最多的那個多載, 並把最後一個參數 leaveOpen 設成 true 讓 stream 本身在 StreamReader 釋放後不會被關閉, 但這樣還要特別去注意其他參數預設要填什麼有點麻煩, 而且也不確定 <code>ReadAsStreamAsync()</code> 這個方法使會不會建立一個新的 Stream 以及是否必須手動釋放 , 例如下面的範例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stream s = actionContext.Request.Content.ReadAsStreamAsync().Result;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StreamReader(s, Encoding.UTF8, <span class="literal">true</span>, <span class="number">1024</span>, <span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            s.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">            <span class="keyword">string</span> body = sr.ReadToEnd();</span><br><span class="line">            <span class="comment">// Logging here...</span></span><br><span class="line">            logger.Info(body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這兩種做法雖然是能讓程式碼能成功運作, 但是既然這些類別有實作 IDisposable 來允許使用 using 來提早回收資源, 在不完全確定這些資源能被 GC 即時回收的情況下, 冒然把 using 拆掉似乎不是首選.</p>
<h3 id="改用-ReadAsStringAsync"><a href="#改用-ReadAsStringAsync" class="headerlink" title="改用 ReadAsStringAsync"></a>改用 ReadAsStringAsync</h3><p>這是最簡短的作法, 且這樣做在 Action 中要再次讀取 Sream 時並不會出錯, 但是卻有個限制 - <strong>Action 不能有參數</strong>.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> body = actionContext.Request.Content.ReadAsStringAsync().Result;</span><br><span class="line">        <span class="comment">// Logging here...</span></span><br><span class="line">        logger.Info(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>從<a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf" target="_blank" rel="noopener">這張圖</a>可以看出, 如果 Action 有參數的話 (像是這樣 <code>public void Post(MyModel model)</code> ), 會先做 Model Binding (在圖中標註 C 點的地方) 然後才是做 ActionFilter, 所以當進到 ActionFilterAttribute 裡面時, 請求已經被讀取過了, 這時候讀出來的結果會是空字串.  </p>
<p>因此, 這種做法必須限制 Action 不能有參數, 但是只為了 ActionFilterAttribute 需要而限制的 Action 的實作方式是不合理的, 會造成未來擴展或維護上的困擾.  </p>
<h3 id="複製-Stream"><a href="#複製-Stream" class="headerlink" title="複製 Stream"></a>複製 Stream</h3><p>既然要讀取內容又不能把資源釋放掉, 不如直接複製一份出來讀取, 再釋放掉複製版的資源就好了.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (Stream s = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            actionContext.Request.Content.CopyToAsync(s);</span><br><span class="line">            <span class="comment">// need call it twice if model binding works</span></span><br><span class="line">            actionContext.Request.Content.CopyToAsync(s);</span><br><span class="line">            <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(s))</span><br><span class="line">            &#123;</span><br><span class="line">                s.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">                <span class="keyword">string</span> body = sr.ReadToEnd();</span><br><span class="line">                <span class="comment">// Logging here...</span></span><br><span class="line">                logger.Info(body);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前在某一本書上看到複製 stream 不好, 但當時沒有仔細看, 所以也不清楚為什麼不好, 不過倒是有在網路上找到一篇關於<a href="http://vunvulearadu.blogspot.com/2013/04/steamcopyto-performance-problems.html" target="_blank" rel="noopener">複製 stream 的效能問題</a>, 基本上是因為短時間大量資料湧入再加上資源來不及釋放, 導致記憶體用量飆高, 這邊的作法跟他提到的解法有點不同, 但原則都是盡早釋放資源.  </p>
<p>另外還有一個問題是, 這個做法如果跟 Model Binding 一起使用, <code>actionContext.Request.Content.CopyToAsync(s)</code> 要執行兩次才能才能正確的複製 stream, 推測跟 Stream.Position 有關但不知道怎麼證實.  </p>
<h3 id="內建的-Model-Binding"><a href="#內建的-Model-Binding" class="headerlink" title="內建的 Model Binding"></a>內建的 Model Binding</h3><p>或是換個方向, Action 必須帶參數且透過 Model Binding 綁定, 而 ActionFilterAttribute 中維持不動, Action 直接操作綁定好的物件就好, 但這樣 ActionFilterAttribute 中還是把資源釋放掉了, 就設計的角度來看我們不希望在一個通用方法 (DemoActionFilterAttribute) 中對全域的資源做一次性的使用, 因為無法預期這個資源是否會再次被使用.</p>
<h3 id="推薦-直接讀內建的屬性"><a href="#推薦-直接讀內建的屬性" class="headerlink" title="(推薦) 直接讀內建的屬性"></a>(推薦) 直接讀內建的屬性</h3><p>這個思考方向是, 那有沒有可能內建的 request 相關物件就有提供記錄著請求內容的 Stream 型別的屬性讓我們能直接讀取呢? 而內建的物件中的屬性, 我們可以合理預期不用手動去釋放相關的資源.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = (HttpContextBase)actionContext.Request.Properties[<span class="string">"MS_HttpContext"</span>];</span><br><span class="line">        <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[context.Request.InputStream.Length];</span><br><span class="line">        context.Request.InputStream.Read(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">        <span class="keyword">string</span> body = Encoding.UTF8.GetString(bytes);</span><br><span class="line">        <span class="comment">// Logging here...</span></span><br><span class="line">        logger.Info(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這個做法看起來是最合理的, 一方面可以在 ActionFilter 中讀取請求內容, 不用手動釋放資源所以不會破壞它, 這樣各個 Action 中如果有需要也可以再次讀取.   </p>
<p>另外, 讀取 InputStream 的方式也可以搭配 StreamReader, 要特別帶入 leaveOpen 參數避免把 InputStream 關閉了, 比較麻煩, 例如下面的範例  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoActionFilterAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = (HttpContextBase)actionContext.Request.Properties[<span class="string">"MS_HttpContext"</span>];</span><br><span class="line">        context.Request.InputStream.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StreamReader(context.Request.InputStream, Encoding.UTF8, <span class="literal">true</span>, <span class="number">1024</span>, <span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> body = sr.ReadToEnd();</span><br><span class="line">            <span class="comment">// Logging here...</span></span><br><span class="line">            logger.Info(body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這是工作上遇到的問題, 研究一番後解是解了, 不過畢竟沒有完全了解底層的運作, 最後的解法是不是好的方法還很難說, 可能之後有空或是又踩到什麼相關問題再來仔細深究了.<br>另外前面幾種解法雖然看起來都有些缺陷, 但也不全然是不好, 只是說在這個情境下不太適合而已.  </p>
<p>重置讀取位置這個行為在要讀取的 stream 已經被讀過時要做, 但前面的範例中, 某些情境下要讀取的 stream 不一定已經被讀過, 這個就看各人是習慣不論如何只要讀 stream 都重置讀取位置, 還是只在必要重置的時候重置了.</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/questions/21351617/web-api-request-content-is-empty-in-action-filter" target="_blank" rel="noopener">Web Api Request Content is empty in action filter</a><br><a href="http://vunvulearadu.blogspot.com/2013/04/steamcopyto-performance-problems.html" target="_blank" rel="noopener">Steam.CopyTo - Performance problems</a><br><a href="https://stackoverflow.com/questions/48564634/leave-streamreader-without-closing-stream" target="_blank" rel="noopener">Leave StreamReader without closing Stream</a></p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[XmlWriterSettings.Encoding 設定無效]]></title>
      <url>/content/20181101-xmlwritersettings-encoding-not-working.html</url>
      <content type="html"><![CDATA[<p>最近在寫一個比較方便使用的工具方法來做 XML 的序列化的時候, 發生了一個神奇的問題, <code>XmlWriterSettings.Encoding</code> 預設應該是 UTF-8, 但是轉出來的 XML 卻是 UTF-16, 這就奇了怪了…</p>
<a id="more"></a>
<h3 id="XmlWriterSettings-Encoding-設定無效"><a href="#XmlWriterSettings-Encoding-設定無效" class="headerlink" title="XmlWriterSettings.Encoding 設定無效"></a>XmlWriterSettings.Encoding 設定無效</h3><p>先來看下面這段 Demo<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">DemoForFailure</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xmlWriterSettings = <span class="keyword">new</span> XmlWriterSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> xmlWriter = XmlWriter.Create(sb, xmlWriterSettings))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="keyword">string</span>)).Serialize(xmlWriter, <span class="keyword">string</span>.Empty);</span><br><span class="line">        <span class="keyword">return</span> sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程式碼就是很簡單的把一個空字串拿去序列化, 但是輸出的字串卻是 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot;?&gt;&lt;string /&gt;</code>, 即使特別再手動設定 Encoding 也是一樣, 如: <code>var xmlWriterSettings = new XmlWriterSettings() { Encoding = Encoding.UTF8 };</code></p>
<p>稍微推敲一下程式碼, 猜測應該是 <code>StringBulider</code> 的問題, 可能是因為 <code>StringBulider</code> 操作字串有自己的 Encoding, 所以就往這方面去找.</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因為<del>今天比較懶</del>不想自己往底部去鑽, 所以先問問 google 大神先, 也是運氣好還真的有找到<a href="https://blogs.msdn.microsoft.com/kaevans/2008/08/11/xmlwritersettings-encoding-being-ignored/" target="_blank" rel="noopener">一篇分析文</a>, 大意上就是 <code>StringBuilder</code> 設計上是直接操作字元而不是 bytes, 而字串在 .NET 裡面都是 UTF-16 編碼的.</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>所以這邊改用存取 Stream 的方式來操作, 如下<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">DemoForSuccess</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xmlWriterSettings = <span class="keyword">new</span> XmlWriterSettings() &#123; Encoding = Encoding.UTF8 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StreamReader(ms))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> xmlWriter = XmlWriter.Create(ms, xmlWriterSettings))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="keyword">string</span>)).Serialize(xmlWriter, <span class="keyword">string</span>.Empty);</span><br><span class="line">        ms.Position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sr.ReadToEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>也沒什麼特別的技巧好結論, 特別寫出來只是怕之後忘記, 再遇到還要再踩一次.</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://blogs.msdn.microsoft.com/kaevans/2008/08/11/xmlwritersettings-encoding-being-ignored/" target="_blank" rel="noopener">XmlWriterSettings Encoding Being Ignored?</a></p>
<hr>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[WebApi 2 中的 FilterAttribute 介紹與應用]]></title>
      <url>/content/20180923-filters-of-webapi2.html</url>
      <content type="html"><![CDATA[<p>ASP.NET WebApi 2 提供了三個好用的 FilterAttribute 讓開發者可以擴充後將這些 FilterAttribute 套用在 Controller / Action 上面, 也可以在 WebApiConfig.cs 或 Global.asax 裡面註冊 , 並在一個 API request 生命週期中的特定時間被執行.<br>這樣做的好處是可以將跟 API 主業務邏輯無關, 卻又是大部分 API 都要做的事收斂起來, 只需要將 Attribute 套用在正確的地方就能一體適用, 開發者就能更專注在 API 的主要商務邏輯層面.  </p>
<blockquote>
<p>在了解 FilterAttribute 的運用之前, 必須先知道  Attribute 是什麼以及如何使用 Attribute.</p>
</blockquote>
<a id="more"></a>
<h3 id="三種-FilterAttribute-介紹"><a href="#三種-FilterAttribute-介紹" class="headerlink" title="三種 FilterAttribute 介紹"></a>三種 FilterAttribute 介紹</h3><p>ASP.NET WebApi 2 提供了三個好用的 FilterAttribute, 分別是 <code>AuthorizationFilterAttribute</code>,  <code>ActionFilterAttribute</code> 與 <code>ExceptionFilterAttribute</code> , 要注意的是命名空間都是 <code>System.Web.Http.Filters</code>, ASP.NET MVC 也有提供同名的 FilterAttribute, 但是命名空間不同, 內容也不盡相同.  </p>
<p>這三個 FilterAttribute 提供的功能各異:  </p>
<ul>
<li><code>AuthorizationFilterAttribute</code> 提供的是驗證相關的流程, 能在進 Action 之前就先執行相關的驗證方法.   </li>
<li><code>ActionFilterAttribute</code> 會分別在 Action 執行前與執行完畢後執行相關方法.  </li>
<li><code>ExceptionFilterAttribute</code> 在例外(unhandled exception)發生後執行.  </li>
</ul>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>這三種 FilterAttribute 的使用方式都一樣, 這邊用 <code>ExceptionFilterAttribute</code> 來當作範例. </p>
<ol>
<li><p><strong>繼承對應的 FilterAttribute, 並覆寫父類別中的相關方法.</strong> </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoExceptionFilterAttribute</span> : <span class="title">ExceptionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnException</span>(<span class="params">HttpActionExecutedContext actionExecutedContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Call base method</span></span><br><span class="line">        <span class="keyword">base</span>.OnException(actionExecutedContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do somthing, ex: logging exception</span></span><br><span class="line">        <span class="comment">// _logger.Info(actionExecutedContext.Exception);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set response information</span></span><br><span class="line">        actionExecutedContext.Response = <span class="keyword">new</span> HttpResponseMessage(HttpStatusCode.InternalServerError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>套用 FilterAttribute.</strong></p>
<ul>
<li><p>套用到 Action</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DemoExceptionFilter</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>套用到特定 ApiController  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DemoExceptionFilter</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更進一步, 可以將這些 FilterAttribute 套用在一個共用的 BaseApiController 上, 只要繼承 BaseApiController, 就能直接套用.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DemoExceptionFilter</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseApiController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">BaseApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>套用到所有 ApiController - 從 <code>~/App_Start/WebApiConfig.cs</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~/App_Start/WebApiConfig.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">HttpConfiguration config</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    config.Filters.Add(<span class="keyword">new</span> DemoExceptionFilterAttribute());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>套用到所有 ApiController - 從<code>~/Global.asax</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~/Global.asax</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    GlobalConfiguration.Configuration.Filters.Add(<span class="keyword">new</span> DemoExceptionFilterAttribute());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>單獨套用只能套用在 ApiController 的衍生類別或 Action 上, 如果是套用在其他方法(例如: xxxService.Do(), 或 this.Do()), 即使那個方法有被 ApiController 的 Action 呼叫到也是無法讓 FilterAttribute 運作的.  </li>
<li>重複套用同一個 FilterAttribute 不會壞, 但因為註冊了兩次, 所以也會執行兩次, 所以應該要特別注意套用方式避免重複套用.  </li>
</ol>
</blockquote>
<h4 id="排除特定-Action-或-Controller"><a href="#排除特定-Action-或-Controller" class="headerlink" title="排除特定 Action 或 Controller"></a>排除特定 Action 或 Controller</h4><p>如果大部分 API 都需要套用一個 FilterAttribute, 但有少數不套用, 應該要怎麼實作排除機制呢?  </p>
<ol>
<li><p><strong>實作標記為排除的 Attribute</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IgnoreFilterAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Type FilterType &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IgnoreFilterAttribute</span>(<span class="params">Type filterType</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FilterType = filterType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>擴充 FilterAttribute 以支援排除功能</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoExceptionFilterAttribute</span> : <span class="title">ExceptionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnException</span>(<span class="params">HttpActionExecutedContext actionExecutedContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Func&lt;IgnoreFilterAttribute, <span class="keyword">bool</span>&gt; ignoreCheck = (r) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ignored type is one of...</span></span><br><span class="line">            <span class="comment">// 1. DemoExceptionFilterAttribute </span></span><br><span class="line">            <span class="comment">// 2. Base types of DemoExceptionFilterAttribute</span></span><br><span class="line">            <span class="keyword">return</span> r.FilterType.IsAssignableFrom(<span class="keyword">typeof</span>(DemoExceptionFilterAttribute));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ignoredActions = actionExecutedContext</span><br><span class="line">                                .ActionContext</span><br><span class="line">                                .ActionDescriptor</span><br><span class="line">                                .GetCustomAttributes&lt;IgnoreFilterAttribute&gt;()</span><br><span class="line">                                .Any(ignoreCheck);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ignoredControllers = actionExecutedContext</span><br><span class="line">                                    .ActionContext</span><br><span class="line">                                    .ControllerContext</span><br><span class="line">                                    .ControllerDescriptor</span><br><span class="line">                                    .GetCustomAttributes&lt;IgnoreFilterAttribute&gt;()</span><br><span class="line">                                    .Any(ignoreCheck);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ignoredActions || ignoredControllers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>套用標記為排除的 Attribute</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply to Controller</span></span><br><span class="line"><span class="comment">//[IgnoreFilter(typeof(DemoExceptionFilterAttribute))]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// apply to Action</span></span><br><span class="line">    [<span class="meta">IgnoreFilter(typeof(DemoExceptionFilterAttribute))</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="執行順序"><a href="#執行順序" class="headerlink" title="執行順序"></a>執行順序</h4><p>根據 <a href="https://exceptionnotfound.net/the-asp-net-web-api-2-http-message-lifecycle-in-43-easy-steps-2/" target="_blank" rel="noopener">The ASP.NET Web API 2 HTTP Message Lifecycle in 43 Easy Steps</a> 的說明加上 <a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf" target="_blank" rel="noopener">ASP.NET WEB API 2: HTTP MESSAGE LIFECYLE
</a> 流程圖的內容來看, <code>AuthorizationFilterAttribute</code> 會先執行, 然後才是 <code>ActionFilterAttribute</code>, 而例外發生時會執行<code>ExceptionFilterAttribute</code>, 至於同種類的多個 FilterAttribute 或是一個 FilterAttribute 中的不同方法執行的順序, 可以從下面的程式碼觀察出結果.  </p>
<p>首先, 需要 <code>AuthorizationFilterAttribute</code> 和 <code>ActionFilterAttribute</code> 各兩組, 另外一組 <code>ExceptionFilterAttribute</code>, 接著把這些 FilterAttribute 放在 WebApi 專案預設的 Action 上, 且 <code>ExceptionFilterAttribute</code> 刻意插在中間, 而 Action 就簡單的拋出一個例外.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">ApiController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// GET api/values</span></span><br><span class="line">    [<span class="meta">MyAuth2</span>]</span><br><span class="line">    [<span class="meta">MyAuth1</span>]</span><br><span class="line">    [<span class="meta">MyAction1</span>]</span><br><span class="line">    [<span class="meta">MyException1</span>]</span><br><span class="line">    [<span class="meta">MyAction2</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實作部分所有 FilterAttribute 並覆寫所有能覆寫的方法, 內容只是單純寫個簡單的歷程記錄到 <code>RouteTracer.Routes</code> 中, 但<code>ExceptionFilterAttribute</code> 需要另外負責回傳正確的狀態與 <code>RouteTracer.Routes</code> 內容, 才能順利觀察執行順序. </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyAuth1</span> : <span class="title">AuthorizationFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAuthorization</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAuth1.OnAuthorization"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnAuthorization(actionContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnAuthorizationAsync</span>(<span class="params">HttpActionContext actionContext, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAuth1.OnAuthorizationAsync"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.OnAuthorizationAsync(actionContext, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyAuth2</span> : <span class="title">AuthorizationFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAuthorization</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAuth2.OnAuthorization"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnAuthorization(actionContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnAuthorizationAsync</span>(<span class="params">HttpActionContext actionContext, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAuth2.OnAuthorizationAsync"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.OnAuthorizationAsync(actionContext, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyAction1</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">HttpActionExecutedContext actionExecutedContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction1.OnActionExecuted"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnActionExecuted(actionExecutedContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnActionExecutedAsync</span>(<span class="params">HttpActionExecutedContext actionExecutedContext, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction1.OnActionExecutedAsync"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.OnActionExecutedAsync(actionExecutedContext, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction1.OnActionExecuting"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnActionExecuting(actionContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnActionExecutingAsync</span>(<span class="params">HttpActionContext actionContext, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction1.OnActionExecutingAsync"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.OnActionExecutingAsync(actionContext, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyAction2</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">HttpActionExecutedContext actionExecutedContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction2.OnActionExecuted"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnActionExecuted(actionExecutedContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnActionExecutedAsync</span>(<span class="params">HttpActionExecutedContext actionExecutedContext, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction2.OnActionExecutedAsync"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.OnActionExecutedAsync(actionExecutedContext, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">HttpActionContext actionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction2.OnActionExecuting"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnActionExecuting(actionContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnActionExecutingAsync</span>(<span class="params">HttpActionContext actionContext, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyAction2.OnActionExecutingAsync"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.OnActionExecutingAsync(actionContext, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyException1</span> : <span class="title">ExceptionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnException</span>(<span class="params">HttpActionExecutedContext actionExecutedContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteTracer.Routes.Add(<span class="string">"MyException1.OnException"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnException(actionExecutedContext);</span><br><span class="line">        actionExecutedContext.Response = <span class="keyword">new</span> HttpResponseMessage(HttpStatusCode.OK);</span><br><span class="line">        actionExecutedContext.Response.Content = <span class="keyword">new</span> ObjectContent&lt;List&lt;<span class="keyword">string</span>&gt;&gt;(RouteTracer.Routes, <span class="keyword">new</span> XmlMediaTypeFormatter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實際運作後頁面顯示結果如下, 可以看出各種 FilterAttribute 以及其中的方法的執行順序.  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ArrayOfstring</span> <span class="attr">xmlns:i</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/2003/10/Serialization/Arrays"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAuth2.OnAuthorizationAsync<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAuth2.OnAuthorization<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAuth1.OnAuthorizationAsync<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAuth1.OnAuthorization<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction1.OnActionExecutingAsync<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction1.OnActionExecuting<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction2.OnActionExecutingAsync<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction2.OnActionExecuting<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction2.OnActionExecutedAsync<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction2.OnActionExecuted<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction1.OnActionExecutedAsync<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyAction1.OnActionExecuted<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyException1.OnException<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ArrayOfstring</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就執行順序的這部分, 總結來說  </p>
<ul>
<li><code>AuthorizationFilterAttribute</code> 先於 <code>ActionFilterAttribute</code> 執行 (從流程圖上來看合理).  </li>
<li>多個同種類的 FilterAttribute 實作, 會依照套用的順序執行, 但 <code>OnActionExecuted</code> 與 <code>OnActionExecutedAsync</code> 是反序 (從流程圖上來看也合理, 因為 OnActionExecuted 系列方法是在 Action 執行後要 response 時才執行).  </li>
<li>如果有例外發生的話, <code>ExceptionFilterAttribute</code> 會在最後才執行.  </li>
<li>一個 FilterAttribute 內部的方法執行順序看起來是非同步方法先於同步方法.  </li>
</ul>
<blockquote>
<ol>
<li>單一測試就下結論其實不穩妥, 所以我後來又做了幾次不一樣的排序實驗, 看起來結果是符合推測的, 但無法完全保證.  </li>
<li>有些特性可能會隨著版本的變遷改變, 如果實際專案要用, 又真的很在意這些順序或其他細節的話, 還是要再就實際狀況測試一輪.</li>
</ol>
</blockquote>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>想像一下, 當有一天團隊要導入 log 收集與分析工具, 需要統一 log 的格式時, 如果當初有用 FilterAtrribute 來印通用訊息就可以省下非常多瑣碎的工, 而例外處理也是同理, 且能避免到處都是為了抓 unhandled exception 而寫的 <code>try-catch</code> 語句.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://stackoverflow.com/questions/9953760/how-to-disable-a-global-filter-in-asp-net-mvc-selectively" target="_blank" rel="noopener">How to disable a global filter in ASP.Net MVC selectively</a><br><a href="https://www.huanlintalk.com/2013/01/aspnet-web-api-exception-filter.html" target="_blank" rel="noopener">ASP.NET Web API Exception Filter</a><br><a href="http://blogs.microsoft.co.il/oric/2011/10/28/exclude-a-filter/" target="_blank" rel="noopener">Exclude A Filter</a><br><a href="https://exceptionnotfound.net/the-asp-net-web-api-2-http-message-lifecycle-in-43-easy-steps-2/" target="_blank" rel="noopener">The ASP.NET Web API 2 HTTP Message Lifecycle in 43 Easy Steps</a><br><a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf" target="_blank" rel="noopener">ASP.NET WEB API 2: HTTP MESSAGE LIFECYLE
</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[安全的使用遞迴]]></title>
      <url>/content/20180915-use-recursive-safety.html</url>
      <content type="html"><![CDATA[<p>遞迴有一個很大的好處是能用非常簡短的程式碼達到相對複雜很多的功能, 一般來說可讀性高很多, 但也伴隨著一些問題, 例如不慎引發堆疊溢位(stack overflow), 這篇主要是要紀錄怎麼安全的使用遞迴.  </p>
<a id="more"></a>
<h3 id="堆疊溢位"><a href="#堆疊溢位" class="headerlink" title="堆疊溢位"></a>堆疊溢位</h3><p>.NET 中的 <code>StackOverflowException</code> 有兩種觸發情境, 一種是在程式碼中刻意拋出的, 像這樣: <code>throw new StackOverflowException()</code>, 這和一般的例外沒什麼差別, 只要有 catch 到就可以做後續處理, 但另一種真的因為堆疊溢位所引發的例外, 根據 <a href="https://msdn.microsoft.com/en-us/library/w6sxk224.aspx" target="_blank" rel="noopener">MSDN 的說明</a>是無法被 catch 的, 且經過實測發現問題發生時, <strong>程序會直接被終止</strong>.<br>堆疊溢位這個問題通常是由無限遞迴所引發的, 如果在 production 環境發生這個錯誤, 造成服務直停擺, 那真的會很悲劇.  </p>
<blockquote>
<p>其實就 MSDN 看來, 似乎有其他方式可以讓系統不要因為堆疊溢位而停擺, 但太深奧了看不懂, 另一方面來說, 會出現這個問題大多是因為 bug, 所以目前不打算深入去看這一塊.</p>
</blockquote>
<h3 id="防止堆疊溢位"><a href="#防止堆疊溢位" class="headerlink" title="防止堆疊溢位"></a>防止堆疊溢位</h3><h4 id="控制遞迴深度"><a href="#控制遞迴深度" class="headerlink" title="控制遞迴深度"></a>控制遞迴深度</h4><p>目前看到最簡明的方法是利用一個參數去紀錄目前堆疊的深度, 並在超過設定的最高深度時終止遞迴(或做其他相應的處理).<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo</span>(<span class="params"><span class="keyword">int</span> depth = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line"></span><br><span class="line">    Foo(++depth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="做好單元測試"><a href="#做好單元測試" class="headerlink" title="做好單元測試"></a>做好單元測試</h4><p>即使有控制遞迴深度, 但還是有可能會把控制深度的地方寫錯, 所以單元測試還是寫完整點才能多一層保障.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>雖然無限遞迴引發的問題比較嚴重, 但只要做好控制與測試, 其實遞迴還是很好用的, 比較需要在意的地方反而是因為遞迴相對抽象一點, 如果遞迴寫得太複雜的話, 後人會比較難維護.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://msdn.microsoft.com/en-us/library/w6sxk224.aspx" target="_blank" rel="noopener">MSDN: Troubleshooting Exceptions: System.StackOverflowException</a><br><a href="https://stackoverflow.com/questions/3871797/whats-a-good-general-way-of-catching-a-stackoverflow-exception-in-c" target="_blank" rel="noopener">What’s a good general way of catching a StackOverflow exception in C#?</a> - 最佳解下面的推文部分有提到看似有方法處理堆疊溢位, 但有點矯枉過正 (a bit overkill)  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 的自動實作屬性]]></title>
      <url>/content/20180909-auto-implemented-properties.html</url>
      <content type="html"><![CDATA[<p>自動實作屬性(auto implemented properties)是 C# 非常基本的規格, 雖然他跟 欄位(fileds) 使用上非常相似, 但本質上是不一樣的東西.<br>這篇主要是紀錄一些網路上的比較資訊以及自己好奇下做的一個小實驗, 沒什麼太特別的內容. </p>
<a id="more"></a>
<h3 id="欄位-屬性與自動實作屬性"><a href="#欄位-屬性與自動實作屬性" class="headerlink" title="欄位, 屬性與自動實作屬性"></a>欄位, 屬性與自動實作屬性</h3><p>先來看看官方對於<br><a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/fields" target="_blank" rel="noopener">欄位(fileds)</a>, <a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/properties" target="_blank" rel="noopener">屬性(properties)</a>與<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties" target="_blank" rel="noopener">自動實作屬性(auto implemented properties)</a>的介紹, 這部分的介紹與比較網路資料多到看不完, 我就懶得再多整理一次了. </p>
<blockquote>
<p>建議:  </p>
<ol>
<li>private 時使用欄位, 除此之外使用自動實作屬性. </li>
<li>如果需要對欄位進行自動實作屬性的預設行為以外的操作時, 使用屬性. </li>
</ol>
</blockquote>
<h3 id="自動實作屬性編譯後變什麼"><a href="#自動實作屬性編譯後變什麼" class="headerlink" title="自動實作屬性編譯後變什麼?"></a>自動實作屬性編譯後變什麼?</h3><p>根據官方與大量網路資料的說法, 自動實作屬性編譯後會產生兩個存(set)取(get)用的方法和一個欄位(backing field), 昨天剛好好奇想說能不能知道這兩個方法和欄位究竟長什麼樣子.<br>於是基於好奇, 就利用反射的方式在監看式(Watch)中去挖裡面的內容, 果然找到一些有用的東西, 整理後如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> property = <span class="keyword">typeof</span>(MyClass).GetProperty(<span class="string">"MyProperty"</span>);</span><br><span class="line">    <span class="keyword">var</span> runtimeField = <span class="keyword">typeof</span>(MyClass).GetRuntimeFields().First();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method name for get: get_MyProperty</span></span><br><span class="line">    Console.WriteLine(<span class="string">"method name for get: "</span> + property.GetMethod.Name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//method name for set: set_MyProperty</span></span><br><span class="line">    Console.WriteLine(<span class="string">"method name for set: "</span> + property.SetMethod.Name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for backing filed: &lt;MyProperty&gt;k__BackingField</span></span><br><span class="line">    Console.WriteLine(<span class="string">"name for backing filed: "</span> + runtimeField.Name);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然編譯後會產生這樣的兩個方法, 那如果我在 class 裡面刻意加上這兩個方法的話會如何呢?<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">get_MyProperty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_MyProperty</span>(<span class="params"><span class="keyword">string</span> val</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>果然, 編譯不會過, 出現這樣的錯誤<br><img src="/content/20180909-auto-implemented-properties/001.png">  </p>
<blockquote>
<p>本來還想試試看能不能弄出跟 backing field 衝突的欄位, 不過失敗了.</p>
</blockquote>
<p>其實這個實驗對於實作上沒什麼明顯的幫助, 不過有時候稍微追根究底一下也是有趣.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實欄位, 屬性與自動實作屬性的使用時機還滿明確的, 以往使用上也沒有特別難以抉擇的情境出現, 不過真的要回答 “為什麼這樣用?” 時, 還真回答不出來, 然後這邊順便放一下網路上對於這部分的文章  </p>
<ul>
<li><a href="http://csharpindepth.com/Articles/Chapter8/PropertiesMatter.aspx" target="_blank" rel="noopener">C# in Depth - Why Properties Matter</a>  </li>
<li><a href="https://dotblogs.com.tw/yc421206/archive/2011/06/06/27233.aspx" target="_blank" rel="noopener">使用 屬性(Property) 的好處</a>  </li>
<li><a href="https://social.msdn.microsoft.com/Forums/en-US/d479ffff-41da-40fe-9274-62a211ef3edd/difference-between-auto-implemented-properties-and-normal-public-member-variables?forum=csharplanguage" target="_blank" rel="noopener">Difference between Auto - Implemented Properties and normal public member variables</a>  </li>
<li><a href="https://softwareengineering.stackexchange.com/questions/161303/is-it-bad-practice-to-use-public-fields" target="_blank" rel="noopener">Is it bad practice to use public fields?</a></li>
<li><a href="https://stackoverflow.com/questions/34743533/automated-property-with-getter-only-can-be-set-why" target="_blank" rel="noopener">Automated property with getter only, can be set, why?</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[簡化 if 條件式]]></title>
      <url>/content/20180819-simplify-if-statement.html</url>
      <content type="html"><![CDATA[<p><code>if</code> 條件式很常用, 但在有時因為使用不當造成閱讀或維護上的困難, 尤其是巢狀的 if-else 條件式對維護上造成很大的負擔, 這其實是有一些小技巧可以簡化 <code>if</code> 條件式的, 當然, 這些技巧不是萬靈丹, 使用上還是有些細節要注意的.</p>
<a id="more"></a>
<h3 id="一般-if-條件式"><a href="#一般-if-條件式" class="headerlink" title="一般 if 條件式"></a>一般 if 條件式</h3><p>一般的 <code>if</code> 條件式其實沒什麼好簡化的, 但如果之後的<strong>處理邏輯很簡單</strong>或<strong>滿足特定情境</strong>的話, 還是有簡化的空間.</p>
<h4 id="三元運算子"><a href="#三元運算子" class="headerlink" title="三元運算子 ?:"></a>三元運算子 <code>?:</code></h4><p>先附上<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator" target="_blank" rel="noopener">官方文件</a>.  </p>
<p>三元運算子是基本規格也沒啥好說的, 但如果用不好反而會降低可讀性.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string s;</span></span><br><span class="line"><span class="comment">// if(isTure)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s = "Empty"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s = foo;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">string</span> s = isTrue ? <span class="string">"Empty"</span> : foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string s2;</span></span><br><span class="line"><span class="comment">// if(isTure)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s2 = GetTheString();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s2 = GetAnotherString();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">string</span> s2 = isTure ?</span><br><span class="line">            GetTheString() :</span><br><span class="line">            GetAnotherString();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建議:  </p>
<ol>
<li>一般只有一行文的情境下才適用.</li>
<li>用了他之後會比原本的 if-else 易讀就用.  </li>
<li>上例中第二種分三行的做法要視情境斟酌一下, 不一定適合. </li>
</ol>
<p>避免:  </p>
<ol>
<li>使用兩層(或超過)的三元運算子, 因為可讀性很差.</li>
</ol>
</blockquote>
<h4 id="Null-條件運算子-與"><a href="#Null-條件運算子-與" class="headerlink" title="Null 條件運算子 ?., ?[] 與 ??"></a>Null 條件運算子 <code>?.</code>, <code>?[]</code> 與 <code>??</code></h4><p>先附上<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators" target="_blank" rel="noopener"><code>?.</code>, <code>?[]</code> 的官方文件</a> 以及 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator" target="_blank" rel="noopener"><code>??</code> 的官方文件</a>, 其中 <code>?.</code> 和 <code>?[]</code> 是 C# 6.0 之後的規格. </p>
<p>主要用途是減少空值判斷的程式碼, 讓維護時更能專注於商業邏輯上.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string s;</span></span><br><span class="line"><span class="comment">// if(value == null)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s = "Empty";</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">//     s = value;</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">string</span> s = <span class="keyword">value</span> ?? <span class="string">"Empty"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string s2;</span></span><br><span class="line"><span class="comment">// if(obj == null)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s2 = null;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s2 = obj.Property;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">string</span> s2 = obj?.Property;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string s3;</span></span><br><span class="line"><span class="comment">// if(obj == null)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s3 = "Empty";</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s3 =  obj.Property;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">string</span> s3 = obj?.Property ?? <span class="string">"Empty"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string s4;</span></span><br><span class="line"><span class="comment">// if(objectWithIndexer == null)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s4 = null;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     s4 = objectWithIndexer["key"];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">string</span> s4 = objectWithIndexer?[<span class="string">"key"</span>];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>建議:  </p>
<ol>
<li>很好用, 可以盡量用.</li>
</ol>
</blockquote>
<h3 id="巢狀-if-條件式"><a href="#巢狀-if-條件式" class="headerlink" title="巢狀 if 條件式"></a>巢狀 if 條件式</h3><p>相信維護過有歷史包袱的系統的工程師多少都見過巢狀的 <code>if</code> 條件式, 甚至是巢狀的 <code>if</code>, <code>else if</code>, <code>else</code> 堆疊起來的程式碼片段, 這樣的程式碼常常看到後面忘了前面, 要花很多時間甚至畫出流程圖才能理解複雜的邏輯. </p>
<h4 id="合併判斷條件"><a href="#合併判斷條件" class="headerlink" title="合併判斷條件"></a>合併判斷條件</h4><p>下面的程式碼是最單純的情境, 這類型的巢狀 <code>if</code> 條件式可以很輕易的合併.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if(a)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(b)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(c)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             //Do something...</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">bool</span> isTrue = (a &amp;&amp; b &amp;&amp; c);</span><br><span class="line"><span class="keyword">if</span>(isTrue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建議:  </p>
<ol>
<li>實際情況當然不會這麼單純, 如果參雜 <code>else if</code> 或 <code>else</code> 的時候就很容易出錯, 先寫好單元測試再來合併條件式會比較好. </li>
</ol>
</blockquote>
<h4 id="提早返回-return"><a href="#提早返回-return" class="headerlink" title="提早返回(return)"></a>提早返回(return)</h4><p>提早返回是一個我很喜歡用的作法, 但用不好的話可讀性還是不會太好.  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if(a)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     // Do somthing...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else if(b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     // Do somthing...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     // Do somthing</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do somthing...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do somthing...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do somthing...</span></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建議:  </p>
<ol>
<li>提早返回的行為盡可能集中在方法的最前面, 或只集中在同一個區塊, 這樣的思路就單純是在某些情境下提早返回, 否則往繼續執行.  </li>
<li>提早返回前要確認條件式結束後沒有其他邏輯.</li>
</ol>
<p>避免:  </p>
<ol>
<li>在一個方法中多次且分散的提早返回, 這樣維護時需要一直注意哪些地方有提早返回, 反而分散注意力了.  </li>
</ol>
</blockquote>
<h4 id="依職責拆分出不同方法"><a href="#依職責拆分出不同方法" class="headerlink" title="依職責拆分出不同方法"></a>依職責拆分出不同方法</h4><p>如果前面的方法都做了, 也避開了誤用的情境, 但還是存在巢狀的 <code>if</code> 條件式時, 就要考慮這個方法是否違反了單一職責原則(Single Responsibility Principle, SRP), 並考慮將某些情境重構成獨立的方法.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>其實這些做法也不是什麼神奇的技巧, 但沒人提醒或是沒在專案中見過的話就很難意識到, 我剛入行時也是常常弄出巢狀的 <code>if</code> 條件式, 覺得對後面接手的人有點抱歉XD</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/" target="_blank" rel="noopener">官方文件</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Clean Code </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[責任鏈模式(Chain of Responsibility)的變形]]></title>
      <url>/content/20180618-chain-of-responsibility-like.html</url>
      <content type="html"><![CDATA[<p>責任鏈模式在教科書上的典型範例是用在簽核流程上, 也就是一個任務/資料會依序流過各個處理節點, 每個節點會判斷任務/資料是不是在自己的權責範圍內, 決定要自己處理還是繼續往下拋.  </p>
<p>前陣子公司專案剛好有一個類似情境, 但需求與教科書用法不同, 第一時間想到一個變形的作法, 而公司大神也提供了另一個更簡潔的做法, 趁還沒忘整理一下記下來.</p>
<blockquote>
<p><a href="https://github.com/ronsun/Demo/tree/master/ValidatorManager" target="_blank" rel="noopener">完整的示範專案和文件</a></p>
</blockquote>
<a id="more"></a>
<p>情境是這樣的, 有一系列的交易驗證機制, 在很多地方都會被用到, 規則是先檢查A, 若A通過再檢查B, 若B通過再檢查C…依此類推, 直覺呼叫各個檢查點的話, 程式碼會顯得有點複雜.</p>
<h3 id="從層層上報變成生產線"><a href="#從層層上報變成生產線" class="headerlink" title="從層層上報變成生產線"></a>從層層上報變成生產線</h3><p>改造一下責任鏈, 把行為變成讓一個任務/資料會依序流過各個處理節點, <strong>各節點處理自己該做的部分, 沒問題再往下拋</strong>, 如下面範例:</p>
<p><strong>待驗證內容</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValidateContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Amount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Country &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>各個驗證節點</strong> : 每個驗證點都繼承自 <code>Validator</code>.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Validator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Validator NextValidator &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">bool</span> <span class="title">Validate</span>(<span class="params">ValidateContext context</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AmountValidator</span> : <span class="title">Validator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Validate</span>(<span class="params">ValidateContext context</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.Amount &gt; <span class="number">10</span> &amp;&amp; context.Amount &lt; <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NextValidator?.Validate(context) ?? <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmailValidator</span> : <span class="title">Validator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Validate</span>(<span class="params">ValidateContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.Email == <span class="string">"ron.sun@mailserver.com"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NextValidator?.Validate(context) ?? <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountryValidator</span> : <span class="title">Validator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Validate</span>(<span class="params">ValidateContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.Country == <span class="string">"Taiwan"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NextValidator?.Validate(context) ?? <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>驗證流程管理者</strong> : 這邊有些教學會把他直接放在呼叫端, 但如果要重用的話, 還是拉出來比較適合.<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValidatorManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">BasicValidation</span>(<span class="params">ValidateContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> amountValidator = <span class="keyword">new</span> AmountValidator();</span><br><span class="line">        <span class="keyword">var</span> emailValidator = <span class="keyword">new</span> EmailValidator();</span><br><span class="line"></span><br><span class="line">        Validator rootValidator = amountValidator;</span><br><span class="line">        amountValidator.NextValidator = emailValidator;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootValidator.Validate(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">FullValidation</span>(<span class="params">ValidateContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> amountValidator = <span class="keyword">new</span> AmountValidator();</span><br><span class="line">        <span class="keyword">var</span> emailValidator = <span class="keyword">new</span> EmailValidator();</span><br><span class="line">        <span class="keyword">var</span> countryValidator = <span class="keyword">new</span> CountryValidator();</span><br><span class="line"></span><br><span class="line">        Validator rootValidator = amountValidator;</span><br><span class="line">        amountValidator.NextValidator = emailValidator;</span><br><span class="line">        emailValidator.NextValidator = countryValidator;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootValidator.Validate(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>呼叫端</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mng = <span class="keyword">new</span> ValidatorManager();</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> ValidateContext() &#123; Amount = <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> isValid = mng.Validate(context);</span><br><span class="line">    <span class="keyword">if</span> (isValid)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"pass validations."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>視情境還是可以再變化, 例如: 驗證不通過時不中斷, 一定要跑完所有驗證才返回結果與錯誤訊息總結, 那就是把返回從 <code>bool</code> 改成一個物件, 讓每個驗證節點去操作返回物件. </p>
</blockquote>
<h3 id="List-和-Func-搭配迴圈"><a href="#List-和-Func-搭配迴圈" class="headerlink" title="List 和 Func 搭配迴圈"></a>List 和 Func 搭配迴圈</h3><p>委派, 集合與迴圈的搭配, 可以讓一連串的方法呼叫變得更簡潔, 也有一點責任鏈的味道在裡面 , 範例如下:</p>
<p><strong>驗證方法</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Validator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">AmountValidate</span>(<span class="params"><span class="keyword">decimal</span> amount</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount &gt; <span class="number">10</span> &amp;&amp; amount &lt; <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">EmailValidate</span>(<span class="params"><span class="keyword">string</span> email</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email == <span class="string">"ron.sun@mailserver.com"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CountryValidate</span>(<span class="params"><span class="keyword">string</span> country</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country == <span class="string">"Taiwan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>呼叫端</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> ValidateContext() &#123; Amount = <span class="number">100</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">    <span class="keyword">var</span> validateList = <span class="keyword">new</span> List&lt;Func&lt;<span class="keyword">bool</span>&gt;&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        () =&gt; validator.AmountValidate(<span class="number">100</span>),</span><br><span class="line">        () =&gt; validator.EmailValidate(<span class="string">"name@mail.com"</span>),</span><br><span class="line">        () =&gt; validator.CountryValidate(<span class="string">"Taiwan"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> validateList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> isValid = item();</span><br><span class="line">        <span class="keyword">if</span> (!isValid) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這種做法讓集合內的 <code>Func&lt;&gt;</code>, <code>Action&lt;&gt;</code> 等委派方法能依序被處理, 且這些方法可以分別在不同的類別裡, 也不用像一般責任鏈必須衍生自父類別, 唯一的限制就是 <code>Func&lt;&gt;</code>, <code>Action&lt;&gt;</code> 的型別參數必須完全相同. </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>責任鏈的基本樣貌就像一條生產線, 基於這個原則下衍生的變形或簡化做法其實還不少, 我把他們稍微整理在<a href="https://github.com/ronsun/ValidatorManager" target="_blank" rel="noopener">這個專案裡</a>.</p>
]]></content>
      
        <categories>
            
            <category> DesignPatterns </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[用 C# 處理 query string]]></title>
      <url>/content/20180608-handle-querystring-in-csharp.html</url>
      <content type="html"><![CDATA[<p>在網頁開發上, 處理 query stirng 是非常常見的情境, 要手動拆組 query string 也不難, 或是使用 .NET 本身就提供的相關功能讓這件事更輕鬆, 而兩種做法各有優缺點.</p>
<a id="more"></a>
<h3 id="手動拆組"><a href="#手動拆組" class="headerlink" title="手動拆組"></a>手動拆組</h3><p>最直覺的方法就是手動拆組字串, 例如:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleQueryString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 手動拆 query string </span></span><br><span class="line">    <span class="keyword">var</span> queryString = <span class="string">"?q1=v1&amp;q2=v2&amp;q3=v3"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queryString.StartsWith(<span class="string">"?"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        queryString = queryString.Remove(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> splitedQueryString = queryString</span><br><span class="line">                             .Split(<span class="string">'&amp;'</span>)</span><br><span class="line">                             .ToDictionary(r =&gt; r.Split(<span class="string">'='</span>)[<span class="number">0</span>], v =&gt; v.Split(<span class="string">'='</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手動組 query string</span></span><br><span class="line">    <span class="keyword">var</span> queryDic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta"><span class="meta-string">"q1"</span></span>] = <span class="string">"v1"</span>,</span><br><span class="line">        [<span class="meta"><span class="meta-string">"q2"</span></span>] = <span class="string">"v2"</span>,</span><br><span class="line">        [<span class="meta"><span class="meta-string">"q3"</span></span>] = <span class="string">"v3"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> formatedQueryString = queryDic</span><br><span class="line">                              .Select(r =&gt; <span class="string">$"<span class="subst">&#123;r.Key&#125;</span>=<span class="subst">&#123;r.Value&#125;</span>"</span>)</span><br><span class="line">                              .Aggregate((left, right) =&gt; <span class="string">$"<span class="subst">&#123;left&#125;</span>&amp;<span class="subst">&#123;right&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手動拆組 query string 常常還要考慮拿到的 query string 前面有沒有多帶問號, 常用的話還要另外抽出來當共用方法, 比較麻煩但相對的很直覺, 且比較不會遇到編碼問題.</p>
<h3 id="HttpUtility-ParseQueryString"><a href="#HttpUtility-ParseQueryString" class="headerlink" title="HttpUtility.ParseQueryString"></a>HttpUtility.ParseQueryString</h3><p>如果不想手動拆組字串的話, 可以用 <code>HttpUtility.ParseQueryString()</code> 來處理 query string, 例如: </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleQueryStringEasier</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 拆 query string </span></span><br><span class="line">    <span class="keyword">var</span> queryString = <span class="string">"?q1=v1&amp;q2=v2&amp;q3=v3"</span>;</span><br><span class="line">    <span class="keyword">var</span> splitedQueryString = HttpUtility.ParseQueryString(queryString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 組 query string</span></span><br><span class="line">    <span class="keyword">var</span> query = HttpUtility.ParseQueryString(<span class="keyword">string</span>.Empty);</span><br><span class="line">    query[<span class="string">"q1"</span>] = <span class="string">"v1"</span>;</span><br><span class="line">    query[<span class="string">"q2"</span>] = <span class="string">"v2"</span>;</span><br><span class="line">    query[<span class="string">"q3"</span>] = <span class="string">"v3"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> formatedQueryString = query.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣做輕鬆很多, 但如果 query string 裡面有中文字或特殊符號的時候容易衍生出編碼相關的問題, 類似的編碼轉換問題在 <a href="/content/20170813-HhttpRequest.QueryString-auto-urlDecode.html" title="HttpRequest.QueryString 的自動 UrlDecode 問題">HttpRequest.QueryString 的自動 UrlDecode 問題</a> 這篇也有提到.</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>兩種做法都各有優缺, 實務上怎麼做還是得視情況決定, 一般來說我還是會優先選擇 <code>HttpUtility.ParseQueryString</code>, 如果有無法解決的編碼問題再考慮手動拆組.</p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[const 和 readonly 特性與使用時機]]></title>
      <url>/content/20180519-const-vs-readonly.html</url>
      <content type="html"><![CDATA[<p>在C#中 <code>const</code> 和 <code>readonly</code> 都可以被當作常數來使用, 但兩者在特性上有許多的差異, 使用上也有一些需要注意的地方. </p>
<a id="more"></a>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h4><p><code>const</code> 又稱”編譯時期常數”, 實際值在編譯期間就會被取代到使用常數的各個地方, 所以相對的限制比較多, 下面只列舉一部分 <code>const</code> 的重要特性, 完整特性可參照 C# 規格書(5.0版 章節10.4).</p>
<ul>
<li>常數被視為靜態成員, 呼叫方法是 <code>MyClass.MY_CONST</code>.</li>
<li>常數宣告中的型別只能是 sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, enum, 或 reference type.</li>
</ul>
<blockquote>
<p>很神奇的一點是, 常數的型別可以是 reference type, 但是只能賦值 null, 例如:<br><code>public const MyClass MY_COSNT = null;</code><br><a href="https://stackoverflow.com/questions/27699906/why-are-we-allowed-to-use-const-with-reference-types-if-we-may-only-assign-null" target="_blank" rel="noopener">stackoverflow</a>上有人討論過這個特性的用法 (不過我目前大概還不會這樣用它)</p>
</blockquote>
<h4 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h4><p>常數的推薦用法與時機</p>
<ul>
<li>這個值是不能在執行時期變動的</li>
<li>存取修飾子<strong>不建議</strong>用 <code>public</code>, 因為基於<a href="#偏好使用-readonly-而非-const">這個情境</a>, <code>const</code> 不適合跨組件引用.</li>
</ul>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><h4 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h4><p><code>readonly</code> 是用在唯讀欄位上, 限制這個欄位只能在建構子或靜態建構子中被修改, 作為常數使用時又稱為執行時期常數, 執行的時候再去參考變數取得真正的值.</p>
<h4 id="使用時機-1"><a href="#使用時機-1" class="headerlink" title="使用時機"></a>使用時機</h4><p>唯讀欄位的推薦用法與使用時機</p>
<ul>
<li>初始化後就不能再被變動</li>
<li>不適合或無法用 const 的時候</li>
</ul>
<blockquote>
<p>唯讀欄位的值可以在建構子中被改變也讓一些人覺得他不是那麼唯讀, 例如下面的程式碼:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class C1</span><br><span class="line">&#123;</span><br><span class="line">    public readonly static string str = &quot;a&quot;;</span><br><span class="line"></span><br><span class="line">    static C1()</span><br><span class="line">    &#123;</span><br><span class="line">        str = &quot;b&quot;;</span><br><span class="line">        str = &quot;c&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唯讀欄位<code>str</code>被賦值”a”之後又在建構子中被改變了兩次值.</p>
</blockquote>
<h3 id="偏好使用-readonly-而非-const"><a href="#偏好使用-readonly-而非-const" class="headerlink" title="偏好使用 readonly 而非 const"></a>偏好使用 readonly 而非 const</h3><p>考慮一個情境, 現在有一個類別庫 <code>DefaultLib</code>, 裡面有一個類別 <code>DefaultClass</code> 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> AGE = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">string</span> NAME = <span class="string">"John"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一個專案 <code>Execute</code> 參考這個類別庫, 並印出 <code>AGE</code> 和 <code>NAME</code> 如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(DefaultClass.AGE);</span><br><span class="line">        Console.WriteLine(<span class="keyword">new</span> DefaultClass().NAME);</span><br><span class="line"></span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>執行後沒問題, 印出了 18 和 John .</p>
<p>接下來, 改成 <code>AGE = 20</code>, <code>NAME = &quot;Smith&quot;</code> 後只編譯 <code>DefaultLib</code> 專案, 並將 <code>DefaultLib.dll</code> 覆蓋掉舊的 dll 後直接執行 <code>Execute.exe</code>.</p>
<p><strong>結果印出了 18 和 Smith</strong></p>
<p>這其實就是一開始說的 <code>const</code> 作為編譯時期常數, 實際值在編譯期間就會被取代到使用常數的地方, 但 <code>readonly</code> 是參考變數取得真正的值, 所以 <code>Execute</code> 這個專案編譯後印出 <code>AGE</code> 與 <code>NAME</code> 的那兩行, 其實是<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="number">18</span>);</span><br><span class="line">Console.WriteLine(<span class="keyword">new</span> DefaultClass().NAME);</span><br></pre></td></tr></table></figure></p>
<p>於是, 不管參考的 <code>DefaultLib.dll</code> 怎麼變化, 只要 <code>Execute</code> 專案不重新編譯, 第一行印的永遠是 18 ,但使用 <code>readonly</code> 就不會有這個問題.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這篇主要的重點是<strong>偏好使用 readonly 而非 const</strong>而已, 這也不是什麼鮮為人知的秘密, 相關的文章google一下就很多了, 而且都寫得更好, 會特別寫一篇只是想整理一下學習成果, 還意外發現了 <code>const</code> 可以是 reference type 的神奇特性. </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p>C#語言規格書<br><a href="https://blog.johnwu.cc/article/c-sharp-const-vs-static-readonly.html" target="_blank" rel="noopener">C# - const vs static readonly</a><br><a href="https://stackoverflow.com/questions/27699906/why-are-we-allowed-to-use-const-with-reference-types-if-we-may-only-assign-null" target="_blank" rel="noopener">Why are we allowed to use const with reference types if we may only assign null to them?</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[消除switch-case]]></title>
      <url>/content/20180412-anti-switch-case.html</url>
      <content type="html"><![CDATA[<p>Switch-case 是一個經常被使用到的語句, 但當條件/情境過多的時候, 他會變得很肥大, 某種程度上造成維護上的困擾, 網路上也有不少人提出針對過大的 switch-case 語句的重構技巧, 例如: 策略模式.<br>但是策略模式會長出很多新的類別, 如果每個 case 的實作內容都很小, 這樣做似乎是有點複雜了, 所以這邊提供其他的替代方案(但會有一些限制).  </p>
<a id="more"></a>
<h3 id="switch-case的問題"><a href="#switch-case的問題" class="headerlink" title="switch-case的問題"></a>switch-case的問題</h3><p>先看一段程式碼<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Convert</span>(<span class="params">StringConverter converter, <span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (converter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StringConverter.Rule1:</span><br><span class="line">            <span class="keyword">return</span> DoByRule1(input);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StringConverter.Rule2:</span><br><span class="line">            <span class="keyword">return</span> DoByRule2(input);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StringConverter.Rule3:</span><br><span class="line">            <span class="keyword">return</span> DoByRule3(input);</span><br><span class="line">        <span class="comment">//以下省略100種</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">string</span>.Empty;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">string</span> result = Convert(StringConverter.Rule1, <span class="string">"this is input"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程式碼是經過最初步整理的樣子, 至少每個case都提取出一個方法, 但是如果情境持續增加, 這個switch-case語句仍然會繼續成長下去, 似乎還能做一些改善.</p>
<h3 id="用-Dictionary-搭配-Func-或-Action-解決"><a href="#用-Dictionary-搭配-Func-或-Action-解決" class="headerlink" title="用 Dictionary 搭配 Func 或 Action 解決"></a>用 Dictionary 搭配 Func 或 Action 解決</h3><p>從原本的 switch-case 可以看出功能其實很單純, 固定傳入一個字串, 經過某種演算過程, 回傳另外一個字串, 只不過根據列舉(enum)的不同, 要做的事也不同, 這種情境就很適合用 <code>Dictionary&lt;TKey, Func&lt;&gt;&gt;</code> 來處理.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Dictionary&lt;StringConverter, Func&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;&gt; allRules =</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;StringConverter, Func&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">StringConverter.Rule1</span>] = (input) =&gt; &#123; <span class="keyword">return</span> DoByRule1(input); &#125;,</span><br><span class="line">        [<span class="meta">StringConverter.Rule2</span>] = (input) =&gt; &#123; <span class="keyword">return</span> DoByRule2(input); &#125;,</span><br><span class="line">        [<span class="meta">StringConverter.Rule3</span>] = (input) =&gt; &#123; <span class="keyword">return</span> DoByRule3(input); &#125;</span><br><span class="line">        <span class="comment">//以下省略100種</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> rule = allRules[StringConverter.Rule1];</span><br><span class="line">    <span class="keyword">string</span> result = rule(<span class="string">"this is input"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>經過整理後, 我們將列舉與行為的配對抽出來成為一個 <code>Dictionary&lt;StringConverter, Func&lt;string, string&gt;&gt;</code>, 可讀性提高了不少(尤其 case 很多的時候會更明顯).<br>但是這種方式是有一些限制的, 所有情境必須有相同的參數與回傳型別, 才能把他們全部放到一個 <code>Dictionary</code> 中, 如果不幸的所些情境參數或回傳型別不同, 那就要考慮是否另外封裝共用的物件作為參數與回傳型別, 此舉是有副作用的(共用的參數與回傳型別中的成員是所有情境的聯集, 可能會很多或很亂), 因此也應該考慮這樣做的效益是否大於副作用.  </p>
<p>搭配 Action 概念跟上一個例子一樣, 不過是用無參數的 Action.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>技巧跟手法有好處就有副作用, 所以不是所有 switch-case 的情境都適合這樣處理, 有些情境可能維持原本的 switch-case 會更好.  </p>
<blockquote>
<p>類似的技巧還有用 <code>List&lt;Func&lt;&gt;&gt;</code> 搭配 <code>foreach</code>, 可用來達成依序執行一系列的行為的目的, 也是很不錯</p>
</blockquote>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://www.codeproject.com/Articles/1192465/Abolishing-Switch-Case-Statement-and-Pattern-Match" target="_blank" rel="noopener">Abolishing Switch-Case Statement and Pattern Matching in C# 7.0</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Clean Code </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 修飾詞 - partial]]></title>
      <url>/content/20180409-usage-of-partial-in-csharp.html</url>
      <content type="html"><![CDATA[<p>C# 的 partial 修飾詞是相對少用的特性, 但在某些時候能起到很關鍵的作用, 所以還是知道一下比較好.<br>partial不是關鍵字但是他可以放在在class, struct, interface 以及 void method(…) 的前面作為修飾詞, 並將類型宣告或方法拆分成多個, 而編譯時會將所有區段結合起來, 所以對執行時期沒有影響. </p>
<a id="more"></a>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="部分類別-partial-class"><a href="#部分類別-partial-class" class="headerlink" title="部分類別(partial class)"></a>部分類別(partial class)</h4><p>以部分類別為例, 我們可以將一個類別拆成多個部分類別並且分別放在不同的多個檔案中, 如下:</p>
<p><strong>OrderService.cs</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public partial class OrderService</span><br><span class="line">&#123;</span><br><span class="line">    // something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>OrderService2.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>以目前所知patial的用途對於 interface, struct 都相似於 class</p>
</blockquote>
<h4 id="部分方法-partial-method"><a href="#部分方法-partial-method" class="headerlink" title="部分方法(partial method)"></a>部分方法(partial method)</h4><p>方法宣告在其中一個部分類別中, 並在另外其中一個部分類別中實作已宣告的部分方法.</p>
<p><strong>OrderService.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//宣告</span></span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">CreateOrder</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>OrderService2.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//實作</span></span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">CreateOrder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>那麼, 什麼情境需要特意將相同類別拆分到不同檔案中呢? 下面依然以部分類別為出發點說明.  </p>
<blockquote>
<p>部分方法的情境目前還沒遇過, 暫時想不到範例</p>
</blockquote>
<h4 id="擴充由工具產生的程式碼"><a href="#擴充由工具產生的程式碼" class="headerlink" title="擴充由工具產生的程式碼"></a>擴充由工具產生的程式碼</h4><p>工具產生的程式碼原則上是不允許人為去直接修改內容的, 因為當下次重新產生的時候, 會將修改的部分也覆蓋掉, 所以我們會透過 partial 將工具產生的程式碼與人為擴充的程式碼分開.<br>這方面的應用常見的是在擴充 EF(Entify Framework) 自動產生的 Models 上, EF產生的 Models 是基於資料庫的欄位的設計的, 有時候我們需要加上一些欄位方便使用時就能派上用場, 例如:  </p>
<p>Member.cs (工具產生)<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Member</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LasName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MemberExtend.cs (人為擴充)<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Member</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FullName</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LasName&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中, EF在更新Models時只會覆蓋 <code>Member.cs</code>, 對於擴充部分可以不用擔心被影響.  </p>
<h4 id="類別過大且難以分割"><a href="#類別過大且難以分割" class="headerlink" title="類別過大且難以分割"></a>類別過大且難以分割</h4><p>有些類別本身包含大量的內容, 且因為種種因素難以拆分時, 就可以利用partial並將其拆分成不同檔案.  </p>
<blockquote>
<p>如果可以的話還是重構出更小的單元, 分成多個部分類型不是優先選項.</p>
</blockquote>
<h4 id="重構單一類別時"><a href="#重構單一類別時" class="headerlink" title="重構單一類別時"></a>重構單一類別時</h4><p>這是運用在之前公司的專案上的, 當時因為類別中的程式碼過多且複雜, 無法一次重構完, 又擔心當下只重構一部分會讓之後要繼續時需要重新花時間再看過一遍, 就將重構後的程式碼拆成另一個檔案, 等之後全部整理完再合併成一個.</p>
<hr>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>由於部分類型編譯後會被視為一個類型, 其限制的大原則是不能與這個特性矛盾, 這邊大致列出一些.</p>
<h4 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h4><ul>
<li>回傳必須為 void, 且 partial 一定要放在 void 前面</li>
<li>不可明確指定存取修飾詞, 隱含為 private</li>
<li>一個方法最多只能在所有部分類別中宣告一次</li>
<li>最多只能有一個以下的實作</li>
<li>可以宣告後不實作, 但不能有實作沒宣告</li>
<li>參數不可有 out 修飾詞</li>
<li>無法明確實作介面方法</li>
</ul>
<blockquote>
<p>其餘族繁不及備載, 更多細節參閱 C# 規格書或 MSDN</p>
</blockquote>
<h4 id="其他部分類型"><a href="#其他部分類型" class="headerlink" title="其他部分類型"></a>其他部分類型</h4><p>所有部分類型的</p>
<ul>
<li>存取修飾詞不可衝突(但可以只有一個部分類型明確指定修飾詞)</li>
<li>泛型參數的數量、順序與名稱必須完全一致</li>
<li>泛型參數的條件約束不可衝突(可以只有一個部分類型明確指定條件約束)</li>
</ul>
<blockquote>
<p>更多細節參閱 C# 規格書或 MSDN</p>
</blockquote>
<hr>
<h3 id="完整特性"><a href="#完整特性" class="headerlink" title="完整特性"></a>完整特性</h3><p>關於partial修飾詞的完整特性(非常多…), 參閱C#規格書, 相關目錄如下(主要在第10章的幾個小節中, 其他章就只是簡介然後說參考第10章).</p>
<blockquote>
<ol>
<li>類別<br>10.1.2 Partial 修飾詞<br>10.2 部分類型<br>10.6.8. 部分方法  </li>
<li>結構<br>11.1.2 partial 修飾詞  </li>
<li>介面<br>13.1.2. partial 修飾詞  </li>
</ol>
</blockquote>
<hr>
<h3 id="參考與延伸"><a href="#參考與延伸" class="headerlink" title="參考與延伸"></a>參考與延伸</h3><p>C#語言規格書<br><a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods" target="_blank" rel="noopener">MSDN</a><br><a href="https://www.codeproject.com/Articles/30101/Introduction-to-Partial-Methods" target="_blank" rel="noopener">Introduction to Partial Methods</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
        <tags>
            
            <tag> partial </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C#中的隨機數]]></title>
      <url>/content/20180304-random-in-csharp.html</url>
      <content type="html"><![CDATA[<p>前些日子, 收到一個小需求需要隨機產生一組帶大小寫字母和數字的亂數字串, 想說需求滿簡單的, 快速寫一下就寫完commit了, 然後過不久就爆掉了.<br>來看看究竟寫了些什麼鬼東西~</p>
<a id="more"></a>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RandomUtil</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _charDic = <span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RandomString</span>(<span class="params"><span class="keyword">int</span> length</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Random rdm = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">string</span> result = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = rdm.Next(_charDic.Length);</span><br><span class="line">            result += _charDic[nextIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程式內容很單純, 就是用<code>System.Random</code>隨機生出指定長度的字串, 但問題就出在需要隨機產生兩組, 於是呼叫端就呼叫了兩次, 像是這樣:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rdm = <span class="keyword">new</span> RandomUtil();</span><br><span class="line">Console.WriteLine(rdm.RandomString(<span class="number">10</span>));</span><br><span class="line">Console.WriteLine(rdm.RandomString(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>然後產生的兩個結果字串一模一樣, Why?</p>
<h3 id="同時建立多個Random"><a href="#同時建立多個Random" class="headerlink" title="同時建立多個Random"></a>同時建立多個Random</h3><p><code>Random</code>的產生方式是基於一個種子來產生的, 也就是<code>public Random(int Seed)</code>中的<code>Seed</code>, 也就是說如果種子一樣, 那兩個new出來的Random物件產生的隨機數是一模一樣的, 而另外一個不帶參數的建構子呢?<br>從<a href="https://referencesource.microsoft.com/#mscorlib/system/random.cs" target="_blank" rel="noopener">referencesource.microsoft.com</a>上面可以查到原始碼是這樣的:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">        : <span class="title">this</span>(<span class="params">Environment.TickCount</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的,預設以<code>Environment.TickCount</code>做為種子, 而<code>Environment.TickCount</code>是衍生自系統計時器的一個值. </p>
<blockquote>
<p><strong>因為<code>Random()</code>的亂數是基於系統計時器產生的, 所以如果在極短時間內 (Environment.TickCount相同) 建立多個<code>Random</code>實例,就會導致產生的亂數是一樣的.</strong></p>
</blockquote>
<p>知道問題後, 腦中閃過兩個做法:  </p>
<h4 id="解一-Thread-Sleep"><a href="#解一-Thread-Sleep" class="headerlink" title="解一: Thread.Sleep()"></a>解一: Thread.Sleep()</h4><p>在<code>new Random()</code>之前, 先延時一毫秒, 避免拿到重複的時間, 雖然直覺但我個人不喜歡.</p>
<h4 id="解二-建立唯一的Random"><a href="#解二-建立唯一的Random" class="headerlink" title="解二: 建立唯一的Random"></a>解二: 建立唯一的Random</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RandomUtil</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _charDic = <span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random _rdm = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RandomString</span>(<span class="params"><span class="keyword">int</span> length</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> result = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = _rdm.Next(_charDic.Length);</span><br><span class="line">            result += _charDic[nextIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RandomUtil</code>初始化的時候就建立一個唯一的<code>Random</code>物件, 避免短時間內重複建立, 呼叫端程式碼不變, 這次兩次產生的結果是一樣的了,問題在<strong>大部分</strong>的情境下解決了.  </p>
<h3 id="多執行緒環境下的Random"><a href="#多執行緒環境下的Random" class="headerlink" title="多執行緒環境下的Random"></a>多執行緒環境下的Random</h3><p>考慮同時有兩條執行緒都建立了<code>Random</code>, 簡單比對一下結果: </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> firstThreadResult = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> firstThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    firstThreadResult = <span class="keyword">new</span> RandomUtil().RandomString(<span class="number">10</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> secondThreadResult = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> secondThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    secondThreadResult = <span class="keyword">new</span> RandomUtil().RandomString(<span class="number">10</span>);</span><br><span class="line">&#125;));</span><br><span class="line">            </span><br><span class="line">firstThread.Start();</span><br><span class="line">secondThread.Start();</span><br><span class="line"></span><br><span class="line">firstThread.Join();</span><br><span class="line">secondThread.Join();</span><br><span class="line">            </span><br><span class="line"><span class="keyword">var</span> rdm = <span class="keyword">new</span> RandomUtil();</span><br><span class="line">Console.WriteLine(firstThreadResult);</span><br><span class="line">Console.WriteLine(secondThreadResult);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>實驗結果顯示, 兩個產生的字串一樣, 所以在多執行緒的情境下, 還是有機會產生重複的亂數組合.</strong></p>
</blockquote>
<h4 id="解三-RNGCryptoServiceProvider"><a href="#解三-RNGCryptoServiceProvider" class="headerlink" title="解三: RNGCryptoServiceProvider"></a>解三: RNGCryptoServiceProvider</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RandomUtil</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _charDic = <span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">    <span class="keyword">private</span> RNGCryptoServiceProvider _rng = <span class="keyword">new</span> RNGCryptoServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">RandomString</span>(<span class="params"><span class="keyword">int</span> length</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> resultArr = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> nextBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">            _rng.GetBytes(nextBytes);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> index = BitConverter.ToInt32(nextBytes, <span class="number">0</span>) % _charDic.Length;</span><br><span class="line">            resultArr += _charDic[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RNGCryptoServiceProvider</code>可以避免<code>Random</code>在多執行緒情境下的重複問題, 但缺點就是他不像<code>Random</code>提供那麼多方法, 所以需要自己實作<code>Next()</code>,<code>Next(max)</code>,<code>Next(min, max)</code>等方法.</p>
<blockquote>
<p>後來我把相關方法整理重構過放在<a href="https://github.com/ronsun/LazyGuy/blob/master/LazyGuy/Utils/RandomValueGenerator.cs" target="_blank" rel="noopener">我的 Github 上</a>了, 實作細節有不少差異, 但概念是跟上面的範例一樣的. </p>
</blockquote>
<h3 id="延伸-關於隨機數"><a href="#延伸-關於隨機數" class="headerlink" title="延伸 - 關於隨機數"></a>延伸 - 關於隨機數</h3><p><a href="https://dotblogs.com.tw/stanley14/2016/09/11/153133" target="_blank" rel="noopener">密碼學(隨機數筆記)</a></p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="http://csharpindepth.com/Articles/Chapter12/Random.aspx" target="_blank" rel="noopener">Random numbers - C# in depth</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Random </tag>
            
            <tag> RNGCryptoServiceProvider </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正確重拋例外]]></title>
      <url>/content/20180131-correctly-re-throw-exception.html</url>
      <content type="html"><![CDATA[<p>重拋例外有很多種方式, 包含 <code>throw</code>, <code>throw ex</code>, 使用 inner exception 以及 <code>System.Runtime.ExceptionServices.ExceptionDispatchInfo</code>, 或是不要重拋例外.  </p>
<p>先總結選擇如下順序:  </p>
<ol>
<li>最好不要重拋例外</li>
<li>重拋優先選 <code>System.Runtime.ExceptionServices.ExceptionDispatchInfo</code></li>
<li>沒有框架支援則用 Inner Exception</li>
<li><code>throw</code> 應該沒什麼情境需要用到了</li>
<li><code>throw ex</code> 是具破壞性的作法, 除非是要<strong>刻意破壞堆疊追蹤</strong></li>
</ol>
<p>這篇會整理這幾種方法的使用與優缺, 並且另外提到 <code>throw</code> 和 <code>throw ex</code> 兩種方法對於堆疊追蹤的負面影響.  </p>
<a id="more"></a>
<h3 id="throw-amp-throw-ex"><a href="#throw-amp-throw-ex" class="headerlink" title="throw &amp; throw ex"></a>throw &amp; throw ex</h3><h4 id="throw-vs-throw-ex"><a href="#throw-vs-throw-ex" class="headerlink" title="throw vs throw ex"></a>throw vs throw ex</h4><p>這兩個最常見也很相似, 所以一起說, 使用 throw 或是 throw ex 都能重拋例外, 但使用 <code>trow</code> 時會保留較完整的堆疊追蹤(stack trace), 而 <code>throw ex</code> 會重置堆疊追蹤, 造成行數顯示在 <code>throw ex</code> 那一行。<br>另外值得注意的是, 用 <code>throw</code> 來重拋例外其實也會漏掉一些堆疊追蹤, 這會在下面展示。</p>
<p>下面的範例程式中直接使用 <code>throw</code> 重拋例外, 並印出堆疊追蹤內容。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ronsun.github.io.lab</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                ThrowException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"======= ThrowException() ============="</span>);</span><br><span class="line">                Console.WriteLine(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThrowException</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                ExceptionHere();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExceptionHere</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"This is exception message."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>運行後可以看到堆疊追蹤最後是停在 <code>ExceptionHere()</code> 裡面(41行), 也就是真正引發例外的地方  </p>
<blockquote>
<p>這邊有另外一個要注意的地方, 堆疊追蹤的第二行是停在 <code>throw</code> 的地方(35行), 本例看不出大的影響是因為有下一層呼叫可以追蹤, 下一小節會用另一段程式碼展示這個問題. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">======= ThrowException() =============</span><br><span class="line">System.Exception: This is exception message.</span><br><span class="line">   at ronsun.github.io.lab.Program.ExceptionHere() in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 41</span><br><span class="line">   at ronsun.github.io.lab.Program.ThrowException() in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 35</span><br><span class="line">   at ronsun.github.io.lab.Program.Main(String[] args) in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 17</span><br></pre></td></tr></table></figure>
<p>但如果在35行使用 <code>throw ex</code> 的話, 堆疊追蹤最後就會停在 <code>ThrowException()</code> 這裡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">======= ThrowException() =============</span><br><span class="line">System.Exception: This is exception message.</span><br><span class="line">   at ronsun.github.io.lab.Program.ThrowException() in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 35</span><br><span class="line">   at ronsun.github.io.lab.Program.Main(String[] args) in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 17</span><br></pre></td></tr></table></figure></p>
<h4 id="throw-也會影響堆疊追蹤的內容"><a href="#throw-也會影響堆疊追蹤的內容" class="headerlink" title="throw 也會影響堆疊追蹤的內容"></a>throw 也會影響堆疊追蹤的內容</h4><p>以下面的程式碼片段為例, 這次不另外呼叫一個引發例外的方法, 而是直接拋出一個例外<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ThrowException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"======= ThrowException() ============="</span>);</span><br><span class="line">        Console.WriteLine(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThrowException</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"This is exception message."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而此時的堆疊追蹤最後其實是停在 <code>throw</code> 那一行, 也就是說如果例外是發生在 <code>ThrowException</code> 方法中而不是下一層的呼叫, 且 <code>try</code> 區塊中有很多程式碼的時候, 還是會有難以除錯的困擾.  </p>
<h3 id="Inner-Exception"><a href="#Inner-Exception" class="headerlink" title="Inner Exception"></a>Inner Exception</h3><p>基於前面的說明, 我們知道重拋例外會破壞堆疊追蹤, 所以另外一種做法是在重拋前將原始的例外放進 Inner Exception 中, 如下片段:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// handle exception, then...</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"outer"</span>, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但這樣做的缺點就是其實是重新包裝了例外, 如果呼叫端沒有往下查看 Inner Exception 的時候就會看不到完整的細節, 即使呼叫端有存取 Inner Exception 也比較麻煩, 是屬於功能正常但不夠優雅的方式.  </p>
<h3 id="System-Runtime-ExceptionServices-ExceptionDispatchInfo"><a href="#System-Runtime-ExceptionServices-ExceptionDispatchInfo" class="headerlink" title="System.Runtime.ExceptionServices.ExceptionDispatchInfo"></a>System.Runtime.ExceptionServices.ExceptionDispatchInfo</h3><p>靠框架解決, 是目前知道的方法中最漂亮的</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// handle exception, then...</span></span><br><span class="line">    ExceptionDispatchInfo.Capture(ex).Throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用容易, 看輸出也沒什麼副作用, 唯一的限制就是要依賴框架.  </p>
<h3 id="不要重拋例外"><a href="#不要重拋例外" class="headerlink" title="不要重拋例外"></a>不要重拋例外</h3><p>這個方法寫在寫在這裡有點奇怪, 但個人來說是非常不喜歡重拋例外的, 比較傾向把所有<strong>不需要特殊處理</strong>的例外都讓全域例外處理機制去處理, 例如: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#exception-filters" target="_blank" rel="noopener">Exception filters</a>.  </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>雖然理想上是不要重拋例外, 但如果真的不得已需要, 則使用 <code>System.Runtime.ExceptionServices.ExceptionDispatchInfo</code>, 萬一使用的框架不支援的話, 那至少要使用 Inner Exception 去處理.  </p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://stackoverflow.com/questions/730250/is-there-a-difference-between-throw-and-throw-ex" target="_blank" rel="noopener">Is there a difference between “throw” and “throw ex”?
</a>  </p>
<p><a href="https://blogs.msdn.microsoft.com/jmstall/2007/02/07/catch-rethrow-and-debuggability/" target="_blank" rel="noopener">debuggability problems associated with catch / rethrow</a>  </p>
<p><a href="https://blogs.msdn.microsoft.com/jmstall/2007/02/15/throw-e-vs-throw/" target="_blank" rel="noopener">‘throw e;’ vs. ‘throw;’</a>  </p>
<p><a href="https://berserkerdotnet.github.io/blog/rethrow-exception-correctly-in-dotnet/" target="_blank" rel="noopener">How to rethrow exception correctly in .Net</a></p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何避免大量參數 - 以HttpHelper為例]]></title>
      <url>/content/20171202-httpHelper-with-builder-like.html</url>
      <content type="html"><![CDATA[<p>在設計 API 的時候, 常常會被參數過多所困擾著, 因為當方法有著過多參數時, 使用的時候容易眼花, 而需要增減參數時也很不方便, 這邊以常見的 HttpHelper 為例來說明。  </p>
<a id="more"></a>
<p>一般來說, 如果專案只需要跟內部的 API 溝通的話, 其實用 HttpClient 來實作既方便又快速, 但是大量外部廠商對接溝通的時候可能就不太適合, 因為每家廠商對接的方式都不一樣, 所以目前的專案是用 WebRequest 來實作。   </p>
<hr>
<h4 id="擁有大量參數的方法"><a href="#擁有大量參數的方法" class="headerlink" title="擁有大量參數的方法"></a>擁有大量參數的方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Post</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> content, Encoding encoding, <span class="keyword">int</span> contentType, <span class="keyword">string</span> proxyAddress, <span class="keyword">string</span> proxyUserName, <span class="keyword">string</span> proxyPassword</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = WebRequest.CreateHttp(url);</span><br><span class="line">    request.ContentType = contentType;</span><br><span class="line">    request.Method = WebRequestMethods.Http.Post;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> contentBytes = encoding.GetBytes(content);</span><br><span class="line">    request.ContentLength = contentBytes.Count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//設定proxy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//發送request, 取得並回傳response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需求的一開始, 參數可能只有 url 跟 content, 但是當對接廠商越來越多的時候, 有人要求只能用特定編碼(UTF8, GBK…), 資料格式不同時 content type 也要不同, 因為網路環境限制有時候要走 proxy 等等的, 這時候就會出現大量參數, 引發一些問題:  </p>
<ul>
<li>增加參數, 那所有呼叫端的程式都要改, 不難, 但是麻煩</li>
<li>呼叫端改好了, 為了避免帶錯值, 所以要測試一輪, 也不難, 但是很花時間  </li>
</ul>
<p>那就有改善的空間了  </p>
<hr>
<h4 id="選擇性引數-Optional-Arguments"><a href="#選擇性引數-Optional-Arguments" class="headerlink" title="選擇性引數(Optional Arguments)"></a>選擇性引數(Optional Arguments)</h4><blockquote>
<p>註: 口語上大多稱選擇性參數(Optional Parameters), 不過MSDN是用選擇性引數(Optional Arguments)  </p>
<p>註: 參數和引數意義上是不同的  </p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Post</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> content = <span class="string">""</span>, Encoding encoding = <span class="literal">null</span>, <span class="keyword">int</span> contentType = <span class="string">"application/x-www-form-urlencoded"</span>, <span class="keyword">string</span> proxyAddress = <span class="string">""</span>, <span class="keyword">string</span> proxyUserName = <span class="string">""</span>, <span class="keyword">string</span> proxyPassword = <span class="string">""</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(encoding == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        encoding == Encoding.UTF8;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> request = WebRequest.CreateHttp(url);</span><br><span class="line">    request.ContentType = contentType;</span><br><span class="line">    request.Method = WebRequestMethods.Http.Post;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> contentBytes = encoding.GetBytes(content);</span><br><span class="line">    request.ContentLength = contentBytes.Count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//設定proxy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//發送request, 取得並回傳response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣用的好處是, 當需要增加非必要參數的時候, 可以直接加在參數列最後面, 並給他一個預設值, 那至少加參數的時候不用像尋寶一樣到處去找呼叫端修改了, 降低了手誤產生bug的風險, 也可以把測試專注在這個方法內就好。   </p>
<p>但是, 還是有缺點:</p>
<ul>
<li>參數列還是超長</li>
<li>參數預設值只能是編譯時期就決定好的常數, 所以Encoding這類參數, 必須預設為null, 然後另外在方法內判斷賦予預設值</li>
<li>新的參數如果不是加在最後面, 在某些情境下會有問題</li>
</ul>
<blockquote>
<p>註:<br>基於以下方法, 呼叫 <code>foo(0, &quot;B&quot;);</code> 時代表的是 <code>foo(0, b = &quot;B&quot;)</code><br>但是如果插了一個參數在b之前, 而型別和b一樣, 方法簽章變成<br><code>public void foo(int a, string c = &quot;&quot;, string b = &quot;&quot;)</code><br>這時候呼叫 <code>foo(0, &quot;B&quot;);</code>代表的就會是<code>foo(0, c = &quot;B&quot;)</code><br><strong>因此這邊會建議在呼叫帶有選擇性引數的方法時, 採用具名方式呼叫, 避免上面範例中的誤用</strong></p>
</blockquote>
<p>所以還是有改善的空間  </p>
<hr>
<h4 id="把所有參數包成一個condition物件"><a href="#把所有參數包成一個condition物件" class="headerlink" title="把所有參數包成一個condition物件"></a>把所有參數包成一個condition物件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Condition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Encoding Cncoding &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = Encoding.UTF8;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ContentType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Post</span>(<span class="params">Condition condition</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//基於condition準備request相關物件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//設定proxy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//發送request, 取得並回傳response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好多了, 這次的改善避免了之前參數過長, 預設值也不受限於常數, 同時當需要增加非必填的參數時, 只需要修改 condition 物件並設好預設值, 呼叫端基本上不用有任何修改。  </p>
<p>但是真要在吹毛求疵的話, 還是有一個缺點: <strong>API使用者無法一眼看出那些參數是必填</strong>.  </p>
<p>我個人的習慣是, 如果不想讓使用者誤用, 那就從技術層面阻止他, 誘導使用者正確使用, 所以接下來接下來  </p>
<hr>
<h4 id="condition-物件的變形"><a href="#condition-物件的變形" class="headerlink" title="condition 物件的變形"></a>condition 物件的變形</h4><p>直接先上完整版, 下面會細說</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Condition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Encoding Encoding &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = Encoding.UTF8;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ContentType &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IWebProxy Proxy &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Condition</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Condition <span class="title">Create</span>(<span class="params"><span class="keyword">string</span> url</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reqParams = <span class="keyword">new</span> Condition()</span><br><span class="line">        &#123;</span><br><span class="line">            Url = url</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reqParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">WithContentType</span>(<span class="params"><span class="keyword">string</span> contentType</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ContentType = contentType;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">WithContent</span>(<span class="params"><span class="keyword">string</span> content</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Content = content;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">WithEncoding</span>(<span class="params">Encoding encoding</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Encoding = encoding;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">WithProxy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//default proxy</span></span><br><span class="line">        IWebProxy defaultProxy = WebRequest.GetSystemWebProxy();</span><br><span class="line">        defaultProxy.Credentials = CredentialCache.DefaultCredentials;</span><br><span class="line">        Proxy = defaultProxy;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">WithProxy</span>(<span class="params"><span class="keyword">string</span> address, <span class="keyword">string</span> userName, <span class="keyword">string</span> password</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IWebProxy webProxy = <span class="keyword">new</span> WebProxy(address);</span><br><span class="line">        webProxy.Credentials = <span class="keyword">new</span> NetworkCredential(userName, password);</span><br><span class="line">        Proxy = webProxy;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣做有幾個重點與目的  </p>
<ul>
<li><code>private Condition() { }</code> 把預設的建構子設成私有, 然後透過有著<strong>必填參數</strong>的靜態方法 <code>Create(string url)</code> 來建立物件, 目的是讓使用者沒有機會漏填必填的參數</li>
<li>使用者建立物件後可以直接呼叫 <code>WithXXXX(...)</code> 方法設定非必填的參數, 具體呼叫範例: <code>Condition.Create(&quot;http://sample.com&quot;).WithContent(&quot;&lt;xml&gt;balalala&lt;/xml&gt;&quot;).WithProxy();</code>, 這樣的方法鏈非常方便, 是來自於 <a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">Fluent Interface</a> 的概念</li>
<li>這樣 condition 組好直接作為 <code>Post(Condition conditon)</code> 的參數就可以了  </li>
</ul>
<p>這種方式是從建構者模式和 Fluent Interface 變形而來的, 建構者模式是把<strong>建構者</strong> 和 <strong>被建構者</strong> 分成兩個物件, 只不過對於一個只是要整合大量參數的需求來說, 要特別建立 Condition 和 ConditionBuilder 兩個物件是有點太多了, 所以稍微變化一下簡化他的複雜度, 網路上也有結合建構者模式和 Fluent Interface 做成 <a href="https://code-maze.com/builder-design-pattern/" target="_blank" rel="noopener">Fluent Builder</a> 的例子.<br><strong>但是!!</strong><br><strong>但是!!</strong><br><strong>但是!!</strong>  </p>
<p>如果不是非常複雜的情境的話, 這樣是有點過度設計了, 雖然呼叫起來很方便, 但會使得 Condition 變得比較複雜, 如果系統中到處都是這種東西的話其實會提高後續的維護門檻的.</p>
<hr>
<h4 id="推薦-只將選填參數包成-Condition-物件"><a href="#推薦-只將選填參數包成-Condition-物件" class="headerlink" title="(推薦)只將選填參數包成 Condition 物件"></a>(推薦)只將選填參數包成 Condition 物件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Encoding Cncoding &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = Encoding.UTF8;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ContentType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Post</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> content, RequestOptions options = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(options == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        options = <span class="keyword">new</span> RequestOptions();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基於options準備request相關物件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//設定proxy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//發送request, 取得並回傳response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>這個版本是我目前最推薦的</strong>, 一方面他減少了參數的數量, 另一方面把必填與選填參數分開, 避免使用者誤用, 也夠簡單好懂.</p>
<h4 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h4><p>其實自己在寫東西常常弄到過度設計的窘境, 最近在練習怎麼樣才能把程式寫得剛好, 又能在易用, 好維護與好擴充中間找到平衡點(但好難XDD).</p>
<h4 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h4><p><a href="https://stackoverflow.com/questions/6239373/how-to-avoid-too-many-parameters-problem-in-api-design" target="_blank" rel="noopener">how-to-avoid-too-many-parameters-problem-in-api-design</a><br><a href="https://code-maze.com/builder-design-pattern/" target="_blank" rel="noopener">Builder Design Pattern and Fluent Builder</a></p>
]]></content>
      
        <categories>
            
            <category> DesignPatterns </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[將上游未合併的PR合併到自己的fork]]></title>
      <url>/content/20171014-unmerged-pull-request-to-my-fork.html</url>
      <content type="html"><![CDATA[<p>情境是這樣的, 我在github上fork了一個專案過來, 並且做了一些修改, 後來發現我的上游專案有幾個pull request剛好解決的我一直解決不了的問題, 該怎麼把那些變更同步到我的fork呢?</p>
<a id="more"></a>
<p>先說一下這故事的人事時地物:  </p>
<ul>
<li>情境如上</li>
<li>JohnDao 他是pull request的作者</li>
<li>issue-fix-branch-1是這個變更所在的branch</li>
<li>AwesomeProject 是這個專案的名字  </li>
</ul>
<p><strong>實作部分</strong>  </p>
<p>先新增遠端儲存庫到要merge的來源專案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add JohnDao-Repo https://github.com/JohnDao/AwesomeProject.git</span><br></pre></td></tr></table></figure></p>
<p>然後把變更fetch下來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch JohnDao-Repo</span><br></pre></td></tr></table></figure></p>
<p>最後把變更merge進來, 然後push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge JohnDao-Repo/issue-fix-branch-1</span><br></pre></td></tr></table></figure></p>
<p> <strong>結論</strong><br>這樣就能將別人(JohnDao)提交但是還沒被原作者合併回去的pull request先合併到自己這裡了。  </p>
<p><strong>參考資料</strong><br><a href="https://stackoverflow.com/questions/6022302/how-to-apply-unmerged-upstream-pull-requests-from-other-forks-into-my-fork" target="_blank" rel="noopener">How to apply unmerged upstream pull requests from other forks into my fork?</a><br><a href="https://stackoverflow.com/questions/36628859/git-how-to-merge-a-pull-request-into-a-fork" target="_blank" rel="noopener">git: how to merge a pull request into a fork?</a><br><a href="https://stackoverflow.com/questions/5617211/what-is-git-remote-add-and-git-push-origin-master" target="_blank" rel="noopener">What is “git remote add …” and “git push origin master”?</a> </p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在Visual studio 2017上使用AxoCover顯示測試程式碼涵蓋範圍]]></title>
      <url>/content/20171009-test-code-coverage-AxoCover.html</url>
      <content type="html"><![CDATA[<p>當我們想知道目前產品的測試程式涵蓋率的時候, 可以使用Visual Studio 2017內建的功能來分析, 但只有企業版支援這個功能, 所以另外找了AxoCover來用看看。</p>
<a id="more"></a>
<h3 id="AxoCover"><a href="#AxoCover" class="headerlink" title="AxoCover"></a>AxoCover</h3><h4 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h4><p>打開 Tools &gt; Extensions and Updates, 並找到AxoCover後直接安裝(安裝時需要關閉Visual Studio才能繼續)。<br><img src="/content/20171009-test-code-coverage-AxoCover/AxoCover-Install.png"></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安裝完成開啟Visual Studio後, 可在Tool &gt; AxoCover打開功能視窗。<br><img src="/content/20171009-test-code-coverage-AxoCover/AxoCover-Installed.png">   </p>
<p>一開始的功能視窗看起來什麼都沒有, 照著上面的提示編譯一下專案後, 可以看到完整的功能頁面。<br><img src="/content/20171009-test-code-coverage-AxoCover/AxoCover-Function-Window.png"></p>
<p>接著就幾個主要功能說明一下  </p>
<ul>
<li><p><strong>Tests</strong>  </p>
<ul>
<li><p><strong>Tests &gt; Run</strong><br>執行所有單元測試。  </p>
</li>
<li><p><strong>Tests &gt; Cover</strong><br>分析測試涵蓋率, 結果可在Report頁籤看到。  </p>
</li>
<li><p><strong>Tests &gt; Build</strong><br>編譯。 </p>
</li>
</ul>
</li>
<li><p><strong>Reposrt</strong><br>這邊可以看到涵蓋率的分析。  </p>
<ul>
<li><strong>Reposrt &gt; Export</strong><br>將執行與涵蓋率分析結果分別輸出到<code>~/.axoCover/runs</code> 以及<code>~/.axoCover/reports</code>, 其中<code>~/.axoCover/reports</code>下是用一個精美的靜態網頁來顯示測試涵蓋率報表。   <img src="/content/20171009-test-code-coverage-AxoCover/AxoCover-Report.png">
</li>
</ul>
</li>
<li><p>Settings<br>AxoCover的相關設定全在這。  </p>
</li>
</ul>
<p>操作上大致是這樣子的, 接著可以打開程式碼並且清楚的看到有被測試碼涵蓋到的部分是綠色, 沒涵蓋到的部分是紅色, 而部分涵蓋的那一行會有一個很小的黃色圖標。<br><img src="/content/20171009-test-code-coverage-AxoCover/AxoCover-Display.png"></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 的 explicit 與 implicit 關鍵字]]></title>
      <url>/content/20170924-explicit-implicit-keywords.html</url>
      <content type="html"><![CDATA[<p>來紀錄一下 C# 的兩個關鍵字 , <code>explicit</code> 以及 <code>implicit</code>。</p>
<a id="more"></a>
<h3 id="定義與使用時機"><a href="#定義與使用時機" class="headerlink" title="定義與使用時機"></a>定義與使用時機</h3><h4 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h4><p>隱含轉換, 不需要明確指定轉換類型, 例如 <code>int</code> 轉換成 <code>float</code> 時, 只需要直接指定變數, 如下:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> f = i;</span><br></pre></td></tr></table></figure>
<p>隱含轉換使用於轉換不會造成資料誤差或例外的情境, 以本例來說, <code>int</code> 轉換成 <code>float</code> 值不會有誤差, 但反過來就會, 所以 <code>float</code> 轉換成 <code>int</code> 時需要明確轉換。</p>
<h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p>明確轉換, 必須明確指定轉換類型, 同樣的例子, 當 <code>float</code> 要轉換成 <code>int</code> 的時候, 就會變成:  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">10.12</span>f;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)f;</span><br></pre></td></tr></table></figure>
<p>明確轉換使用於轉換可能會造成資料誤差或例外時, 以本例來說, 10.12 轉成 <code>int</code> 後, 結果是會不同的, 所以應該用明確轉換比較恰當。</p>
<h3 id="自訂物件的隱含與明確轉換"><a href="#自訂物件的隱含與明確轉換" class="headerlink" title="自訂物件的隱含與明確轉換"></a>自訂物件的隱含與明確轉換</h3><h4 id="範例情境"><a href="#範例情境" class="headerlink" title="範例情境"></a>範例情境</h4><p>首先我們先來考慮一個情境, 現在有兩個類別, 椅子 (Chair) 以及板凳 (Bench) 。</p>
<blockquote>
<p>椅子只能坐一個人, 板凳則沒有限制, 所以椅子轉換成板凳時可以是隱含轉換, 但反過來就應該用明確轉換。  </p>
</blockquote>
<p>先來個椅子, 有個 <code>HeadCount</code> 屬性, 當指定給他的值大於 1 的時候, 代表人數超載了, 會拋出一個例外, 且有一個隱含轉換的方法 <code>public static implicit operator Bench(Chair chair)</code> 如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _headCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> HeadCount</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _headCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"椅子座位只能容納一個人"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _headCount = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chair 轉 Bench 可以是隱含轉換</span></span><br><span class="line">    <span class="comment">// 這個方法也可以放在 Bench 中, 但不能兩邊都寫, 編譯不會過</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Bench</span>(<span class="params">Chair chair</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bench()</span><br><span class="line">        &#123;</span><br><span class="line">            HeadCount = chair.HeadCount</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再來是板凳, 板凳沒有人數限制, 有一個明確轉換的方法 <code>public static explicit operator Chair(Bench bench)</code> 如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bench</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> HeadCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bench 轉 Chair 需要明確轉換</span></span><br><span class="line">    <span class="comment">// 這個方法也可以放在 Chair 中, 但不能兩邊都寫, 編譯不會過</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Chair</span>(<span class="params">Bench bench</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Chair()</span><br><span class="line">        &#123;</span><br><span class="line">            HeadCount = bench.HeadCount</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用戶程式:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Chair chair = <span class="keyword">new</span> Chair()</span><br><span class="line">    &#123;</span><br><span class="line">        HeadCount = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Bench bench = <span class="keyword">new</span> Bench()</span><br><span class="line">    &#123;</span><br><span class="line">        HeadCount = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//當 bench 的 HeadCount 值大於1時, 這邊會拋 Exception 出來</span></span><br><span class="line">    Chair chairFromBench = (Chair)bench;</span><br><span class="line">    Bench benchFromChair = chair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用說明"><a href="#使用說明" class="headerlink" title="使用說明"></a>使用說明</h4><p>接著說明一下轉換的部分, 實作轉換方法有幾個限制  </p>
<ul>
<li>存取修飾詞必須是 public</li>
<li>必須是靜態方法(static)</li>
<li>必須有 implicit 或 explicit 關鍵字</li>
<li>必須有 operator 關鍵字</li>
</ul>
<p>總括來說方法必須長這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static implicit operator Destination(Source src)</span><br><span class="line">public static explicit operator Destination(Source src)</span><br><span class="line"></span><br><span class="line">public static implicit operator Source(Destination dest)</span><br><span class="line">public static explicit operator Source(Destination dest)</span><br></pre></td></tr></table></figure></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>implicit / explicit operator 可以寫在來源或目標中, 但是沒規範又容易亂, 目前看起來寫在來源中比較好, 設計類別 <code>A</code> 的時候由類別 <code>A</code> 決定自己可以隱含或是明確轉換成何種類別, 相較於寫在目標類別中來說比較合理.  </p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/conversion-keywords" target="_blank" rel="noopener">MS</a>  </p>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> Language Spec </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 與 hexo-theme-next 的零碎片段]]></title>
      <url>/content/20170902-hexo-and-next-fragments.html</url>
      <content type="html"><![CDATA[<p>Hexo以及hexo-theme-next樣板在使用上有滿多細節跟小地方是需要一直找資料解決的, 但是每個小東西都寫一篇覺得太零散了, 所以把相關的片段都放在這裡。</p>
<a id="more"></a>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="skip-render"><a href="#skip-render" class="headerlink" title="skip_render"></a>skip_render</h3><p>hexo可以透過skip_render參數讓特定檔案不被渲染, 就以資產資料夾為例吧。  </p>
<p>首先直接建立一個新的Post, 然後將sample.html檔案放到render_sample資料夾下, 這時候資料夾結構看起來是這樣的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- _posts/2017-09/</span><br><span class="line">|   |-- render_sample.md</span><br><span class="line">|   |-- render-sample</span><br><span class="line">|   |   |-- sample.html</span><br></pre></td></tr></table></figure></p>
<p>接著<code>hexo g</code> 一下, 這時候靜態文章的目錄會變成這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- render-sample</span><br><span class="line">|   |-- sample.html</span><br><span class="line">|   |-- index.html</span><br><span class="line">|   |-- sample</span><br><span class="line">|       |-- index.html</span><br></pre></td></tr></table></figure></p>
<p><strong>這就是問題點, sample.html應該純粹作為資產使用才對, sample資料夾不應該存在的。</strong>  </p>
<p>所以我們必須找出hexo的_config.yml檔, 並且設定skip_render參數, 指定資產資料夾不被渲染</p>
<blockquote>
<p><code>skip_render: _posts/*/*/**</code></p>
</blockquote>
<p>接著再重新<code>hexo g</code>一下, 目錄就可以正確的產出了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- render-sample</span><br><span class="line">|   |-- sample.html</span><br><span class="line">|   |-- index.html</span><br></pre></td></tr></table></figure></p>
<p>這邊引述一下hexo官方文件的說明:</p>
<blockquote>
<p>skip_render: 跳過指定檔案的渲染，您可使用 glob 表達式 來配對路徑。</p>
</blockquote>
<h2 id="hexo-theme-next"><a href="#hexo-theme-next" class="headerlink" title="hexo-theme-next"></a>hexo-theme-next</h2>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[利用xs3p將xsd轉換成文件]]></title>
      <url>/content/20170902-xsd-to-document-by-xs3p.html</url>
      <content type="html"><![CDATA[<p>有時候專案中會需要使用xml做為設定文件去定義程式的行為與參數, 而config有可能會非常複雜, 所以為了開發上的方便會用xsd來定義, 並且需要產出一份文件來讓新手快速了解config應該如何編寫, 所以我們需要一些工具來幫來製作文件。</p>
<a id="more"></a>
<p>目前這個專案, 需要文件化的xsd只有一個, 所以並沒有使用大砲級的 <a href="https://www.liquid-technologies.com/xml-studio" target="_blank" rel="noopener">Liquid Studio</a> 以及 <a href="http://www.filigris.com/docflex/" target="_blank" rel="noopener">DocFlex</a>, 而是用了比較輕量簡單的 xs3p , 但是 <a href="https://xml.fiforms.org/xs3p/" target="_blank" rel="noopener">官方的xs3p</a> 排版太陽春, 所以這邊推薦使用 <a href="https://github.com/bitfehler/xs3p" target="_blank" rel="noopener">Github上的美化版</a>, 或是我<a href="https://github.com/ronsun/xs3p" target="_blank" rel="noopener">後來 fork 出來改過的版本</a>.  </p>
<p>接著會用 bitfehler 版本的 xs3p 介紹這個小工具的使用. </p>
<h2 id="下載工具與依賴元件"><a href="#下載工具與依賴元件" class="headerlink" title="下載工具與依賴元件"></a>下載工具與依賴元件</h2><ul>
<li><a href="https://github.com/bitfehler/xs3p" target="_blank" rel="noopener">xs3p美化版</a></li>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=21714" target="_blank" rel="noopener">Command Line Transformation Utility (msxsl.exe)</a></li>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=15697" target="_blank" rel="noopener">MSXML 4.0 Service Pack 3</a>: 可以不裝, 但轉換時Annotation中如果有CDATA區段會轉不出來。</li>
</ul>
<h2 id="xs3p資料夾結構與使用"><a href="#xs3p資料夾結構與使用" class="headerlink" title="xs3p資料夾結構與使用"></a>xs3p資料夾結構與使用</h2><h3 id="主要文件"><a href="#主要文件" class="headerlink" title="主要文件"></a>主要文件</h3><ul>
<li><code>/examples</code>: 範例資料夾。<ul>
<li><code>/examples/test_*.bat</code> : 執行各種轉換工具的批次檔。</li>
<li><code>/examples/*.xsd</code>: 範例XSD檔。</li>
</ul>
</li>
<li><code>/xs3p.xsl</code>: 轉換時需要使用的樣式定義。</li>
</ul>
<h3 id="使用-以msxml為例"><a href="#使用-以msxml為例" class="headerlink" title="使用(以msxml為例)"></a>使用(以msxml為例)</h3><ol>
<li>將 <code>msxsl.exe</code> 放到 <code>/examples</code> 資料夾中。</li>
<li>點擊 <code>/examples/test_msxsl.bat</code> 直接執行。</li>
<li>會在 <code>/examples/msxsl-results</code> 中產出 <code>/examples</code> 目錄下所有XSD檔轉換後的html文件。</li>
<li><a href="sample.xsd">範例XSD</a> 與 <a href="sample.html">範例HTML</a>。</li>
</ol>
<h2 id="各種問題"><a href="#各種問題" class="headerlink" title="各種問題"></a>各種問題</h2><h3 id="編碼問題"><a href="#編碼問題" class="headerlink" title="編碼問題"></a>編碼問題</h3><p>轉出來的html檔所需要的css, js等資源都是連到cdn上拿, 如果在chrome上面樣式無法套用, 可能是編碼問題, 要在 xs3p.xsl 中的 <code>&lt;link&gt;</code> 元素中加上 <code>charset=&quot;UTF-8&quot;</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;&#123;$bootstrapURL&#125;/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; charset=&quot;UTF-8&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="命名空間問題"><a href="#命名空間問題" class="headerlink" title="命名空間問題"></a>命名空間問題</h3><p>用xs3p搭配msxml.exe去產生xsd文件時, 需要特別當一個命名空間設定多個前綴, 只認第一個。  </p>
<p>舉例, 下面的範例中, <code>xmlns:first</code>以及 <code>xmlns:me</code>是同樣的命名空間, 轉換時只認第一個, 所以如果xsd中以me為前綴的type轉換出來的超連結都會是失效的, 如附圖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">id</span>=<span class="string">"ComponentDefinition"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">targetNamespace</span>=<span class="string">"http://www.ronsun.com/ComponentDefinition/Guide.md"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:first</span>=<span class="string">"http://www.ronsun.com/ComponentDefinition/Guide.md"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:me</span>=<span class="string">"http://www.ronsun.com/ComponentDefinition/Guide.md"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<img src="/content/20170902-xsd-to-document-by-xs3p/001-duplicate-namespace.png">  
<h3 id="列舉類型的Annotation無法轉換"><a href="#列舉類型的Annotation無法轉換" class="headerlink" title="列舉類型的Annotation無法轉換"></a>列舉類型的Annotation無法轉換</h3><p>如下範例將註解加在enumeration中, 轉換後的文件會遺漏掉註解。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:simpleType</span> <span class="attr">name</span>=<span class="string">"componentTypeEnum"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:restriction</span> <span class="attr">base</span>=<span class="string">"xs:string"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:enumeration</span> <span class="attr">value</span>=<span class="string">"Typ1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">          &lt;![CDATA[This is type1]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:enumeration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:enumeration</span> <span class="attr">value</span>=<span class="string">"Typ2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">          &lt;![CDATA[This is type1]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:enumeration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:restriction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:simpleType</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>因應方式是把註解加在simpleType下, 如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:simpleType</span> <span class="attr">name</span>=<span class="string">"componentTypeEnum"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">      &lt;![CDATA[</span><br><span class="line">      `Type1`: this is type1  </span><br><span class="line">      `Type2`: this is type2</span><br><span class="line">      ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:restriction</span> <span class="attr">base</span>=<span class="string">"xs:string"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:enumeration</span> <span class="attr">value</span>=<span class="string">"Typ1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:enumeration</span> <span class="attr">value</span>=<span class="string">"Typ2"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:restriction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:simpleType</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這個工具用起來很不錯, 不過如上面所說, 有一些細節不符合目前專案需求, 所以只好自己另外 fork 出來改成 <a href="https://github.com/ronsun/xs3p" target="_blank" rel="noopener">ronsun/xs3p</a>.  </p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[新增一個使用者定義函數提供亂數字串]]></title>
      <url>/content/20170820-mssql-random-string.html</url>
      <content type="html"><![CDATA[<p>首先, 需求上是這樣的:<br>要在資料庫中建立一個UDF(User-defined function), 它的功能是要能產生一組格式像這樣 zAc-jVu-euO-nQ7 的亂數字串。  </p>
<a id="more"></a>
<p>參考許多網路文章並實作後, 發現在Function裡面並不能使用RAND()這類的函數, 所以只能先建立一個檢視表(View), 接著才能在函數中撈出產生在檢視表中的亂數來做動作。 </p>
<p><strong>建立檢視表</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Get_RAND</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RAND</span>() <span class="keyword">AS</span> RandomNumber</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure></p>
<p><strong>建立函數</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> [dbo].[fu_CZ_NewID]()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">	<span class="comment">--需求: </span></span><br><span class="line">	<span class="comment">--  產生一個格式為 6ev-zS5-lMN-pwg 的亂數字串</span></span><br><span class="line">	<span class="comment">--  * 長度為15個字元</span></span><br><span class="line">	<span class="comment">--  * 每三個字元以'-'符號作為分隔符號</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">--@id: 要產生的字串</span></span><br><span class="line">	<span class="keyword">DECLARE</span> @<span class="keyword">id</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">--@length: 要產生的字串長度</span></span><br><span class="line">	<span class="keyword">DECLARE</span> @<span class="keyword">length</span> <span class="built_in">INT</span> = <span class="number">15</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">--@group: 每隔幾個字要加上分隔字元</span></span><br><span class="line">	<span class="keyword">DECLARE</span> @<span class="keyword">group</span> <span class="built_in">INT</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">---@chars: 亂數資料來源</span></span><br><span class="line">	<span class="keyword">DECLARE</span> @chars <span class="built_in">VARCHAR</span>(<span class="number">100</span>) = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">--@count: 迴圈起始值</span></span><br><span class="line">	<span class="keyword">DECLARE</span> @<span class="keyword">count</span> <span class="built_in">INT</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	WHILE (@count &lt; @length)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">DECLARE</span> @<span class="keyword">current</span> <span class="built_in">INT</span> = (<span class="keyword">SELECT</span> RandomNumber <span class="keyword">FROM</span> dbo.Get_RAND) * <span class="number">100</span></span><br><span class="line">		<span class="keyword">IF</span>(@<span class="keyword">current</span> &lt;= <span class="keyword">LEN</span>(@chars))</span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">			<span class="comment">--判斷是否加分隔字元</span></span><br><span class="line">			<span class="keyword">IF</span>((<span class="keyword">LEN</span>(@<span class="keyword">id</span>) + <span class="number">1</span>) % (@<span class="keyword">group</span> + <span class="number">1</span>) = <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">BEGIN</span></span><br><span class="line">			<span class="keyword">SET</span> @<span class="keyword">id</span> += <span class="string">'-'</span>;</span><br><span class="line">			<span class="keyword">SET</span> @<span class="keyword">count</span> += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">SET</span> @<span class="keyword">id</span> += <span class="keyword">SUBSTRING</span>(@chars, @<span class="keyword">current</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">SET</span> @<span class="keyword">count</span> += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">END</span></span><br><span class="line">	<span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">-- Return the result of the function</span></span><br><span class="line">	<span class="keyword">RETURN</span> @<span class="keyword">id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> MSSQL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HttpRequest.QueryString 的自動 UrlDecode 問題]]></title>
      <url>/content/20170813-HhttpRequest.QueryString-auto-urlDecode.html</url>
      <content type="html"><![CDATA[<p>HttpRequest.QueryString[“q”] 在用來取得query string的值是很方便, 但是會自動將query string先做過UrlDecode, 這在query string 有某些特殊字元的時候產生問題</p>
<a id="more"></a>
<p>直接上Demo</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//sample query string (plain text): q=aaa$bbb+ccc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//q = "aaa$bbb ccc"</span></span><br><span class="line">    <span class="keyword">string</span> q = <span class="keyword">this</span>.Request.QueryString[<span class="string">"q"</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 1: encode after get query string</span></span><br><span class="line">    <span class="comment">//             useful if query string not contain other characters can be encode</span></span><br><span class="line">    <span class="comment">//q = "aaa%24bbb+ccc" in this case</span></span><br><span class="line">    <span class="keyword">string</span> q2 = HttpUtility.UrlEncode(<span class="keyword">this</span>.Request.QueryString[<span class="string">"q"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 2: split string to get value</span></span><br><span class="line">    <span class="comment">//             if query string contain charactors can be encode, this is safety way</span></span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; queryStrings = <span class="keyword">this</span>.Request.Url.Query.Replace(<span class="string">"?"</span>, <span class="string">""</span>).Split(<span class="string">'&amp;'</span>).ToList();</span><br><span class="line">    <span class="comment">//q3 = "aaa$bbb+ccc"</span></span><br><span class="line">    <span class="keyword">string</span> q3 = queryStrings.Where(r =&gt; r.Split(<span class="string">'='</span>)[<span class="number">0</span>] == <span class="string">"q"</span>).Select(r =&gt; r.Split(<span class="string">'='</span>)[<span class="number">1</span>]).FirstOrDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> C# </category>
            
            <category> .NET </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[置底 - 工具箱與優質傳送門]]></title>
      <url>/content/19000101-tools-and-references.html</url>
      <content type="html"><![CDATA[<p>總有一些小工具一個不小心就會忘, 還有一些好文章要查的時候找不到.</p>
<a id="more"></a>
<h3 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h3><h4 id="線上工具"><a href="#線上工具" class="headerlink" title="線上工具"></a>線上工具</h4><ul>
<li><p><strong>Regex</strong><br>  <a href="https://regex101.com/" target="_blank" rel="noopener">Regex 101</a>: 線上regex檢查附速查表與解析.<br>  <a href="https://www.debuggex.com/" target="_blank" rel="noopener">Debuggex</a>: 線上regex檢查附速查表與圖像化解析.<br>  <a href="https://jex.im/regulex" target="_blank" rel="noopener">Regulex</a>: 線上regex圖像化解析, 沒有檢查功能但比較好看.  </p>
</li>
<li><p><strong>Markdown Editor</strong><br>  <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>: 好用好看.  </p>
</li>
<li><p><strong>C# 線上IDE</strong><br>  <a href="https://dotnetfiddle.net/" target="_blank" rel="noopener">dotnetfiddle</a></p>
</li>
<li><p><strong>.net source browser</strong><br>  <a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">.net framework</a><br>  <a href="https://source.dot.net/" target="_blank" rel="noopener">.net core</a></p>
</li>
<li><p><strong>其他</strong><br>  <a href="http://web.archive.org/" target="_blank" rel="noopener">archive.org</a>: 網頁下架/消失後可以從這裡找到備份, 備份比 google cache 還要久.  </p>
</li>
</ul>
<h3 id="傳送門"><a href="#傳送門" class="headerlink" title="傳送門"></a>傳送門</h3><h4 id="C-NET"><a href="#C-NET" class="headerlink" title="C# / .NET"></a>C# / .NET</h4><p><a href="http://www.diogonunes.com/blog/webclient-vs-httpclient-vs-httpwebrequest/" target="_blank" rel="noopener">WebClient vs HttpClient vs HttpWebRequest</a>  </p>
<h4 id="API-設計"><a href="#API-設計" class="headerlink" title="API 設計"></a>API 設計</h4><p><a href="https://blog.toright.com/posts/725" target="_blank" rel="noopener">REST &amp; RESTful (1)</a><br><a href="https://blog.toright.com/posts/1399" target="_blank" rel="noopener">REST &amp; RESTful (2)</a></p>
<h4 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h4><p><a href="https://docs.microsoft.com/zh-tw/dotnet/standard/design-guidelines/index" target="_blank" rel="noopener">微軟 Framework 設計方針</a><br><a href="https://msdn.microsoft.com/zh-tw/library/da5kh0wa.aspx#bkmk_QueryResults" target="_blank" rel="noopener">Visual Studio 中的預設鍵盤快速鍵</a>  </p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="http://visualstudioshortcuts.com/2017/" target="_blank" rel="noopener">Visual Studio 2017 keyboard shortcuts</a><br><a href="https://buzzorange.com/techorange/2016/08/16/airbnb-code-review/" target="_blank" rel="noopener">Airbnb 資深工程師分享：怎樣才是正確、有效的 code review</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/03/17/2402814.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（—）</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/03/19/2405216.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（二）</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/03/25/2416841.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（三）</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/04/03/2430585.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（四）</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/04/14/2446507.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（五）</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/04/25/2470277.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（六）</a><br><a href="https://www.cnblogs.com/JimmyZheng/archive/2012/05/17/2502727.html" target="_blank" rel="noopener">C# 温故而知新：Stream篇（七）</a>  </p>
]]></content>
      
        <categories>
            
            <category> Top </category>
            
        </categories>
        
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
