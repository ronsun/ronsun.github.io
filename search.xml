<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Entity Framework Core 預熱]]></title>
    <url>%2Fcontent%2F20240512-ef-core-warmup.html</url>
    <content type="text"><![CDATA[在使用 Entity Framework Core (EF Core) 進行資料存取操作時，初次查詢時會有耗時較長的現象。這種延遲主要是因為 EF Core 在第一次執行查詢時需要進行一系列的初始化步驟。這些步驟造成的延遲可能會對效能敏感的應用程式造成不利的影響。例如在 WebAPI 服務中，如果初始化花費太多時間可能造成連線超時。而且在效能監測時，這種初始化所造成的延遲可能會產生極端的執行時間資料影響到效能的解讀。 為了解決這個問題，通常會在應用程式啟動階段加入一些預熱的操作，以提前完成一些必要的初始化步驟。這篇文章會介紹兩種預熱解法，要注意的是這兩個解法不是針對所有的初始化步驟，目的只是要達到觸發 DbContext.OnModelCreating() 的效果來降低首次查詢的延遲時間。 解法一： dbContext.Set&lt;T&gt;以 ASP.NET Core 來說，在 Startup.cs 中的 Configure 方法中注入 DbContext 來達到效果是最常見的作法，如下： 12345public void Configure(IApplicationBuilder app, DbContext dbContext)&#123; // Warmup operation, trigger DbContext.OnModelCreating() to reduce the initialization delay on first query. dbContext.Set&lt;Blog&gt;().FirstOrDefault();&#125; 這是最簡單的解法，但特定的 Model 進而產生額外的依賴這個缺點會帶來幾個風險和限制： 該 Model 被移除時看似無關的預熱功能也需要一併修改而使用其他 Model。 會需要特別寫註解說明目的，否則後期維護時很可能被誤當成多餘的程式碼而刪除，最麻煩的是刪除後短期內可能還不會產生明顯的問題。 難以通用化，例如公司內部如果有通用套件時，會因為依賴特定資料庫對應的 Model 而無法將預熱功能加入其中。 解法二： ExecuteSqlRaw()為了避免解法一所產生的副作用，可以用執行一個和資料表無關的查詢達到效果，如下： 12345public void Configure(IApplicationBuilder app, DbContext dbContext)&#123; // Warmup operation, trigger DbContext.OnModelCreating() to reduce the initialization delay on first query. dbContext.Database.ExecuteSqlRaw("SELECT 1 FROM DUAL");&#125; 這個解法解決了依賴特定的 Model，這個優點帶來了很大的通用性。以我遇到的情境來說，能輕易的將預熱功能抽離到內部套件中提供跨部門同事使用，如下範例： 1234567891011// In internal library.public namespace MyCompany.EFCoreEnhancement&#123; public static class DbContextExtension &#123; public static void Warmup(this DbContext context) &#123; context.Database.ExecuteSqlRaw("SELECT 1 FROM DUAL"); &#125; &#125;&#125; 12345// In application using the internal library.public void Configure(IApplicationBuilder app, DbContext dbContext)&#123; dbContext.Warmup();&#125; 結論一般來說除非已有現成 API 可用，否則不建議一開始就做預熱功能。如果要做則是視使用情境，單一專案或存取單一資料庫的情境解法一加註解就很夠用了。解法二則是基於最大化通用性的考量設計的，這個方案在把預熱功能抽離到通用套件時才有明顯的優勢。]]></content>
      <categories>
        <category>C#</category>
        <category>Packages</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[為什麼陣列索引的存取是常數時間複雜度 O(1)]]></title>
    <url>%2Fcontent%2F20240427-why-access-array-index-constant-time.html</url>
    <content type="text"><![CDATA[可能只有我不知道，但是不記下來又覺得需要解釋的時候會解釋不出來。 陣列是在程式設計中常見的資料結構，將多個固定大小的元素存放在連續的記憶體位址中，而這段記憶體的起始位址是已知的。當要存取陣列中的某個元素時就能透過起始位址加上偏移量來計算出目標元素的記憶體位址，而不需要一個一個的走訪所有元素去找出目標元素。 另外，Why is indexing faster than binary search 這篇文章提到這件事背後與硬體運作有關。 計算目標元素的記憶體位置公式如下：1元素位址 = 起始位址 + (目標索引 × 元素大小) 由於計算元素位址的過程不依賴於陣列的大小，而僅涉及一次計算操作，因此無論索引大小如何，這個操作的時間都是固定的。這就是為什麼說陣列索引的存取時間複雜度是 O(1)，即常數時間複雜度。 結論這是個很小的知識點，寫出來比較像是備忘並幫助我理清思緒，而需要回答這個問題時也能比較順暢的回答。 另一方面參考資料中有很多圖文並茂且深入的講解，透過連結記錄起來需要時也能更深入的了解。 參考How accessing an array element is constant time ?Why does accessing an Array element take O(1) time?Why is Array Access Constant TimeWhy is indexing faster than binary search]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[責任鏈模式 - Fluent 風格]]></title>
    <url>%2Fcontent%2F20240404-fluent-chain-of-responsibility.html</url>
    <content type="text"><![CDATA[一般範例中的責任鏈，負責組合各實作的 Handler 時通常會如下方這樣組合，這樣的做法不管從操作上還是閱讀上都比較不友善：12345678910111213141516// InitIHandler positiveEven = new PositiveEvenHandler();IHandler negativeEven = new NegativeEvenHandler();IHandler positiveOdd = new PositiveOddHandler();IHandler negativeOdd = new NegativeOddHandler();// ConfigurepositiveEven.SetNext(negativeEven);negativeEven.SetNext(positiveOdd);positiveOdd.SetNext(negativeOdd);// Call the chainpositiveEven.Handle(1);positiveEven.Handle(-1);positiveEven.Handle(2);positiveEven.Handle(-2); 這篇主要是紀錄透過簡單的修改讓 Handler 能更簡單的組合責任鏈。 以 Fluent API 風格組合根據上面的範例，如果能將組合責任鏈改成 Fluent API 風格，能有效提升易用性，如下：1234567891011// Init and ConfigureIHandler root = new PositiveEvenHandler();root.SetNext(new NegativeEvenHandler()) .SetNext(new PositiveOddHandler()) .SetNext(new NegativeOddHandler());// Call the chainroot.Handle(1);root.Handle(-1);root.Handle(2);root.Handle(-2); 而各節點的實作重點則是將 void SetNext(IHandler next) 改成回傳下一個節點的實例 IHandler SetNext(IHandler next)，非常簡單就能讓整個責任鏈更易用，如下範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public interface IHandler&#123; IHandler SetNext(IHandler handler); void Handle(int number);&#125;public class PositiveEvenHandler : IHandler&#123; private IHandler _nextHandler; public IHandler SetNext(IHandler handler) &#123; _nextHandler = handler; return handler; &#125; public void Handle(int number) &#123; if (number &gt; 0 &amp;&amp; number % 2 == 0) &#123; Console.WriteLine($"Positive even number &#123;number&#125;"); return; &#125; if (_nextHandler != null) &#123; _nextHandler.Handle(number); &#125; &#125;&#125;public class NegativeEvenHandler : IHandler&#123; private IHandler _nextHandler; public IHandler SetNext(IHandler handler) &#123; _nextHandler = handler; return handler; &#125; public void Handle(int number) &#123; if (number &lt; 0 &amp;&amp; -number % 2 == 0) &#123; Console.WriteLine($"Negative even number &#123;number&#125;"); return; &#125; if (_nextHandler != null) &#123; _nextHandler.Handle(number); &#125; &#125;&#125;public class PositiveOddHandler : IHandler&#123; private IHandler _nextHandler; public IHandler SetNext(IHandler handler) &#123; _nextHandler = handler; return handler; &#125; public void Handle(int number) &#123; if (number &gt; 0 &amp;&amp; number % 2 == 1) &#123; Console.WriteLine($"Positive odd number &#123;number&#125;"); return; &#125; if (_nextHandler != null) &#123; _nextHandler.Handle(number); &#125; &#125;&#125;public class NegativeOddHandler : IHandler&#123; private IHandler _nextHandler; public IHandler SetNext(IHandler handler) &#123; _nextHandler = handler; return handler; &#125; public void Handle(int number) &#123; if (number &lt; 0 &amp;&amp; -number % 2 == 1) &#123; Console.WriteLine($"Negative odd number &#123;number&#125;"); return; &#125; if (_nextHandler != null) &#123; _nextHandler.Handle(number); &#125; &#125;&#125; 其他作法 - Next 屬性取代 SetNext 方法也是個簡化組合的程式碼的方式，但這種方式當整個責任鏈很長時可讀性稍差，搭配 DI 操作起來也不太順暢。 但優點就是直接用自動實作屬性就好，不用再額外實作 SetNext 方法。 12345678910111213IHandler chain = new PositiveEvenHandler&#123; Next = new &#123; Next = new NegativeEvenHandler &#123; Next = new PositiveOddHandler &#123; Next = new NegativeOddHandler&#123;&#125; &#125; &#125; &#125;&#125;; 結論之前的文章提到過的，設計模式只是個樣板，實務上應該針對語言特性與應用場景做適當的調整。 參考Design Pattern— 責任鏈模式(Chain of Responsibility Pattern)]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 語言特性更新 - C# 8]]></title>
    <url>%2Fcontent%2F20240324-whats-new-in-csharp-8.html</url>
    <content type="text"><![CDATA[C# 各版本新特性摘要，包含自己的想法與實務上的偏好。 唯獨成員 (Readonly members)允許在結構 (struct) 成員上單獨使用 readonly 修飾詞。其中有一些精細的限制，違反的話會有 Warning 或因而無法編譯，所以不用刻意去記。 預設介面方法 (Default interface methods)介面中可以有預設實作方法，打破以前介面無法實作的限制。主要的優點是讓 API 開發者可以在後續版本上加上新的介面方法而不會造成破壞性變更 (Breakin Changes)，算是方便但是預設介面方法有很多限制，並不是表面上的 “介面中的方法可以有實作內容” 這麼單純，這個之後再另外發文探討。而這個特性除了方便外，也會讓介面和抽象方法之間的界線更為模糊，這時候設計的時候就應該更從物件導向設計的角度來決定兩者的使用時機，而不單單只是看語言特性的差異。 擴大模式比對的應用 (More patterns in more places)模式比對從 C# 8 後更新的非常迅速，五花八門琳瑯滿目的很多，如果不是要看變更歷程的話，推薦直接看完整教學： Pattern matching overview Patterns switch 運算式 (Switch expressions)讓 switch 語句更精簡，如下範例：1234567891011121314151617181920public enum Color&#123; Red, Green, Blue, Yellow&#125;public string GetColorHex(Color color)&#123; return color switch &#123; Color.Red =&gt; "#FF0000", Color.Green =&gt; "#00FF00", Color.Blue =&gt; "#0000FF", Color.Yellow =&gt; "#FFFF00", // Default _ =&gt; throw new ArgumentOutOfRangeException(nameof(color), color, null) &#125;;&#125; 這不只是語法外觀的改變，switch 區塊的主體也變成了運算式 (Expression)，而不是以前的陳述式 (Statement)。 屬性模式 (Property patterns)、Tuple 模式 (Tuple patterns)、位置模式 (Positional patterns)雖然命名上是 Property patterns，但他的意思不是在 Property 上使用模式比對，而是使用模式比對時可以針對目標型別的屬性來比對。大概就是用一堆符號來表達對屬性的型別、值範圍等判斷，主訴是程式碼的簡潔。 Tuple 模式和位置模式依此類推。 using 宣告 (Using declarations)不同於以往的1234using (var foo = new Foo())&#123; // Somthing to do&#125; 而改用12using var foo = new Foo();// Somthing to do 差別在於以往我們要將 using 區塊另外框起來，常常需要處理區塊內宣告的參數在區塊外無法使用的問題，不難但很雜，且經常被迫要把宣告與賦值分開，程式碼就比較亂，差異如下：1234567var v1;using (var foo = new Foo())&#123; v1 = foo.GetV1();&#125;var v2 = v1 * 2; 1234using var foo = new Foo();// Place only code related to "foo" in this scope to make it disposed ASAP.var v1 = foo.GetV1();var v2 = v1 * 2; 如上範例註解所示，在新的語法中我們不用關心區塊，區塊範圍會在編譯時期決定，但相對的就是要注意 using 宣告的變數應該盡早使用，避免在中間放其他無關程式碼造成實際的 using 區塊太大。 靜態區域函式 (Static local functions)靜態區域函式能讓我們的區域函式不捕捉外層的變數，但這部分是透過 Warning CS8421 來達到的。 區域函式的變數捕捉特性會產生關注點發散到外層方法的副作用，又因為預設會自動捕捉外層的變數導致平常開發時很難確保所需資訊都由參數列提供而不是透過變數捕捉，靜態區域函式的特點可以有效避免這個困擾。 ref struct 可實作 IDisposable (Disposable ref structs)就字面上的意思，同時也適用 readonly ref struct。 可為 Null 的參考型別 (Nullable reference types)參考型別本來就可以是 Null，這個特性使得參考型別編譯時被視為不可為 Null，並由編譯器分析是否可能誤用使其值為 null。看起來是在空值判斷這個議題上，透過強制規範迫使開發者嚴格檢視空值情境，如果在已有嚴格規範的專案上使用有錦上添花的效果，但如果現有專案規範與品質不夠或開發習慣不嚴謹，啟用這個特性幫助不大，甚至適得其反讓程式碼風格更不一致。 非同步資料流 (Asynchronous streams)雖然名字有 streams 字眼，但他和 Stream 型別無關，是提供非同步迭代的一種特性。 如下方範例程式，有幾個關鍵： async 方法 回傳 IAsyncEnumerable&lt;T&gt; 呼叫端迭代時需要在前面加 await 關鍵字，不限定使用 foreach 的情境，在自己操作迭代器的情境也適用如 await using var enumerator = numberGenerator.GetAsyncEnumerator();。 1234567891011121314151617181920212223using System;using System.Collections.Generic;using System.Threading.Tasks;class Program&#123; static async Task Main(string[] args) &#123; await foreach (var number in GenerateNumbersAsync(5)) &#123; Console.WriteLine(number); &#125; &#125; static async IAsyncEnumerable&lt;int&gt; GenerateNumbersAsync(int count) &#123; for (int i = 0; i &lt; count; i++) &#123; await Task.Delay(1000); yield return i; &#125; &#125;&#125; 上面範例每秒都能回傳一個結果，但以前通常只能等到 GenerateNumbersAsync() 完成再一次回傳如下：1234567891011121314151617181920static async Task&lt;IEnumerable&lt;int&gt;&gt; GenerateNumbersAsync(int count)&#123; var numbers = new List&lt;int&gt;(); for (int i = 0; i &lt; count; i++) &#123; await Task.Delay(1000); numbers.Add(i); &#125; return numbers;&#125;// Doesn't work, returns `IEnumerable&lt;Task&lt;int&gt;&gt;` also doesn't work.// static async Task&lt;IEnumerable&lt;int&gt;&gt; GenerateNumbersAsync(int count)// &#123;// for (int i = 0; i &lt; count; i++)// &#123;// await Task.Delay(1000);// yield return i;// &#125;// &#125; 而根據 ChatGPT 的範例，不使用這個特性要每秒都能回傳一個結果的話，程式碼就會像下面這樣難以閱讀：12345678910111213141516171819202122using System;using System.Threading.Tasks;class Program&#123; static async Task Main(string[] args) &#123; await GenerateNumbersAsync(5, async number =&gt; &#123; Console.WriteLine(number); await Task.Delay(1000); &#125;); &#125; static async Task GenerateNumbersAsync(int count, Func&lt;int, Task&gt; processNumber) &#123; for (int i = 0; i &lt; count; i++) &#123; await processNumber(i); &#125; &#125;&#125; IAsyncDisposable (Asynchronous disposable)如字面上的非同步 dispose，上面的非同步資料流中提到的 IAsyncEnumerable&lt;T&gt; 就繼承自 IAsyncDisposable。 索引和範圍 (Indices and ranges)用更簡潔的語法表達索引和範圍，提供兩個新的型別 System.Index 和 System.Range，並透過 ^ (倒數) 和 .. (到) 符號來使用。 要注意的是第一個是 0，但倒數第一個是 ^1 。 歸納一下規則： ^n 是倒數第 n 個 (即 sequence[sequence.Length - n] 的概念)。 x..y 是索引 x (包含) 到索引 y (不包含)，省略 x 代表從頭開始。省略 y 代表到底為止。 x 和 y 可以是 ^m 和 ^n 這樣表示。 索引 x 必須小於或等於索引 y，而 ^m 和 ^n 推論成 x 和 y 後亦同。 範例如下：12345678910111213141516171819202122string str = "This is a book.";Index first = 0;Index firstFromEnd = ^1;str[first].Dump(); // Tstr[firstFromEnd].Dump(); // .str[0].Dump(); // Tstr[^1].Dump(); // .Range range = 10..14;Range rangeFromEnd = ^5..^1;str[range].Dump(); // bookstr[rangeFromEnd].Dump(); // bookstr[10..14].Dump(); // bookstr[^5..^1].Dump(); // bookstr[5..^8].Dump(); // isstr[^10..7].Dump(); // isstr[..7].Dump(); // This isstr[10..].Dump(); // book.str[0..^0].Dump(); // This is a book.str[..].Dump(); // This is a book. 雖然正向和倒數可以混用，但不要濫用不然可讀性也會差。 ??= (Null-coalescing assignment)範例：1message ??= "Default Message"; 同義於1234if (message == null)&#123; message = "Default Message";&#125; 非託管結構型別 (Unmanaged constructed types)如果結構只包含非託管型別的屬性時，該結構也是非託管型別。 巢狀運算式中的 Stackalloc (Stackalloc in nested expressions)如果 stackalloc 運算式的結果是 Span&lt;T&gt; 或 ReadOnlySpan&lt;T&gt; 就可以不用另外指派給另外一個變數，如下範例：1234567Span&lt;int&gt; numbers = stackalloc[] &#123; 1, 2, 3, 4, 5, 6 &#125;;// In earlier version:// Span&lt;int&gt; searchNumbers = stackalloc[] &#123; 2, 4, 6, 8 &#125;;// var idx = numbers.IndexOfAny(searchNumbers);// Now:var idx = numbers.IndexOfAny(stackalloc[] &#123; 2, 4, 6, 8 &#125;); 擴充內插逐字字串 (Enhancement of interpolated verbatim strings)可支援 $@&quot;...&quot; 和 @$&quot;...&quot;，順序不會造成編譯錯誤。 參考What’s new in C# 8.0 (原文件已經被刪除，這是 Archive 網站的存檔)]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 語言特性更新 - C# 7]]></title>
    <url>%2Fcontent%2F20240203-whats-new-in-csharp-7.html</url>
    <content type="text"><![CDATA[C# 各版本新特性摘要，包含自己的想法與實務上的偏好。 C# 7 系列比較特殊，總共經過 7.0、7.1、7.2、7.3 四個版本，且範圍有高度重疊，所以這邊不分開看，直接依照 2021 年版官方整合過的文件將 C# 7 的新特性一起看。 Tuples 和 Discards具名 Tuple以前的 Tuple 沒辦法具名，所以會產生很多 tuple.Item1 這類的呼叫，嚴重影響程式碼的可讀性，具名 Tuple 出現後很大程度解決了這個問題，如下範例：12345678public (int Id, string Name) GetPerson()&#123; return (1, "Ron");&#125;// Callervar user = GetPerson();$"ID: &#123;user.Id&#125;, Name: &#123;user.Name&#125;".Dump(); // ID: 1, Name: Ron 但這也衍生出另外一個問題就是命名風格，這邊我建議依照呼叫端的使用方式來決定，以本例來說，呼叫端使用上像是將他視為屬性，因此使用雙駝峰。但如果像下面的情境，就應該使用單駝峰，因為呼叫端使用上像是區域變數：12(var id, var name) = (1, "Ron");$"ID: &#123;id&#125;, Name: &#123;name&#125;".Dump(); // ID: 1, Name: Ron 另外還要注意這種風格的 Tuple 其實背後是編譯成 System.ValueTuple 而不是傳統的 System.Tuple，這兩種型別有一些差異。 Discards12345678public (int Id, string Name, string Address) GetPerson()&#123; return (1, "Ron", "My Home");&#125;// Caller, discard the Address(var id, var name, _) = GetPerson();$"ID: &#123;id&#125;, Name: &#123;name&#125;".Dump(); // ID: 1, Name: Ron 如上範例，用不到的變數可以用一個底線 _ 取代，可以讓維護的人不用關注無用的資訊。但這也不是他唯一的使用情境，詳細情境參考 Discards 官方文件。 C# 怎麼處理 Tuple 的名字?將一段簡單的程式碼編譯後，透過反組譯工具反組譯回低版本的 C# 可以發現，最後還是呼叫 Item1、Item2，所以具名 Tuple 其實是一種編譯時期的語法糖。 解構 (Deconstruction)雖然解構看起來是另外一個主題了，但可能是因為 Tuple、Discards、解構，三者太常互相搭配使用，官方文件中是將他和 Discards 放在一起的，解構不只能套用到 Tuple 還能透過實作 Deconstruct 方法套用到其他型別上。 直接看 Discards 和 Deconstructing tuples and other types 來了解會更全面。 這邊要注意一下，寫這篇文章時 C# 已經更新到 12 版了，官方的規格介紹中會夾很多後面版本新增的特性。 模式比對 (Pattern matching)這個功能比較像是為了可讀性的擴充，主要用途在於用 is 關鍵字來做型別確認與轉換；用 when 關鍵字來做附加條件判斷；額外搭配 switch 來透過簡單的語法達到複雜的運用。 is 關鍵字1234567891011121314public void Do(object obj)&#123; if (obj is int i) &#123; // Do somthing using i. return; &#125; if (obj is string s) &#123; // Do somthing using s. return; &#125;&#125; 從上述範例可以看到以前需要先透過 is 判斷型別後再轉型 (或使用 as 後再判斷空值後處理)，現在可以將兩個行為合一讓可維護性提高很多。 switch123456789101112131415161718192021private static void Do(object obj)&#123; switch (obj) &#123; case int i: // Do somthing using i. break; case string s: // Do somthing using s. break; case DateTime dt when dt.Year == 2021: // Do somthing using dt which contains Year is 2021. break; case null: // Do somthing for null scenario. break; default: // Default behavior. break; &#125;&#125; 從上述範例可以看到，switch 關鍵字在使用上能更有彈性的設定條件了。 這個規格依然是編譯時期的語法糖， switch 本身的限制並沒有改變，上面的範例編譯後其實是 if、else if、else 條件式的組合。 Async main在 Main 上可以加上 async 關鍵字了。比較意外的是這也是語法糖，保哥有一篇文章提供詳細的說明。 區域函式 (Local functions)區域函式允許一個方法中包含另外一個方法，而區域函式只能被包含他的方法呼叫。這個設計主要用於迭代器和非同步方法中。 實務使用情境而在實務上，在滿足以下條件下，也可考慮使用區域函式： 有足夠的理由將該區塊抽離： 通常這種情境下如果不抽離的話，原方法會過於肥大，以前常見的作法是用 #region 包覆起來，但這種做法對維護沒有太大的幫助。 該方法做為私有方法仍然過於特殊： 很多時候會有程式碼區塊內容過於特殊，離開主方法後無法封裝成一個方法。 使用注意事項區域函式不宜濫用，如果濫用會發現主要方法仍然很肥大，且會增加排版的難度。關於區域函式排版上我自己有幾個建議要點： 區域函式集中放在最下方且要在 return 後，這樣區域函式才不會穿插在呼叫端的程式碼中造成更大的混亂。 即使方法無回傳也要在區域函式前加上 return;，用以更明確的區隔呼叫端程式碼和區域函式部分。 如下範例：1234567891011121314public void Do(int a, int b, bool c)&#123; var a2 = LocalFunction(a); int ans = c ? LocalFunction(a2 + b) : LocalFunction(a * b); // Always return at the last line of primary implementation. return; // Local functions int LocalFunction(int num) &#123; return num * 2; &#125;&#125; 區域函式也是編譯時期的語法糖且有很多細節要說，尤其是參數傳遞的部分，這部分之後再另外寫一篇來詳細說明。 更多成員支援運算式主體 (More expression-bodied members)運算式主體套用到更多成員上，包含建構子、Finalizer、以及在屬性和索引子上的 get 與 set 存取子，範例如下： 12345678910111213141516171819202122232425public class MyContainer&#123; private List&lt;string&gt; items = new List&lt;string&gt;(); private string label; // Expression-bodied constructor public MyContainer(string initialLabel) =&gt; Label = initialLabel; // Expression-bodied finalizer ~MyContainer() =&gt; Console.WriteLine("Finalizing or cleaning up MyContainer."); // Expression-bodied property get and set accessors public string Label &#123; get =&gt; label; set =&gt; label = value ?? "Default label"; &#125; // Expression-bodied indexer public string this[int index] &#123; get =&gt; items[index]; set =&gt; items[index] = value; &#125;&#125; 要注意的是 Finalizer，舊稱 Destructor 的語法 ~ 實際上是個語法糖，編譯後其實是 Finalize() 方法。 throw 運算式 (Throw expressions)throw 一直都是陳述式 (Statement) 而非運算式 (Expression)，也因此以前很多運算式中無法包含 throw (例如在三元運算子中)，而在 C# 7.0 中新增的 throw 運算式 解決了這個限制。 預設常值運算式 (Default literal expressions)擴大 default 運算子的適用範圍到運算式上 數值常值的語法增強功能 (Numeric literal syntax improvements)允許利用 _ 符號來分隔數字而不影響數值本身，類似於千分位符號的功能且同時能套用到二進位數值上，範例如下：123int binary = 0b001_0000;int number = 10_000_000;decimal money = 1_000.123_456; out 變數 (out variables)可以把 out 變數的宣告和傳遞寫在一起，如下：1int.TryParse(str, out int number); 這個特性雖然看起來不起眼，但是在實務上對於維護是有非常大的幫助的，他能避免讓變數的宣告和使用的位置距離太遠，如下面範例是實務上常見的痛點。首先看這段程式碼，因為維護或各種關係導致變數 number 和 decimal 的宣告遠離第一次被使用的位置，進而造成閱讀時必須同時關注這麼一大段程式碼並忽略中間穿插的各種雜訊。12345678910111213141516171819202122232425int number;// Unrelated code, making it hard to track 'number'for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine("Loop 1: " + i);&#125;string temp = "Hello";Console.WriteLine(temp.ToUpper());bool flag = true;if (flag) &#123; Console.WriteLine("Flag is true");&#125;decimal money;// Unrelated code, making it hard to track 'money'foreach (var item in new List&lt;string&gt; &#123; "a", "b", "c" &#125;) &#123; Console.WriteLine("Item: " + item);&#125;DateTime now = DateTime.Now;Console.WriteLine("Current time: " + now);// Usage of 'number' and 'money' is separated from its declarationint.TryParse(str, out number);decimal.TryParse(str2, out money); 但套用這個特性，維護過程我們就不用關注那些雜訊而能直接鎖定在真正的目標上。12int.TryParse(str, out int number);decimal.TryParse(str2, out decimal money); 這個問題的主因是不好的開發習慣，但長期多人開發的專案很難完全避免這個現象。重構和 Code Reivew 能緩解這個問題，但終究是額外的成本，因此從語言特性上直接避免是更理想的。 非後置具名引數 (Non-trailing named arguments)具名引數非必要放在最後，例如：1234// In C# 7.1 and earlier, named arguments should be trailing.DisplayPersonDetails(35, "Ron", city: "New York");// In C# 7.2 and later, named arguments do not necessarily have to be trailing.DisplayPersonDetails(age: 35, "Ron", city: "New York"); 這讓我們可以不用為了遷就前排的具名引數而將其後所有引數具名，但從另外一個角度來看，使用具名引數時提高可讀性前應該先思考方法參數列的設計是否需要改善。 private protected 存取修飾詞 (private protected access modifier)限制存取範圍在 protected AND internal，比 protected internal 代表的 protected OR internal 存取範圍更狹窄。 改善選擇多載的規則 (Improved overload candidates)增加三個解析規則來讓更明確的選擇多載。 老實說我不想特別去記這些複雜的規則，因為這些規則是建立在呼叫多載方法時會混淆的前提，通常這代表多載設計得不夠好，應該優先考慮改善多載方法的設計。 擴充安全程式碼的能力 (Enabling more efficient safe code)幾乎都是沒用過的特性，所以直接看官方文件，沒甚麼好說的。 套用 ref 到區域變數和回傳值上 / ref 條件運算式 (Ref locals and returns / Conditional ref expressions)允許傳址給區域變數，例如：12345678910111213public class Program&#123; public static void Main() &#123; int[] numbers = &#123; 1, 2, 3 &#125;; ref int two = ref numbers[1]; two = 0; Console.WriteLine(two); // 0 Console.WriteLine(numbers[1]); // 0 &#125;&#125; 允許回傳時傳址，例如：123456789101112131415161718public class Program&#123; public static void Main() &#123; int[] numbers = &#123; 1, 2, 3 &#125;; ref var two = ref GetTwo(numbers); two = 0; Console.WriteLine(two); // 0 Console.WriteLine(numbers[1]); // 0 &#125; static ref int GetTwo(int[] numbers) &#123; return ref numbers[1]; &#125;&#125; ref 條件運算式，例如：1ref var i = ref (numbers1 != null ? ref numbers1[0] : ref numbers2[0]); 除非很必要否則我不用 ref 的，因為對於開發、維護人員來說門檻較高且容易被濫用，且到目前為止工作上可以使用 ref 的情境其實都有其他成本不高且低副作用的替代方案。 當然也不是說 ref 不好，相信他在一些效能極度敏感的情境是很有用的。 in 參數修飾詞補充現有的 ref 和 out。ref 傳址，被呼叫的方法不一定要為其賦值；out 傳址，被呼叫的方法一定要為其賦值，代表這個引數在傳入前賦值通常是沒意義的；in 傳址，被呼叫的方法不能為其賦值。1234567891011121314void Do(ref string a, out string b, in string c)&#123; // Must to have b = "B"; // Can not assign to "in" parameter. // c = "C";&#125;string s1 = "a";// Bad, assignment here generally doesn't make sense.string s2 = "b";// Need to have value generally.string s3 = "c";Do(ref s1, out s2, in s3); 更多型別支援 fixed 陳述式 (More types support the fixed statement)在 C# 7.3 之後，所有包含 GetPinnableReference() 方法且回傳 ref T 或 ref readonly T 的型別都能套用 fixed。 fixed 索引欄位不需要釘選 (Indexing fixed fields does not require pinning)123456789101112131415161718192021222324252627282930using System;public unsafe struct MyStruct&#123; public fixed int FixedArray[10];&#125;public class Example&#123; public static void Main() &#123; MyStruct myStruct = new MyStruct(); // Before C# 7, pinning required fixed (int* ptr = myStruct.FixedArray) &#123; for (int i = 0; i &lt; 10; i++) &#123; ptr[i] = i; &#125; &#125; // After C# 7, no pinning required for (int i = 0; i &lt; 10; i++) &#123; // Direct indexing is now allowed myStruct.FixedArray[i] = i; &#125; &#125;&#125; stackalloc 陣列支援初始設定式 (stackalloc arrays support initializers)C# 7.3 之前：12345int* arr = stackalloc int[3];arr[0] = 1;arr[1] = 3;arr[2] = 5; C# 7.3 之後：1int* arr = stackalloc int[3] &#123; 1, 3, 5 &#125;; 擴充泛型限制可以限制 System.Enum 或 System.Delegate 做為泛型型別的限制；也可以用 unmanaged 限制為不可空的非託管型別。 最有感的是 System.Enum 以前要限制泛型型別只能用 struct 再加上一些驗證程式碼，沒辦法在編譯時期精準限制列舉為泛型型別。 新的編譯選項這部分沒用過，就留個連結備查。 結論C# 7 多了很多東西，最明顯的是各種語法糖，面對語法糖，應該找時間更仔細的研究他們編譯後實際的樣子避免誤用。 參考What’s new in C# 7.0 through C# 7.3 (原文件已經被刪除，這是 Archive 網站的存檔)]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[可重用的 XML 文件註解]]></title>
    <url>%2Fcontent%2F20240122-reuseable-xml-documentation-comments.html</url>
    <content type="text"><![CDATA[在開發 C# 專案時，我們經常使用 XML 文件註解 來為型別或成員寫說明，這類型的註解除了可以提高維護性外，也可以透過工具自動轉化成 API 文件。 但是註解也是需要維護的，在多載方法的註解經常面臨一個問題就是一群多載方法通常有著相似的註解，維護時需要一個一個修改其實很容易使得最後不同多載間的註解有著許多細微的不一致。另一方面這樣也讓維護註解變得更麻煩瑣碎。 XML 文件註解 官方文件很詳細，這篇文章不詳細說明這些內容，而會聚焦在重用註解的方式。 &lt;inheritdoc&gt;首先是 &lt;inheritdoc&gt; 這個標記，這算是比較常用的部分，範例如下：123456789101112131415161718192021public class FluentUriBuilder&#123; /// &lt;summary&gt; /// Create &lt;see cref="FluentUriBuilder"/&gt;. /// &lt;/summary&gt; /// &lt;returns&gt;Created &lt;see cref="FluentUriBuilder"/&gt;.&lt;/returns&gt; public static FluentUriBuilder Create() &#123; return new FluentUriBuilder(); &#125; /// &lt;summary&gt; /// &lt;inheritdoc cref="Create()"/&gt; With passed &lt;paramref name="uri"/&gt;. /// &lt;/summary&gt; /// &lt;param name="uri"&gt;Uri.&lt;/param&gt; /// &lt;returns&gt;Created &lt;see cref="FluentUriBuilder"/&gt;.&lt;/returns&gt; public static FluentUriBuilder Create(Uri uri) &#123; return new FluentUriBuilder(uri); &#125;&#125; 首先可以看到無參數方法 Create() 有一行註解 Create &lt;see cref=&quot;FluentUriBuilder&quot;/&gt;.，對於另外一個多載來說應該也要套用相同的註解為基底，可能會需要加上針對該多載的特別描述，這時候就可以用 &lt;inheritdoc cref=&quot;Create()&quot;/&gt; 的方式來 “繼承” 無參數方法的註解，並附加額外的說明。 但這個方法有些缺點，首先，當多載數量一多的時候註解內容就會有很多繼承語句，可讀性不太好；其次，在決定要用哪個多載的註解當基底時也容易有標準不一致的情況。這兩個缺點都會讓註解的維護打了不少折扣。 整體來說，堪用但可維護性偏差。 &lt;include&gt;同樣的程式碼片段，變成下面這樣：12345678910111213141516171819202122public class FluentUriBuilder&#123; /// &lt;summary&gt; /// &lt;include file='Properties/SharedComments.xml' path='SharedComments/Method[@name="FluentUriBuilder.Create"]'/&gt; /// &lt;/summary&gt; /// &lt;returns&gt;Created &lt;see cref="FluentUriBuilder"/&gt;.&lt;/returns&gt; public static FluentUriBuilder Create() &#123; return new FluentUriBuilder(); &#125; /// &lt;summary&gt; /// &lt;include file='Properties/SharedComments.xml' path='SharedComments/Method[@name="FluentUriBuilder.Create"]'/&gt; /// With passed &lt;paramref name="uri"/&gt;. /// &lt;/summary&gt; /// &lt;param name="uri"&gt;Uri.&lt;/param&gt; /// &lt;returns&gt;Created &lt;see cref="FluentUriBuilder"/&gt;.&lt;/returns&gt; public static FluentUriBuilder Create(Uri uri) &#123; return new FluentUriBuilder(uri); &#125;&#125; 這個做法直接把共用註解檔獨立出去成一個 XML 檔案存放在 Properties 中，如下：12345&lt;SharedComments&gt; &lt;Method name="FluentUriBuilder.Create"&gt; Create &lt;see cref="FluentUriBuilder"/&gt;. &lt;/Method&gt;&lt;/SharedComments&gt; 優點在於避免 &lt;inheritdoc&gt; 在方法間相互 “繼承” 所引發的混亂，但相對的缺點就是會需要額外的註解檔，且以可讀性差來說和 &lt;inheritdoc&gt; 不相上下。 結論雖然 XML 文件註解很簡單，但其實他有各式各樣的標記讓我們在維護程式過的過程就順便維護 API 註解，能為自動產生的 API 提供很大的幫助最大化降低額外維護文件的成本與風險。 而註解因為沒有編譯器的保護所以寫壞很難察覺，如果能活用 XML 文件註解的話也能更容易的維持高品質的註解。 參考XML documentation comments]]></content>
      <categories>
        <category>C#</category>
        <category>NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在 EF Core 中自定義 ValueConverter]]></title>
    <url>%2Fcontent%2F20231225-efcore-customize-valueconverter.html</url>
    <content type="text"><![CDATA[關於 EF Core 中的值轉換 (Value Conversion)，官方文件已經展示的非常詳細，但這樣的實作使得值轉換和 DbContext 高度相依，在中小型專案中這樣已經足夠，但在複雜的產品群中，如果需要基於 EF Core 建立內部共用的套件，就會難以將這些客製化的 ValueConverter 從套件中抽離，也難以讓應用程式自行擴充自己特殊的 ValueConverter，本文主要提供另外一個面向的實作來達到更低的耦合度與更高的可擴充性。 前言通常我們不需要自己客製化 Value Converters，但實務環境總是不會這麼單純。 以一個實務的例子來說，舊的資料庫在將真假值欄位的值存成 1 代表 false，2 代表 true，然後在程式中用一個列舉 TrueFalseEnum 來表達時，而同一個資料庫又有正常的真假值欄位是存成 0 代表 false 而 1 代表 true，並在程式中轉成 bool。 當有機會重整舊系統時，想要統一這種真假值的型別但又因為要避免未重整部分出錯而不能直接修正資料庫的資料時，就需要在 EF Core 轉換過程直接透過不同的 ValueConverter 來讓這兩種情境都能和 bool 互相轉換。 或是另外一種資料庫設計不當的情境，例如一張表將時間區間欄位設計成數字代表小時，另外一張表的時間區間欄位可能是代表分，這種不一致很容易造成程式中操作的困難，維護的工程師常常需要分心想現在這個數字代表的是時、分還是秒，也容易不小心弄錯產生 bug。 這時候不管是新專案還是重整舊系統，都會面臨到資料庫欄位變更困難但又不想讓程式遷就資料庫不當設計的兩難。 這時候也很適合用不同的 Value Converters 來轉換數字和 TimeSpan 之類的一致的型別，提升程式碼的可維護性。 抽象來說，就是當資料庫和程式中的型別無法用預設機制轉換時，就可以考慮客製化 Value Converters. 實作另外繼承並實作 ValueConverter&lt;&gt;首先我們可以參考 EF Core 內建的各種 Value Converters 來實作，例如：DateTimeToTicksConverter.cs。 提供一個客製的 Attribute提供一個 ValueConverterAttribute，讓使用者可以放在 Entity Domain Model 中如下：12345678910[Table("PERSON")]public class Person&#123; [Column("WHATEVER")] public bool Whatever &#123; get; set; &#125; [Column("IS_DELETED")] [ValueConverter(typeof(BooleanToTrueFalse))] public bool IsDeleted &#123; get; set; &#125;&#125; Whatever 欄位就是正常的布林值 (0 和 1)，而 IsDeleted 標記套用 BooleanToTrueFalse 這個 Value Converter 來適應資料庫中不當的真假值 (1 和 2)，在程式中我們可以一致的操作 bool，而資料庫的整理則可以等程式整理完後再另外分案處理。 DbContext 中的實作這是非常重要的一部份，如果我們照官方文件的作法，會讓 DbContext 和 ValueConverter 直接且高度依賴，這邊我們透過 ValueConverterAttribute 來解除他們的依賴，程式碼範例如下： 123456789101112131415161718192021222324252627282930public class MyDbContext : DbContext&#123; private string _entityAssemblyName; public MyDbContext( DbContextOptions&lt;MyDbContext&gt; options, Setting settings) : base(options) &#123; _entityAssemblyName = settings.EntityAssemblyName; &#125; protected override void OnModelCreating(ModelBuilder modelBuilder) &#123; var entityTypes = Assembly.Load(_entityAssemblyName).GetTypes(); foreach (var type in entityTypes) &#123; var entity = modelBuilder.Entity(type); foreach (var property in type.GetProperties()) &#123; var converterAttribute = property.GetCustomAttribute&lt;ValueConverterAttribute&gt;(); if (converterAttribute != null) &#123; var converter = (ValueConverter)Activator.CreateInstance(converterAttribute.Type); entity.Property(property.Name).HasConversion(converter); &#125; &#125; &#125; &#125;&#125; 我們可以在 OnModelCreating 中透過偵測 ValueConverterAttribute 以及反射來設定 Value Conversions。 要注意這個只是用來展示概念，細節部分還需要視情況仔細設計。 其他應用這種設計不限於本文提到的 Value Converters 的情境，只要是會在 MyDbContext 中的各方法中和外部 (例如 Entity Domain Model) 產生直接依賴的情境，都可以用這種設計來解耦。 注意事項以下是一些重要的注意事項： 直接搜尋組件來找出標有特定 Attribute 的成員是效能很差的做法，在本例中可以接受是因為 OnModelCreating 只會在初始化時執行一次，整體效能影響不大，加上我遇到的是非常重視解耦與彈性的情境，所以是利大於弊的。 這種設計不適用於無跨專案共用需求的 DbContext。 結論基礎用法其實官方文件都有，但是實務上往往比文件上的範例複雜，這時候就需要變通並試著找出其他更適合的解決方案，但也要了解到不同的機制各有不同的缺點，需要謹慎評估。 參考Value Conversions ValueConversion on GitHub]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在 Switch-Case 中使用重名區域變數與延伸探討]]></title>
    <url>%2Fcontent%2F20231217-switch-case-variable-scoping.html</url>
    <content type="text"><![CDATA[問題起始於一個情境如下：1234567891011121314switch (cryptoType)&#123; case CryptoType.AesEncrypt: var key = ""; var iv = ""; break; case CryptoType.AesDecrypt: var key = ""; var iv = ""; break; // Others default: break;&#125; 這時候因為 case 之間的區域變數名字重複了所以編譯不會通過。 現實情境更複雜，CryptoType 可能有幾十個。 這邊要先聲明，理論上這種大量的 switch-case 有很多設計可以管理它，但實務上是一個老舊又缺乏架構的專案，甚至亂到重構後的檔案放哪都只會更亂的程度，而如果只是抽出方法，那一些簡單的情境就會因此被抽出大量小型方法，且都放在同一個類別中也不會比較好。 總之，這個例子只是拿來說明區域變數與其作用域和生命週期，不表示例子中的設計是恰當的。 使用區塊限定作用域在 cases 中建立利用區塊 {} 建立獨立的作用域： 123456789101112131415161718switch (cryptoType)&#123; case CryptoType.AesEncrypt: &#123; var key = ""; var iv = ""; &#125; break; case CryptoType.AesDecrypt: &#123; var key = ""; var iv = ""; &#125; break; // Others default: break;&#125; 區塊 (Block) 與區域變數生命週期在 C# 中，區塊 {} 不僅是 if、for 等控制流語句的一部分，也是作用域的界定者。在一個區塊內定義的區域變數，其作用域限定在該區塊內。這意味著同一變數名可以在不同區塊中獨立使用，不會相互影響。 另外如果有必要的時候，使用區塊來限定變數的作用域，不僅有助於解決命名衝突，還可以讓區域變數因為結束區塊而釋放。 但是這樣做會犧牲很大的可讀性與可維護性去得到微乎其微的效益，只能說 “理論上可以這樣做”。 另外，基於好奇稍微去看了 C# 的語言規格書怎麼描述這種基礎到不知道怎麼描述的語法，才發現其實這些看似基礎的東西，細節還真的不少，例如： 區域變數、區塊。 結論其實單獨用區塊控制區域變數的生命週期就是一句話的事，實在很猶豫要不要寫成一篇。 但實務上可能還是會遇到要維護肥大的 switch-case 又無法改設計的情境，導致變數名稱常常重複，如果不用區塊分隔開就會出現為了避免區域變數重名而產生冗長難閱讀的變數，也會讓變數命名時還要去考慮現存的 case 中會不會出現相同的名字造成細微卻常態出現的干擾。 想想還是寫一篇紀錄一下好了。 參考C# standard specification]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[設計 WebAPI 通用回傳模板]]></title>
    <url>%2Fcontent%2F20231216-consistent-webapi-returns.html</url>
    <content type="text"><![CDATA[在我以往的工作經驗中，處理過不少 WebAPI 的維護工作，普遍面臨的一個問題是回傳資料的不一致性。舉例來說，常見的幾種回傳格式包括： 純值： true、100 等，會出現在回傳單一值的 API 中。 物件： {&quot;name&quot;: &quot;Ron&quot;, &quot;gender&quot;: &quot;Male&quot;}，會出現在回傳物件的 API 中。 物件含狀態： {&quot;status&quot;: &quot;1001&quot;, &quot;name&quot;: &quot;Ron&quot;, &quot;gender&quot;: &quot;Male&quot;}，會出現在呼叫端需要知道更多狀態細節時。 其他變種：除了資料外還有各種狀態、錯誤、訊息等欄位，但格式與名稱不統一。 這個現象造成的問題就是明明是同一個站台對外提供服務，回傳的狀態訊息卻每個 API 都不一樣，不僅對使用者不友善，也會讓接手維護的人無所適從。 本篇文章會介紹並分析的幾種解決方案，所有方案都有高一致性與關注點分離的共同優點，但也有些不同的缺點。 用 Header 表示狀態這是個很常見的做法，用 Header 表示狀態，而回傳的 Body 中則只包含資料本身。 優點 把狀態和資料徹底區分開，具有高度彈性和相容性，尤其適合於需要回傳非字串類型資料 (如串流、multipart/form-data) 的情境。 缺點 管理不便 需要較多文件輔助。 需要適當設計來集中來收納各種 Header 的常數，避免到處散落的 Magic String。 較不直覺，開發者和使用者都需要認知到 Header 中有包含狀態訊息。 用基底類別收納狀態相關欄位123456789101112public class ResponseModelBase&#123; public string Status &#123; get; set; &#125; public string Message &#123; get; set; &#125;&#125;public class Person : ResponseModelBase&#123; public string Name &#123; get; set; &#125; public Gender Gender &#123; get; set; &#125;&#125; 如上面範例，使用 ResponseModelBase 做為基底類別來收納狀態類的資訊，他會被所有 API 的回傳類別繼承，他與使用 Header 的解決方案有著相似的優點並解決了一些 Header 的缺點，但也產生不同面相的缺點。 優點 管理稍微容易，只需要提到繼承 ResponseModelBase 即可。 直覺，狀態就在 Body 中。 缺點 只支援回傳字串的情境。 如果衍生類別 (如 Person) 與基底類別 (如 ResponseModelBase) 有同名欄位，會造成命名上的困擾、缺陷或混淆。 由於無法預測未來的規格變化，這種風險難以避免。 (基底類別的欄位用很特殊的命名不算個解法)。 繼承通用泛型類別1234567891011121314public class ResponseModel&lt;T&gt;&#123; public string Status &#123; get; set; &#125; public string Message &#123; get; set; &#125; public T Data &#123; get; set; &#125;&#125;public class Person&#123; public string Name &#123; get; set; &#125; public Gender Gender &#123; get; set; &#125;&#125; 如上範例，借用以包含取代繼承的概念，設計泛型類別取代基底類別，而 API 回傳的型別則會變成 ResponseModel&lt;Person&gt;。 優點 管理稍微容易，只需要提到 ResponseModel&lt;T&gt; 即可。 直覺，狀態就在 Body 中。 基礎類別 (如 Person) 不用擔心和 ResponseModel&lt;T&gt; 中的欄位同名。 缺點 只支援回傳字串的情境。 比起繼承，泛型型別在使用時的程式碼比較冗長。 結論這幾種方案各有利弊，但至少都能解決文章開頭提到的一致性、維護性和使用者友好度的問題。總結建議如下： 當預期會回傳非字串型態的 Body 時，選擇 Header 解決方案，但需要注意管理的複雜性。 當預期只會回傳字串 Body 時，選擇泛型解決方案。 不要選擇繼承通用類別的解法，提到他只是要記錄他和泛型型別設計上的差異。 參考開發經驗。]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[客製 .NET 程式碼分析與自動修正]]></title>
    <url>%2Fcontent%2F20230812-write-roslyn-analyzer-and-code-fix.html</url>
    <content type="text"><![CDATA[.NET 編譯器平台 (Roslyn) 分析器 提供很多有用的程式碼分析規則讓我們更容易維持良好的程式碼品質，但有時候我們會需要自己定義一些規則來符合專案開發規範。官方以及其他網路文章其實已經提供了不少資訊，但因為步驟和說明真的很多，了解起來太花時間，於是想自己來整理一下讓需要的人可以快速走完所有步驟。 用 Visual Studio 樣板建立專案 打開 Visual Studio (這邊用 2022 版來示範)。 File &gt; New &gt; Project，選擇 Analyzer with code fix (.NET Standard) 如下圖： 找不到的話就是沒安裝相關元件，參考官方說明來安裝。 下一步繼續設定名稱路徑等，這邊要注意的是 Framework 選單沒有意義，不管選哪一個建立的方案都是一樣的版本，所以不用費心挑選。 建立完成如下圖，會得到四個專案，詳情參考官方介紹。 建立規則並發佈開發與測試從剛剛建立的方案所提供的範本為起點。 MyRoslynAnalyzer 專案中寫的是主要的程式碼分析規則。 MyRoslynAnalyzer.Test 專案中寫的是測試。 MyRoslynAnalyzer.Package 提供一些製作 NuGet Package 時候所需要的設定與工具。 預設就可以用不需要改。 MyRoslynAnalyzer.Vsix 設定為起始專案啟動後會另外開一個 Visual Studio 來套用前面寫的規則。 我會刪掉這個專案。他也是預設就可以用，但會多開一個 Visual Studio，這樣交錯操作對我來說容易搞混，不如單元測試完直接把 NuGet Package 放在自己本機然後用固定的專案測試。但是這個做法是因為我已經建好本機 NuGet 儲存庫了，建立本機 NuGet 儲存庫的方法之前有寫過一篇 在本機上建立 NuGet 儲存庫。 開發建議 Hello World 從 官方提供的範例專案 開始看。 綜合參考 StyleCopAnalyzers 和 roslyn-analyzers 來進一步學習。 資料夾結構與命名等參考 StyleCopAnalyzers。這是因為他用編號命名，資料夾結構用規則分類來做，整體專案也比較單純，這對維護來說很方便。 實作細節參考 roslyn-analyzers。這是因為 StyleCopAnalyzers 畢竟是另外一套工具，他有一些自定義的內容，相較之下參考 roslyn-analyzers 的實作能最大限度的利用內建的物件避免自造輪子或額外依賴另一個套件的物件增加沒必要的複雜度。但是 StyleCopAnalyzers 的資料夾複雜，要找到可以參考的規則還真不太好找，但因為所有規則都會繼承 DiagnosticAnalyzer 類別並加上 DiagnosticAnalyzerAttribute，以這個為進入點就會好找很多。 從最簡單的命名規則開始，會比較容易建立信心。 善用 ChatGPT 或 GitHub Copilot 輔助。AI 在這類很常見的情境上表現得很好，我自己就只用 AI 加預設範例就實作出一些簡單的規則了。 發佈發佈的話就是直接編譯 MyRoslynAnalyzer.Package 並用 Visual Studio 內建的功能來製作 nupkg 檔就好，很方便。 結論其實入門不難，但是就是官方文件非常長所以要看很久。 參考Overview of source code analysis How to write a Roslyn Analyzer Roslyn Analyzer Part 1 - 5 roslyn-analyzers StyleCopAnalyzers]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[樂觀鎖與悲觀鎖的選擇]]></title>
    <url>%2Fcontent%2F20230721-optimistic-vs-pessimistic-lock.html</url>
    <content type="text"><![CDATA[在資料庫操作時，面對多個操作的並行操作，為了避免資料不一致和衝突我們主要有兩種方法可以達成這個目標：樂觀鎖 (Optimistic Lock) 和悲觀鎖 (Pessimistic Lock)。但我們應該如何選擇適合的方法呢？ 樂觀鎖和悲觀鎖的實作網路資源太多了，這篇不會特別提。 樂觀鎖分析個人經驗來說，會用一個 Version 欄位來記錄版本，在寫入資料時再判斷版本是否因為被其他操作更新過，以此為依據來避免互相覆蓋。 特性 由應用程式控制而不是資料庫中真實的鎖。 衝突時比較晚更新的那個操作會被取消，應用程式中可能會拋出例外。 優點 Entity Framework Core 和 NHibernate 等 ORM 有支援樂觀鎖，使用方便。 缺點 衝突時比較晚更新的那個操作如果一定要更新就需要有重試機制，當衝突率高時重試開銷會很高。 操作取消並重試的機制在效能上必然較差，重試機制要兼顧資料正確性時較複雜。 適用情境 衝突時只需要認列第一個操作時。 衝突時需要認列後面的操作，但是不能直接寫入而需要重新執行一些商務邏輯再更新才正確時。 悲觀鎖分析悲觀鎖又稱行鎖 (Row Lock)，一開始操作時就先把該筆資料鎖定，防止其他操作修改該資料，解鎖後其他操作會繼續執行，它可以預防衝突，而不是在事後解決衝突。 特性 由資料庫提供的行鎖。 衝突時所有操作會排隊在解鎖後依序執行。 優點 避免事後處理衝突的開銷。 缺點 Entity Framework Core 和 NHibernate 等 ORM 不直接支援，如果要使用會需要用純 SQL 下指令，以 Oracle 來說就是 SELECT C1, C2 FROM T1 FOR UPDATE。 鎖定時資料無法被修改，如果因為操作不當而沒有及時解鎖，就會嚴重影響效能。 適用情境 衝突時多個操作可依序執行時(例如後面的變更覆蓋之前的變更是正確的時)。 結論這兩種鎖互有優缺，應該要適當的搭配使用。 參考ChatGPT]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[參考型別當 Dictionary Key 的注意事項]]></title>
    <url>%2Fcontent%2F20230720-reference-type-as-dictionary-key.html</url>
    <content type="text"><![CDATA[Dictionary&lt;TKey, TValue&gt; 是很常用的資料結構，我們可以使用索引子 (Indexer) 透過特定的 Key 來存取資料。 但使用時，我們要特別注意 Key 的型別，使用值型別作為 Key 通常不會有問題，但當使用參考型別作為 Key 時就不一定了。 使用參考型別作為 Key 時的存取先看下面程式碼：1234567891011121314151617public class TwoValue&lt;T1, T2&gt;&#123; public TwoValue(T1 v1, T2 v2) &#123; Value1 = v1; Value2 = v2; &#125; public T1 Value1 &#123; get; &#125; public T2 Value2 &#123; get; &#125;&#125;// The key is `new TwoValue&lt;int, int&gt;(1, 2)`var dic = new Dictionary&lt;TwoValue&lt;int, int&gt;, string&gt;();dic.Add(new TwoValue&lt;int, int&gt;(1, 2), "Hello");dic.TryGetValue(new TwoValue&lt;int, int&gt;(1, 2), out var v1).Dump(); // falsev1.Dump(); // null 從 Dictionary 的 Add(…) 方法 中可以看到，在新增項目的時候，Key 的部分是以呼叫 GetHashCode() 方法所得到的結果為基準產生的。我們也知道參考型別的不同物件，呼叫 GetHashCode 得到的結果會不同，所以新增項目後又以另外一個新建的 TwoValue 物件為 Key 去查詢，就會因為新物件的 GetHashCode() 回傳和 Dictionary 內物件的不同而找不到。 關於 Object.GetHashCode() 怎麼運作、和物件的實際記憶體位置有什麼關係、和 Object.Equal(object) 又有什麼關係，之後再找時間仔細了解。 使用 Tuple 作為 Key 時的存取但是如果使用的是 Tuple 就不同了，如下範例：123456// The key is `new Tuple&lt;int, int&gt;(1, 2)`var dic = new Dictionary&lt;Tuple&lt;int, int&gt;, string&gt;();dic.Add(new Tuple&lt;int, int&gt;(1, 2), "Hello");dic.TryGetValue(new Tuple&lt;int, int&gt;(1, 2), out var v2).Dump(); // truev2.Dump(); // "Hello" 雖然 Tuple&lt;T1,T2&gt; 是參考型別，但因為他覆寫了 GetHashCode() 方法 使得產生的雜湊值其實是源自於它包含的 T1 與 T2 的雜湊值，所以才會造成參考型別的 Key 即使是不同物件也能用來查詢 Dictionary 項目的現象。 這點其實很重要，如果不知道這些細節，可能會因為這些程式碼執行結果而反向推斷出像是 “Tuple 是值型別” 這樣的錯誤認知，或是對參考型別的特性產生困惑與混淆。 使用包含參考型別的 Tuple 作為 Key 時的存取經過上面兩種情境的示範，應該不能猜出這個情境會有什麼結果了，範例如下：1234567891011121314151617public class TwoValue&lt;T1, T2&gt;&#123; public TwoValue(T1 v1, T2 v2) &#123; Value1 = v1; Value2 = v2; &#125; public T1 Value1 &#123; get; &#125; public T2 Value2 &#123; get; &#125;&#125;// The key is `new TwoValue&lt;int, int&gt;(1, 2), 3)`var dic = new Dictionary&lt;Tuple&lt;TwoValue&lt;int, int&gt;, int&gt;, string&gt;();dic.Add(new Tuple&lt;TwoValue&lt;int, int&gt;, int&gt;(new TwoValue&lt;int, int&gt;(1, 2), 3), "Hello");dic.TryGetValue(new Tuple&lt;TwoValue&lt;int, int&gt;, int&gt;(new TwoValue&lt;int, int&gt;(1, 2), 3), out var v3).Dump(); // falsev3.Dump(); // null 因為 Tuple&lt;T1, T2&gt; 是以其所包含的型別參數們的雜湊值為基礎去產生他自己的雜湊值，所以當然如果型別參數中有參考型別，那整個 Tuple&lt;T1, T2&gt; 的雜湊值就可能 (如果他沒有改變 GetHashCode() 的行為) 會因為其所包含的成員產生不同雜湊值而最終結果也不同，不能單以型別參數是參考型別而判定他適合做為 Dictionary 的 Key。 結論總結來說就是， Dictionary&lt;TKey, TValue&gt; 中的 TKey 盡量不要用參考型別，如果要用得要確定他不會產生上述的疑慮。 其實不難理解，但是很難用文字說明，自己看起來都像是在繞口令… 參考Reference Source]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 部分類別 (Partial Class) 的使用建議]]></title>
    <url>%2Fcontent%2F20230709-using-partial-class.html</url>
    <content type="text"><![CDATA[在 C# 中，partial class 可以讓開發者把一個類別分散到多個檔案中。當程式編譯時，這些分散的部分會被合併成一個單一的類別。這篇會根據以往經驗來紀錄一下使用建議。 設計建議檔名名稱檔名名稱應該是 &lt;Class&gt;.&lt;Category&gt;.cs 這樣的格式。 例如一個類別 Product 有一個 Product.cs 檔案包含了產品的部分資訊，當需要建立另外一個部分類別來包含商品屬性的時候，這個新的部分類別可以放在另外一個 Product.Properties.cs 檔案中，這樣做的好處有幾個： Product.cs 是主要資訊，其他資訊可以依照分類建立在不同檔案中，非常清楚也容易維護。 使用如果 Visual Studio 開發，建立檔案 Product.Properties.cs 的時候它預設的的類別就會是 Product，且對程式碼分析工具來說也是符合規範的 (至少我用過的程式碼分析是這樣)。 即便不是使用 Visual Studio 開發，在程式編碼規範的訂定上也比較容易，例如：一般會要求主檔名要符合類別名稱，這在部分類別的情境也適用。 細節可依狀況調整，但大方向依照 &lt;Class&gt;.&lt;Category&gt;.cs 這樣的模式是副作用最小的。 檔案管理同一個類別的所有部分類別檔案放在同一個資料夾下，避免檔案四散各處而難以追蹤整個類別的完整樣貌。 共用成員的管理這個主題包含建構子、共用欄位、共用屬性、共用方法等需要在被不同檔案中的部分類別共用的情境。 通常我會把共用成員放在主要檔案中，例如： Product.cs 中就包含所有共用成員，且要維護過程中需要時刻注意呼叫方法時是否會破壞這個原則。 適用情境隔離自動生成 (Auto-Generated)的程式碼有時候我們需要透過工具或框架自動產生程式碼，最常見的情況就是 ORM (如 Entity Framework）所產生的資料模型 (Entity Data Model)，我們不應該去修改這些自動生成的程式碼，避免之後重新生成覆蓋掉我們的修改，這時候就可以用部分類別來擴充與維護，範例如下：1234567891011121314151617// Person.cspublic partial class Person&#123; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public DateTime DateOfBirth &#123; get; set; &#125;&#125;// Person.Aggregation.cspublic partial class Person&#123; public string FullName &#123; get =&gt; FirstName + " " + LastName; &#125;&#125; 這樣一來當重新產生資料模型的時候就只會影響到工具所管轄的檔案 Product.cs 而已。 大類別的拆分有些類別因為定義的過於抽象且現實不允許重構時，就可以透過將一個大類別細分成多個小的部分類別，提升一點可維護性；另外一種是資料容器型的類別 (Model)，尤其是 Context 或是 Metadata 這一類的類別很容易就包山包海，稍微分類一下也是有幫助。 但是要注意的是：如果適合，一開始就設計成不同類別會更理想；如果不適合設計成不同類別，那再來考慮部分類別。 分階段重構時有些包袱特別重的專案，裡面會有很肥又很亂的類別，偏偏又不允許一次到位的重構整個類別，這時候就會需要分階段重構。而分階段重構時必然會面對邊重構邊維護的困境，使得一個原本就很亂的類別中的程式碼新舊交融，因而更難以維護，也容易因為維護不當導致亂上加亂。 這邊的新舊交融不是指重構後留著舊程式碼不刪，而是有些重構了但有些還沒做的意思。 這時候可以把舊的程式碼直接改成部分類別留在原本的檔案 GhostStory.cs 中，另外建立一個新檔案 GhostStory.Refactoring.cs 包含整理過的程式碼，達到分階段重構期間仍然可以維護舊的程式而不會互相干擾的效果。 等到幾百年後重構終於完成了，就可以刪掉舊的 GhostStory.cs 後再把 GhostStory.Refactoring.cs 重新命成回 GhostStory.cs 並移除 partial 關鍵字就完成了。 缺點與誤用風險分類不當或程式放在不適合的檔案用部分類別雖然可以達到大類別分類管理的效果，但如果分類不當或將程式放在不適合的檔案中，反而會增加維護難度。 共用成員難管理當多個不同檔案的方法需要呼叫共用成員時，那個共用成員要放在哪個檔案也是個不好決定的主題，甚至複雜一點會產生多個檔案間的方法交錯呼叫而難以追蹤與管理。即使一開始決定好了，維護過程也要一直注意呼叫關係是否恰當以及是否要讓成員換檔案住的問題。 這點是最難掌控的，因為很容易隨著維護的過程慢慢歪掉。 逃避設計或重構部分類別算是備用方案，如果不先考慮好好設計而一股腦地使用部分類別的話，還是會產生一個大雜燴風格的類別，違反了單一職責原則 (Single Responsibility Principle) 且容易讓程式碼的可維護性快速下降。 結論部分類別是個很好用的工具，但如果使用不當，再好用的工具都會砸到自己的腳，所以設計時應該要綜合考慮優缺點與副作用以及需要的取捨後再做決定。 參考ChatGPT 開發經驗 Naming Conventions For Partial Class Files Best Practices: When not/to use partial classes]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 ORM 做單次大查詢的效能陷阱]]></title>
    <url>%2Fcontent%2F20230617-large-scale-query-with-orm.html</url>
    <content type="text"><![CDATA[在開發過程中，我們經常需要透過 ORM (我是使用 EF Core) 從資料庫中取得資訊，在查詢很複雜的時候我通常都會盡量透過一個查詢就把資料準備好，並轉換成巢狀的資料結構以便於應用程式進行操作，這樣可以避免多次查詢造成的效能風險。 但前陣子在開發過程檢查 ORM 產生的 SQL 時意外發現我的認知不一定是對的。 問題因為單次大查詢雖然能避免多次來回查詢的成本，但是當遇到巢狀的資料結構的時候，單次大查詢轉換出來的 SQL 可能會非常糟，問題主要可以分成兩個方向。 這邊先附上一個複雜的 LINQ 查詢與透過 EF Core 轉化出來的 SQL 作為下面說明的參考資料： 1234567891011121314151617181920var courseDetails = _dbContext.Set&lt;Course&gt;() .Where(c =&gt; c.Id == id) .Select(c =&gt; new Detail &#123; Id = c.Id, Name = c.Name, Teacher = c.Teacher.Name, Students = c.Students.Select(s =&gt; new Student &#123; Id = s.Id, Name = s.Name, Grade = s.Grades.FirstOrDefault(g =&gt; g.CourseId == c.Id).Grade, PersonalInfo = new PersonalInfo &#123; Address = s.PersonalInfo.Address, PhoneNumber = s.PersonalInfo.PhoneNumber, &#125; &#125;).ToList(), &#125;) .SingleOrDefault(); 123456789101112131415161718192021222324SELECT "c"."Id", "c"."Name", "t"."Name", "s"."Id", "s"."Name", (SELECT "g"."Grade" FROM "Grades" AS "g" WHERE ("g"."CourseId" = "c"."Id") AND ("g"."StudentId" = "s"."Id") FETCH FIRST ROW ONLY), "p"."Address", "p"."PhoneNumber"FROM "Courses" AS "c" LEFT JOIN "Teachers" AS "t" ON "c"."Id" = "t"."CourseId" JOIN ( SELECT "s".*, "cs"."CourseId" FROM "Students" AS "s" INNER JOIN "CourseStudents" AS "cs" ON "s"."Id" = "cs"."StudentId" ORDER BY "cs"."CourseId" ) AS "s" ON "c"."Id" = "s"."CourseId" LEFT JOIN "PersonalInfos" AS "p" ON "s"."Id" = "p"."StudentId"WHERE "c"."Id" = :idORDER BY "c"."Id", "s"."CourseId" 這個問題是工作上遇到的也已經確認過問題的確存在，但當然不能拿公司實際資料當範例，所以這邊用 ChatGPT 產生 LINQ 和 SQL 來當範例，因為是機器產生的和實際運作產生的 SQL 不一定會相同甚至無法運作，但作為展示概念的參考資料已經足夠了。 大量多餘的資料這部分可以用 SQL 搜尋出來的資料是一個表格為出發點去理解，因為透過 SQL 沒辦法直接搜尋出一個巢狀的資料結構，所以在查到的資料到應用程式的巢狀類別中間勢必要經過轉化，而這個轉化是發生在應用程式中的。 從上面的範例來看，我們可以看到他產生的 SQL 因為包含大量的 JOIN 所以搜尋出來的資料筆數可能會極大，然後才在應用程式中分組整合。 而重點在於這大量的資料中的多數欄位都是重複的內容。 以實際遇到的情境來說，我只是要搜尋一筆主資料，但因為關聯到很多其他資料表所以實際上搜尋出幾千筆的資料，然後在應用程式中將幾千筆資料分組整合成一個巢狀類別。 這會造成的問題有： 無謂的記憶體消耗，甚至 GC 的負擔透過上面描述，可想而知這幾千筆中重複的內容會造成多少無謂的記憶體消耗，如果資料夠大還可能會進一步造成 GC 的負擔。 提高對 CPU 的負擔這點也很好理解，大量資料的轉化需要很多運算資源。 不必要的排序另外一個就是不必要的排序，從前面的範例可以發現所產生的不必要的排序，這個排序會使得 SQL 本身的查詢成本大幅提高。 至於為什麼會排序，根據 ChatGPT 的說法是：Entity Framework Core 在產生 SQL 語句時，會在某些情況下插入排序操作，以確保返回的資料符合 C# 的 LINQ 查詢的順序。這通常發生在涉及集合導航屬性的查詢中，因為 EF Core 需要保證資料的順序與原始查詢相符。這種排序操作是 EF Core 為了處理導航集合屬性（如 c.Students）而添加的。它需要按照外鍵（在這裡是 CourseId）的順序來獲取相關的 Students，以便能夠正確地建立回傳的物件。 解決方案解決方式其實就是把單次大查詢轉化成多次小查詢，如下範例。 var courseDetails = _dbContext.Set&lt;Course&gt;() .Where(c =&gt; c.Id == id) .Select(c =&gt; new Detail { Id = c.Id, Name = c.Name, Teacher = c.Teacher.Name, }) .SingleOrDefault(); courseDetails.Students = _dbContext.Set&lt;Student&gt;() .Where(s =&gt; s.Courses.Any(c =&gt; c.Id == courseDetails.Id)) .Select(s =&gt; new Student { Id = s.Id, Name = s.Name, Grade = s.Grades.FirstOrDefault(g =&gt; g.CourseId == courseDetails.Id).Grade, PersonalInfo = new PersonalInfo { Address = s.PersonalInfo.Address, PhoneNumber = s.PersonalInfo.PhoneNumber, } }).ToList(); 因為被拆成幾段小查詢，所以每一段查詢都會降低 JOIN 的數量 (甚至沒有)，因此就能避免單次大查詢的效能陷阱了。 但這邊還是要注意，不是把巢狀拆掉分開就是好的，如果 JOIN 後的資料量很小，多次小查詢的效能是可能比單次查詢要差的，這部分就變成要因地制宜來判定了。 總結以前總是覺得多個小查詢查資料效能比較差，沒想到其實不一定。 總結一下巢狀物件的查詢心得： 看到巢狀物件考慮拆成多個小查詢。 巢狀部分的資料量很大或預期會快速成長時，拆成小查詢可能比較好。 巢狀部分的資料量很小且幾乎不會增長時，不拆可能程式碼會比較整潔。 拆與不拆之間，要綜合考量可讀性、效能差異幅度、資料是否會增長…等多個要素，也可將 ORM 所產生的 SQL 印出來後分析以協助判斷。 參考ChatGPT]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 SourceBrowser 建立原始碼瀏覽網站]]></title>
    <url>%2Fcontent%2F20230312-use-source-browser.html</url>
    <content type="text"><![CDATA[Reference Source 是一個非常方便的資源可以用來查看 .NET Framework 的程式碼，而這個網站是利用 SourceBrowser 所建立的。 對於我們自己開發的專案，雖然都有原始碼好像用不到這個工具，但很多時候想快速查看程式碼卻又不想耗費資源在執行 IDE 上的時候(尤其同時維護多專案的時候)，這個工具能提供一個不錯的介面來使用。 官方提供了基本的使用教學，但要開 Visual Studio 來編譯 SourceBrowser 專案，比較不方便，所以這邊會使用官方也有提供的 NuGet Package 來做，稍微紀錄一下過程，讓之後需要的時候能更快的使用。 基本使用步驟下載 NuGet Package下載 NuGet Package 後解壓縮後只留下 tools 資料夾。 使用 HtmlGenerator.exe 來建立資料根據 GenerateTestSite.cmd 可以知道我們需要用 HtmlGenerator.exe 來解析目標專案並輸出到指定目錄下，如下範例：1tools\HtmlGenerator.exe "MyGithub\MoreNet.Cryptography\MoreNet.Cryptography.sln" /out:tools\site 將輸出結果佈署到伺服器上根據 RunTestSite.cmd 可以知道我們需要使用 Microsoft.SourceBrowser.SourceIndexServer.dll 來啟動 SourceBrowser 站台 (也可以直接執行 Microsoft.SourceBrowser.SourceIndexServer.exe)，例如：1dotnet Microsoft.SourceBrowser.SourceIndexServer.dll 如果是在本機執行，從瀏覽器瀏覽 http://localhost:5000 就可以看到結果了，也可以佈署到伺服器上提供線上查詢。 其他 相關的指令可以自己寫成 *.bat 檔方便重複使用。 產生出來的內容至少依賴 dotnet，詳細資訊見官方說明，我本機上環境太雜沒辦法精準驗證需要哪些依賴。 可能還有其他使用方式和參數，但目前不急著知道所以需要的時候再看 GitHub 就好 結論雖然從 GitHub 或其他線上儲存庫就能直接看程式碼，但是 SourceBrowser 提供更強大的功能來查看程式碼之間的參考與依賴關係，還是能讓我們更有效率的查看程式碼。 唯一美中不足的是它不是靜態網站且有一些框架的依賴，所以佈署成本滿高的。 參考SourceBrowser]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 using 以及當例外從 finally 區塊拋出時的問題]]></title>
    <url>%2Fcontent%2F20230311-problem-about-exception-from-finally-block-of-using.html</url>
    <content type="text"><![CDATA[當我們想要使用實作 IDisposable 的型別時，using 關鍵字通常是不二人選，但是其中卻包含一些小陷阱 (嚴格來說不是陷阱，是實作 IDisposable 的時候沒做好)。 背景知識:using 關鍵字就是 try-finally 加上呼叫 IDisposable.Dispose() 的語法糖，沒把握的話找個反組譯工具確認一下就知道了。 有可能的問題捕捉不到的例外首先，用下面的範例程式來說明：1234567public class Foo : IDisposable&#123; public void Dispose() &#123; throw new Exception("a"); &#125;&#125; 1234567891011121314// callerusing (var f = new Foo())&#123; try &#123; // do something &#125; catch (Exception) &#123; // do something &#125;&#125; // exception thrown here.// never executed from here. 我們有一個實作 IDisposable 的類別，這個類別模擬在 Dispose 方法中拋出例外，而上面的程式碼因為 Foo.Dispose() 拋出例外而使得看起來能正常捕捉例外的程式碼其實是會有漏洞的。 拋出預期外的例外那如果把 try-catch 區塊移到 using 外呢？以下方程式來說明： 1234567public class Foo : IDisposable&#123; public void Dispose() &#123; throw new Exception("a"); &#125;&#125; 123456789101112// callertry&#123; using (var f = new Foo()) &#123; throw new Exception("b"); &#125;&#125;catch (Exception ex)&#123; // got exception from Foo.Dispose() and missing the one from try block.&#125; 一樣的 Foo，不一樣的呼叫端，但是這樣使用會造成呼叫端的 catch 區塊中捕捉到的例外其實是 Foo.Dispose() 拋出的例外，這意味著當呼叫端程式發生例外時，錯誤根本不會被捕捉到，也就代表當 Production Issue 發生時，會完全看不到呼叫端程式真正的例外，在有時間壓力下發生這種事是很可怕的。 問題總結這件事的根本原因是因為在 using 的 finally 區塊中拋出例外使得呼叫端誤以為自己有考慮到所有例外，或是呼叫端誤以為自己能捕捉到 try 區塊中的例外，但其實不然。 解決方案服務提供方確保 IDisposable.Dispose() 不拋出例外如果要實作 IDisposable，必須確保 IDisposable.Dispose() 方法中不會拋出例外。 (不推薦) 呼叫端避免使用 using就是用手動釋放資源取代 using，如下： 12345678910111213var f = new Foo();try&#123; throw new Exception("a");&#125;catch (Exception)&#123; // do something&#125;finally&#123; // release in anther way instead of calling Dispose()&#125; 一般來說，這個問題應該是服務提供方應該要注意的，所以除非確定服務提供方有這個缺陷且沒辦法要求改正，不然不推薦將這種作法作為預設選項。 (很不推薦) 呼叫端用多個 try-catch 暴力解很不推薦的做法，雖然簡單但太過暴力，很醜且維護的人很容易覺得這是多餘的而拆掉其中一個 try-catch 區塊。123456789101112131415161718try&#123; using (var f = new Foo()) &#123; try &#123; throw new Exception("a"); &#125; catch (Exception ex) &#123; // do something &#125; &#125;&#125;catch (Exception ex)&#123; // do something else&#125; 結論會想寫這篇是源於這個已知的問題，但我覺得這是微軟的鍋，不應該因噎廢食而放棄 using，但萬一遇到了，還是要知道有這個現象來避免鬼打牆找不到問題，所以需要紀錄一下來加強印象。 參考Close and Abort release resources safely when network connections have dropped]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hangfire 搭配 Redis 時的資料清理機制]]></title>
    <url>%2Fcontent%2F20230114-auto-delete-jobs-for-hangfire-with-redis.html</url>
    <content type="text"><![CDATA[Hangfire 是很常用的定時排程工具，他會將排程和任務資訊紀錄在資料庫中，但是如果使用 Redis 做資料儲存時，就必須謹慎思考資料清理的問題，畢竟資料存放在記憶體中是不可能不去限制大小的。 限制資料筆數使用 Hangfire.Redis.StackExchange 的話，可以透過 RedisStorageOptions 中的 SucceededListSize 和 DeletedListSize 兩個欄位來限制成功和已刪除的任務的列表長度，避免無限制的增長。 但是問題是在於失敗的任務怎麼辦? 一開始找了很多網路文章，通常都是建議用 Job Filters 來設定，雖然看起來很合理但實測卻發現失敗列表不可以手動刪除，最後才發現可以透過 AutomaticRetryAttribute 來達到目標。 這個做法的主要邏輯是在重試次數結束後刪除，使得任務進入已刪除列表，而已刪除列表是可以設定最大長度的， AutomaticRetryAttribute 可以單獨用在需要的排程上，也可以一次設定到所有排程，如下:1234567891011// Startup.cspublic void ConfigureServices(IServiceCollection services)&#123; services .AddHangfire((serviceProvider, config) =&gt; &#123; config .UseFilter(new AutomaticRetryAttribute &#123; Attempts = 0, OnAttemptsExceeded = AttemptsExceededAction.Delete &#125;) ; &#125;)&#125; 結論失敗列表不能手動刪除的這個限制滿合理的，畢竟有重試機制存在，如果可以手動刪除那等於是和重試機制產生衝突了，倒是刪除失敗任務的設定在重試機制的設定中這點滿讓人意外的。 然後網路的解法不能盡信，要實驗過才知道能不能運作。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[透過 GET 發送 HTTP Request 的時候 Uri 過長的問題]]></title>
    <url>%2Fcontent%2F20230114-resolve-url-too-long-exception.html</url>
    <content type="text"><![CDATA[很多時候我們需要從客戶端從透過 HTTP GET 發送 Reqeust 給服務端，但在之前的一個 ASP.NET Core 的專案中卻因為 Uri 過長而出現了 Invalid URI: The uri string is too long 這樣的錯誤訊息。 這個問題網路上幾乎都是改 Web Service (例如: IIS) 的設定來解決，這是最簡單方便的方法，但如果伺服器很多或是需要經常擴充伺服器時就會造成不小的困擾，即使伺服器不多也可能因為這些瑣碎的設定造成維護上的不方便，所以這邊提供另外一種解決方案。 X-Http-Method-Override緣起X-Http-Method-Override 這個 Header 典型的用法是用於用戶端因為各種限制而無法配合服務端的要求使用特定 HTTP Method 時，以這篇文章為例， 服務端要求的是 PUT /api/Person/4，但客戶端無法配合時，就可以改用 POST /api/Person/4 搭配 X-Http-Method-Override 這個 Header (值為 PUT) 來改變實際上的 HTTP Method，這可以不需要遷就客戶端而讓服務端的設計保持一致且合理。 利用這個特性，我們可以試著讓呼叫端改用 HTTP POST 來發送以避開 Web Server 對 Uri 的長度限制。 同理，對 QueryString 的長度限制也適用。 實做首先，從這篇文章我們可以知道 ASP.NET Core 有提供相關的功能來支援 X-Http-Method-Override，但仔細看 UseHttpMethodOverride 和 HttpMethodOverrideMiddleware 的實做可以發現這並不足以滿足我們的需求，HttpMethodOverrideMiddleware 的實做只包含改變 HTTP Method 但不包含處理 Body 或 QueryString。 但至少我們知道 ASP.NET Core 對於 X-Http-Method-Override 的支援是透過 Middleware 來完成的，這樣我們就可以自己寫 Middleware 來達到想要的效果。 建立另外一個 Middleware 來處理 Body 的部分: 框架內建的部份我們就沿用就好，所以自製的 Middleware 只需要處理 Body。123456789101112131415161718192021222324252627282930313233343536373839404142public class HttpGetOverrideMiddleware&#123; private const string XHttpMethodOverride = "X-Http-Method-Override"; private readonly RequestDelegate _next; public HttpGetOverrideMiddleware(RequestDelegate next) &#123; _next = next; &#125; public Task Invoke(HttpContext context) &#123; var xHttpMethodOverrideValue = context.Request.Headers[XHttpMethodOverride]; if (HttpMethods.IsGet(xHttpMethodOverrideValue)) &#123; /* pseudo code var body = ReadFromRequestBody(); string anotherQueryString = string.Empty(); if (isJson) &#123; anotherQueryString = ParseBodyFromJsonToQueryString(); &#125; else if (isXml) &#123; anotherQueryString = ParseBodyFromXmlToQueryString(); &#125; else if (whatever) &#123; anotherQueryString = ParseBodyFromWhateverToQueryString(); &#125; context.Request.QueryString += anotherQueryString; ClearBody(); // if possible */ &#125; return _next(context); &#125;&#125; 註冊並使用: 12345678public class Startup&#123; public void Configure(IApplicationBuilder app) &#123; app.UseHttpMethodOverride(); app.UseMiddleware&lt;HttpGetOverrideMiddleware&gt;(); &#125;&#125; 如上所示，在 Middleware 那一層將 Body 轉換成 QueryString 再繼續，這樣一來 Web API 的規格仍然是合理的 HTTP GET， 呼叫端也可以透過 HTTP POST 加上 X-Http-Method-Override 來呼叫到只支援 HTTP GET 的 API。 注意事項: 將 Body 轉換為 QueryString 的過程有很多瑣碎的細節要考慮 如果原本的 Uri 就包含 QueryString 的話(不合理，但技術上可能發生)不能覆蓋掉 Body 讀取後要不要把內容清空? 不清空 Body 的話要不要允許後面的程式能重複讀取 Body? 這會影響 Body 讀取後要不要回捲 Body 資料無法用 QueryString 將 Body 轉換為 QueryString 後整個 Uri 會很長，後面的程式直接操作時要小心避免因過長拋出例外，例如:new Uri(string) 就有機會因為長度太長而拋出例外。 Startup 中呼叫 UseHttpMethodOverride() 和註冊 HttpGetOverrideMiddleware 的順序，誰先誰後比較合理? 結論這個做法看起來有點暴力，但因為 ASP.NET Core 也是用這樣的方式支援 X-Http-Method-Override 的，所以就跟隨原有的做法下去擴充了。 另外值得一提的是， ASP.NET Core 的很多功能 (例如: Health checks) 背後其實都是封裝 Middleware 後提供一個較易用或可讀性較高的 API，知道這點後也能了解很多類似的功能都可以用 Middleware 來實現，只要小心不要弄錯執行順序的話是很好用的。 參考HTTP PUT or DELETE not allowed? Use X-HTTP-Method-Override for your REST Service with ASP.NET Web API HttpMethodOverrideMiddleware.cs HttpMethodOverrideExtensions.cs]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[避免在需要使用 EF Core 的環境擴充 IEnumerable< T >]]></title>
    <url>%2Fcontent%2F20221115-do-not-let-extension-methods-of-generic-ienumerable-work-with-efcore.html</url>
    <content type="text"><![CDATA[擴充方法是很常用的技巧, 之前在使用 Entity Framework Core 的時候, 擴充了一個 IQueryable&lt;T&gt; 的擴充方法 WhereIf(), 後來想說這個方法也適用於其他衍生自 IEnumerable&lt;T&gt; 的型別, 且 IQueryable&lt;T&gt; 繼承了 IEnumerable&lt;T&gt;, 所以把 WhereIf() 方法改成 IEnumerable&lt;T&gt; 的擴充方法以求更廣的適用範圍, 沒想到一切都不一樣了, 要是當時沒及時發現就引爆了一個效能核彈了. 雖然標題是寫 Entity Framework Core, 但 IQueryable&lt;T&gt; 本來就是設計給”資料查詢”的情境來說, 其他 ORM 八九不離十會遇到一樣的現象. 問題描述以下面的程式碼為範例來說明: 123var adults = _dbContext.Set&lt;Person&gt;() // DbSet&lt;Person&gt; .Where(r =&gt; r.Age &gt;= 18) // Append condition, IQueryable&lt;Person&gt; .ToList(); // Query 我們知道在 ToList() 被呼叫前的行為都只是在組合查詢條件, 不會真正去查資料, 基於這個前提如一開始描述擴充一個 IEnumerable&lt;T&gt; 的擴充方法 WhereIf(...) 來方便使用, 如下: 1234567891011121314151617public static class EnumerableExtensions&#123; public static IEnumerable&lt;T&gt; WhereIf&lt;T&gt;(this IEnumerable&lt;T&gt; query, Func&lt;T, bool&gt; predicate, bool shouldAppendWhere) &#123; if (shouldAppendWhere) &#123; return query.Where(predicate); &#125; return query; &#125;&#125;var adults = _dbContext.Set&lt;Person&gt;() .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) // Optional filter .Where(r =&gt; r.Age &gt;= 18) .ToList(); 雖然執行結果沒錯, 但這樣做會有個很嚴重的問題, 以上面的例子來說, 當 WhereIf(...) 被呼叫時會從資料來源查詢資料, 以 Oracle 來說就是執行了 SELECT * FROM PERSON 的查詢將 Person 資料表的 所有資料 搜尋出來後才在應用程式中做後續的篩選和處理. 為什麼會有這個現象?其實從 IQeueryable&lt;T&gt; 和 IEnumerable&lt;T&gt; 的用途與差別大概就能推測出會有這樣的結果了, 不過出於好奇還是稍微實驗一下看會不會有更明確的答案. 實驗程式碼如下:1234567891011121314151617181920212223242526272829303132333435363738public static IEnumerable&lt;T&gt; WhereIf&lt;T&gt;(this IEnumerable&lt;T&gt; query, Func&lt;T, bool&gt; predicate, bool shouldAppendWhere)&#123; if (shouldAppendWhere) &#123; return query.Where(predicate); &#125; return query;&#125;public class MyQueryable&lt;T&gt; : IQueryable&lt;T&gt;&#123; public Type ElementType =&gt; typeof(T); public Expression Expression =&gt; default; public IQueryProvider Provider =&gt; default; public IEnumerator&lt;T&gt; GetEnumerator() &#123; throw new NotImplementedException("a"); &#125; IEnumerator IEnumerable.GetEnumerator() &#123; throw new NotImplementedException("b"); &#125;&#125;IEnumerable&lt;int&gt; query1 = new MyQueryable&lt;int&gt;().WhereIf(r =&gt; r &gt; 10, true);IEnumerable&lt;int&gt; query2 = new MyQueryable&lt;int&gt;().WhereIf(r =&gt; r &gt; 10, false);"Correct here.".Dump();// NotImplementedException("a")query1.Dump();// NotImplementedException("b")query2.Dump(); 經過實驗, 可以看到有加其他條件和直接轉型的情境會分別呼叫到兩個不同的 GetEnumerator() 方法, 翻了一下 Entity Framework Core 的原始碼可以發現 InternalDbSet 中的兩個 GetEnumerator() 方法的實作 最後都會呼叫到 CreateEntityQueryable() 方法且回傳一個 EntityQueryable&lt;T&gt; 型別的物件, 接著從 EntityQueryable 中相關的方法 的實作大概就可以推測到會去執行查詢了. 也就是說, 只要觸發 GetEnumerator() 方法的呼叫, 就會引發資料查詢. 這部分這樣推測是比較粗糙的作法, 嚴格來說應該是要找到真的去執行的程式碼才能證實, 但因為實測已經知道結果了, 加上懶得在家建立完整的環境追蹤, 所以就沒堅持要找到最底層. 解決方案方案一 : 同時擴充 IQueryable&lt;T&gt; 和 IEnumerable&lt;T&gt;如下範例:123456789101112131415161718192021222324252627282930public static class QueryableExtensions&#123; public static IQueryable&lt;T&gt; WhereIf&lt;T&gt;(this IQueryable&lt;T&gt; query, Expression&lt;Func&lt;T, bool&gt;&gt; predicate, bool shouldAppendWhere) &#123; if (shouldAppendWhere) &#123; return query.Where(predicate); &#125; return query; &#125;&#125;public static class EnumerableExtensions&#123; public static IEnumerable&lt;T&gt; WhereIf&lt;T&gt;(this IEnumerable&lt;T&gt; query, Func&lt;T, bool&gt; predicate, bool shouldAppendWhere) &#123; if (shouldAppendWhere) &#123; return query.Where(predicate); &#125; return query; &#125;&#125;var adults = _dbContext.Set&lt;Person&gt;() .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) // Optional filter .Where(r =&gt; r.Age &gt;= 18) .ToList(); 雖然同時擴充 IQueryable&lt;T&gt; 和 IEnumerable&lt;T&gt; 可以解決問題, 但這有幾個缺點: 因為 DbSet&lt;T&gt; 實作了 IQueryable&lt;T&gt;, 而 IQueryable&lt;T&gt; 繼承了 IEnumerable&lt;T&gt;, 所以編譯時優先使用 IQueryable&lt;T&gt; 的擴充方法, 雖然符合預期, 但完全依賴於編譯時的優先順序, 非常隱晦. 考慮到搭配選擇性引數 (Optional Arguments) 使用時, 很容易在無意間因為一點小改動而導致使用了 IEnumerable&lt;T&gt; 的擴充方法而沒發現. 萬一維護過程將 IQueryable&lt;T&gt; 的擴充方法移除或重新命名, 呼叫端還是可以正確編譯的, 但會變成呼叫了 IEnumerable&lt;T&gt; 的擴充方法, 而且很難意識到這個問題. 這是個有用且支援範圍廣但需要謹慎維護的解決方案, 適合非常嚴謹的團隊. 事實上, dotnet runtime 就是同時做了 IEnumerable&lt;T&gt; 版本的 Where() 擴充方法 和 IQueryable&lt;T&gt; 版本的 Where() 擴充方法 方案二 : 只擴充 IQueryable&lt;T&gt;如下範例:1234567891011121314151617public static class QueryableExtensions&#123; public static IQueryable&lt;T&gt; WhereIf&lt;T&gt;(this IQueryable&lt;T&gt; query, Expression&lt;Func&lt;T, bool&gt;&gt; predicate, bool shouldAppendWhere) &#123; if (shouldAppendWhere) &#123; return query.Where(predicate); &#125; return query; &#125;&#125;var adults = _dbContext.Set&lt;Person&gt;() .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) // Optional filter .Where(r =&gt; r.Age &gt;= 18) .ToList(); 這樣做不容易出錯, 但也有一個缺點 - 對於衍生自 IEnumerable&lt;T&gt; 的型別不友善. 以下面範例來說, 需要透過 AsQueryable() 方法轉型後才能使用.123456var dataSource = new List&lt;Person&gt;();var adults = dataSource .AsQueryable() .WhereIf(r =&gt; r.Gender == condition.Gender.Value, condition.Gender.HasValue) // Optional filter .Where(r =&gt; r.Age &gt;= 18) .ToList(); 是個支援範圍比較窄, 但是維護風險較低的做法, 適合無法保證謹慎維護的專案. 結論整體來說, 如果可能會被任何需要 ORM 的用戶端程式呼叫到, 優先避免做 IEnumerable&lt;T&gt; 的擴充方法, 真的需要的話要考慮如果會被 IQueryable&lt;T&gt; 的衍生類別呼叫到就必須連同 IQueryable&lt;T&gt; 的擴充方法一起做. 還好在確認 ORM 產生的 SQL Script 內容時就即時發現, 不然等到上 production 才爆發就真的很難找到這麼隱晦的問題來源了.]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[遠端連線時支援"部份多螢幕"]]></title>
    <url>%2Fcontent%2F20220925-use-some-of-monitors-for-remote.html</url>
    <content type="text"><![CDATA[使用 Windows 內建的遠端連線工具 (Remote Desktop Connection) 如果需要支援雙螢幕的話需要做一些設定，這些網路上資源很多沒什麼好說的。 但是如果是想要只使用三個螢幕中的其中兩個螢幕呢? 手動編輯 .rdp 檔案RDP 的圖形化介面沒有提供部分多螢幕的設定，只能將 *.rdp 檔案用文字編輯器打開後編輯。 增加設定如下:12use multimon:i:1selectedmonitors:s:0,1 意思是支援多螢幕，然後套用到 0、1 兩個螢幕，不確定 0、1 怎麼編號的，但是要用的時候試一下就好也就不仔細追究了。 結論很空虛的一篇，但是不是太熱門的問題不想之後需要又要到處找所以還是隨手紀錄一下。 參考remote desktop connection on 2 out of 3 monitors]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在本機上建立 NuGet 儲存庫]]></title>
    <url>%2Fcontent%2F20220924-local-nuget-package-repository.html</url>
    <content type="text"><![CDATA[最近的一個大專案剛好有機會重新打造基礎建設，於是便將常用與各種擴充功能做成套件發佈到內部的 NuGet 儲存庫，但有一個問題是因為套件上傳後就不應該再重新佈署同一個版本，如果新的套件開發初期有頻繁的設計變更會經常引發 breaking change，造成版本號增加的很快，即便不是設計變更，一有小 bug 或是小變更就急著跑流程發新版也是很浪費時間。 所以就有了一個想法，如果能在本機上建立 NuGet 套件儲存庫，這樣就能先在本機上試用確認設計適當且品質夠好，再將正式版發佈到真正的 NuGet 儲存庫上。 在本機上建立 NuGet 儲存庫其實很簡單，用 Visual Studio 開發的話幾個步驟就好了: 打開 NuGet Package 管理介面 依照下圖步驟指定資料夾 最後只要將包好的 *.nupkg 檔案放到資料夾中，就能從 NuGet Package 管理介面下載了。 NuGet 下載後的儲存位置如果從本機開發，版號部分可以後綴個 -local-v1 (這部分隨變加後綴是因為是本機臨時版不會真的上線，正式版要有嚴謹的定版規則)，這樣就可以頻繁修改直到確定要發行後再上線，但這樣缺點就是會留一大堆臨時版的資料在本機上，讓人覺得很礙眼。 這時候就可以從 %USERPROFILE%\.nuget\packages (我這邊完整路徑是 C:\Users\{user}\.nuget\packages) 中找到下載來的套件，可以開發完後順手清一下臨時版的資料，免得留一堆垃圾佔空間。 其實一開始是每個臨時版都是用一樣的版號，然後再手動到下載資料夾中清掉舊的重新下載一次，但是畢竟不是正常的操作方式，而且常常這樣做也是很繁瑣，所以還是用不同的版號比較好，等正式版要上前再去清垃圾就好了，另一方面也能養成不重覆發行相同版本套件的正確習慣。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[依字位 (grapheme) 處理字串 (2)]]></title>
    <url>%2Fcontent%2F20220828-grapheme-cluster-string-2.html</url>
    <content type="text"><![CDATA[前陣子在 依字位 (grapheme) 處理字串 這篇文章中有以越南文為例提到 grapheme 的問題，後來覺得 TextElementEnumerator 提供的方法不夠多，所以基於他另外封裝了一個仿 String 的類別，折騰了幾天常用的都寫得差不多了才發現繞遠路做了不少原本 string 就有提供的功能。 主要問題主要問題是因為 unicode 的幾種不同的標準化格式，導致字面上一樣的字其實是不同的內容，造成字串在比對的時候 (== 運算子) 會認為雙方是不同的字。 關於標準化格式就放連結在這邊就好，要看再慢慢看: UNICODE NORMALIZATION FORMS Unicode Normalization 文字標準化 解決方案String其實 String 提供的不少方法就有包含到這個問題，通常透過方法中的 StringComparison 或 CultureInfo 參數來做。 String.Normalize(...)這個方法可以將字串轉為特定的標準化格式，轉換後可以直接比對字串不需要考慮格式問題 避免用 String.Normalize(...) 做字串取代後輸出，轉化後的內容和輸入內容不同這樣做容易出意外，例如: 預期沒有要取代的內容卻被轉化成不同的格式後輸出。 用 TextElementEnumerator這就和之前那篇一樣了。 結論優先使用 string 提供的方法，包含 String.Normalize(...)，兩者都不合用時再考慮 TextElementEnumerator，不要一開始就繞遠路。 參考Char objects and Unicode characters UNICODE NORMALIZATION FORMS Unicode Normalization 文字標準化]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在 RoslynPad 中使用 MeasureIt 做基準測試 (benchmarking)]]></title>
    <url>%2Fcontent%2F20220818-use-measureit-in-roslynpad-for-benchmarking.html</url>
    <content type="text"><![CDATA[BenchmarkDotNet 是一個很熱門的工具可以用來簡單的量測與比較程式碼的效能，但是有時候我們只是想要快速測試一段程式碼的執行時間，這時候還要開 IDE 使用 BenchmarkDotNet 就覺得有點厚重 (除非 BenchmarkDotNet 專案已經建好在方案中可以一邊開發一邊實驗)。 這時候就想要在 RoslynPad 或 LinqPad 中使用基準測試工具，偏偏因為 RoslynPad 的限制而無法支援 BenchmarkDotNet，所以只能另外找一個替代方案 - MeasureIt。 使用方式範例123456789101112131415161718192021222324252627282930313233#r &quot;nuget:MeasureIt.exe/0.2.2&quot;using PerformanceMeasurement;var cost = LinqPadUX.Measure.Action(new Action(() =&gt;&#123; string s = string.Empty; for (var i = 0; i &lt; 1000; i++) &#123; s += i.ToString(); &#125;&#125;)).Dump();var costComparison = LinqPadUX.Measure.NamedActions(new List&lt;NamedAction&gt;()&#123; new NamedAction(&quot;string&quot;, () =&gt; &#123; string s = string.Empty; for (var i = 0; i &lt; 1000; i++) &#123; s += i.ToString(); &#125; &#125;), new NamedAction(&quot;stringBuilder&quot;, () =&gt; &#123; var sb = new StringBuilder(); for (var i = 0; i &lt; 1000; i++) &#123; sb.Append(i.ToString()); &#125; var s = sb.ToString(); &#125;)&#125;).Dump(); 結論沒什麼難度，但是沒記一下的話很快就忘了，尤其這個替代方案不算熱門，沒有很好找。 這個工具的功能比較精簡，如果真的要複雜的分析還是 BenchmarkDotNet 比較豐富。 參考Support BenchmarkDotNet Run time costs of small operations in C#]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在 Model Binding 後讀取 Request.Body 的內容]]></title>
    <url>%2Fcontent%2F20220626-read-form-body-after-model-binding.html</url>
    <content type="text"><![CDATA[一般來說在 WebAPI 的專案中, 我們會偏好使用 Model Binding 的機制來綁定請求內容, 但是之前在一個特殊需求上卻遇到在 Model Binding 後仍然要讀取 Request.Body (型別是 Stream) 的內容. 而問題在於, Form Post 的情境中, 在Model Binding 後 (在 Action 中) 讀取Request.Body 時會得到空的內容, 但是資料長度又是正確的 (而神奇的是 JSON 和 XML 情境是沒問題的). 這邊 Form Post, JSON 和 XML 情境是依 Content-Type 這個 Header 來分辨的. 這個需求是剛需, 因為這個 API 提供給外部廠商呼叫, 是不固定格式內容的, 所以 Body 中有可能是 Form, JSON ,XML, 甚至是自定義格式的, 比起客製 Model Binding 機制, 簡單的讀取 Request.Body 後再解析是比較容易上手的. 解決方式這個症狀和 Sream 讀取後需要”倒帶” (rewind) 才能再讀取的特性很像, 但是在 Action 中又無法直接倒帶, 剛好之前有遇過類似的問題, 印象中是要額外設定才能開啟倒帶功能 (但我金魚腦忘了怎麼做). 找了很久沒看到完全一樣的問題, 倒是看到一篇 類似的情境 值得一試, 只需要簡單的在 Startup.cs 中如下啟用就好: 1234567891011121314public void Configure(IApplicationBuilder app)&#123; // Must before UseEndpoints() called. app.Use(next =&gt; context =&gt; &#123; context.Request.EnableBuffering(); return next(context); &#125;); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 但有限制: 一定要出現在 UseEndpoints() 被呼叫之前, 推測是因為 Middleware 的執行順序的緣故. 不能在 Action 中才呼叫 EnableBuffering(), 也是合理, 畢竟都在所有 Middleware 後才呼叫, 就不符合上一個限制了, 但可惜目前還不知道是怎樣的運作機制讓倒帶這麼挑場合設定. 結論基本上能用 Model Binding 就盡量用, 沒特殊情境不需要特別去讀 Body Stream, 解析麻煩而且相對容易錯. 這要是第一次遇到連關鍵字都沒有不知道會卡多久, 還好之前有先遇過 Stream 倒帶和 Reqeut Rewind 的情境, 真是謝天謝地. 參考IAsyncActionFilter, trying to log request body, but it is empty]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[關於物件和集合初始設定式]]></title>
    <url>%2Fcontent%2F20220606-about-object-and-collection-initializers.html</url>
    <content type="text"><![CDATA[寫 C# 也好幾年了, 對於物件和集合初始設定式的使用也很習慣, 也知道那是語法糖, 但是前陣子看到自訂類別要套用物件和集合初始設定式時, 才發現其實沒有想像中的熟, 所以想稍微再整理一下一些細節. 首先, 其實官方文件已經非常完整的, 如果看過官方文件其實這邊就沒什麼好看的了. 也因為官方文件很完整, 所以這邊只會記一些平常沒被注意到的細節. 初始設定式的語法糖Indexer 部分以 Dictionary 為例1234var x = new Dictionary&lt;string, string&gt;&#123; ["k"] = "v",&#125; 編譯後的結果會接近下面的樣子, 去存取 Indexer.12var x = new Dictionary&lt;string, string&gt;();x["k"] = "v"; Collection 部分以 List 為例12345var x = new List&lt;string&gt;&#123; "a", "b",&#125; 編譯後的結果會接近下面的樣子, 去存取 Add() 方法.123var x = new List&lt;string&gt;();x.Add("a");x.Add("b"); 自定義類別套用初始設定式Indexer 部分如標題, 重點就是要實作對應的 indexer. 懶得自己想 Demo 了, 就偷一下官方的範例來改:1234567891011// 自定義的物件與 indexerpublic class Matrix&#123; private double[,] storage = new double[3, 3]; public double this[int row, int column] &#123; get =&gt; storage[row, column]; set =&gt; storage[row, column] = value; &#125;&#125; 123456789101112131415161718// 使用var identity = new Matrix&#123; [0, 0] = 1.0, [0, 1] = 0.0, [0, 2] = 0.0, [1, 0] = 0.0, [1, 1] = 1.0, [1, 2] = 0.0, [2, 0] = 0.0, [2, 1] = 0.0, [2, 2] = 1.0,&#125;;// identity[0, 0] =&gt; 1// identity[0, 1] =&gt; 0 Collection 部分兩個重點 必須實作 System.Collections.IEnumerable (或其衍生類別/介面) 這部分倒也不是初始設定式會用到, 只是不實作的話呼叫時就無法使用集合初始設定式. GetEnumerator() 內容在初始設定式不會被呼叫到, 所以沒實作也不會壞, 但是還是應該要實作. 必須有 Add 方法 Add 方法參數對應的就是初始設定式中參數的數量, 例如 {a, b, c} 就是對應呼叫到 Add(a, b, c) 這個多載 1234567891011121314151617181920// 自定義的物件public class NameCollection : IEnumerable&#123; private IList&lt;string&gt; _names = new List&lt;string&gt;(); public void Add(string lastName) &#123; _names.Add($"&#123;lastName&#125;"); &#125; public void Add(string fistName, string lastName) &#123; _names.Add($"&#123;fistName&#125; &#123;lastName&#125;"); &#125; public IEnumerator GetEnumerator() &#123; return _names.GetEnumerator(); &#125;&#125; 1234567891011121314// 使用var fullNames = new NameCollection&#123; // Add("Smith") &#123;"Smith"&#125;, // Add("John", "Smith") &#123;"John", "Smith"&#125;,&#125;;// 這邊會需要用到實作的 IEnumerable.GetEnumerator()foreach(var f in fullNames)&#123; var fullName = f.ToString();&#125; 結論其實使用上都很熟了, 但碰到自定義類別要套用初始設定式時, 一時之間會想不到怎麼做 (尤其時集合初始設定式), 所以這邊紀錄一下怎麼實作. 參考Object and Collection Initializers Collection initializers in custom classes Collection Initializers with Parameter Arrays]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XML 序列化時有條件的忽略欄位]]></title>
    <url>%2Fcontent%2F20220530-xml-serialization-conditional-ignore.html</url>
    <content type="text"><![CDATA[之前遇到需要在 XML 序列化的過程中忽略值為空值或預設值的欄位, 查了一下才發現不太好找而且做法沒有很直覺. 作法bool ShouldSerialize{PropertyName}建立回傳型別為 bool 的方法, 方法名稱必須為 ShouldSerialize 加上屬性名. 1234567891011public class M&#123; public string S &#123; get; set; &#125; public int N &#123; get; set; &#125; // ShouldSerialize + S public bool ShouldSerializeS() &#123; return !string.IsNullOrEmpty(S); &#125;&#125; 唯獨屬性 {PropertytName}Specified建立唯獨屬性, 名稱必須為屬性名加上 Specified, 有幾個細節: 不一定要是唯獨屬性, 有 setter 也可以, 但是沒意義, 不要這樣做. Attribute System.Xml.Serialization.XmlIgnore 不是必要的 (因為唯獨), 但建議要加, 避免有人加了 setter 或其他因素而導致他被序列化, 閱讀時也多一個提示效果. 1234567891011121314public class M&#123; public string S &#123; get; set; &#125; public int N &#123; get; set; &#125; [System.Xml.Serialization.XmlIgnore] public bool NSpecified &#123; get &#123; return N &gt; 0; &#125; &#125;&#125; 呼叫端與綜合分析簡單的呼叫端範例.123456789101112public class Program&#123; public static void Main() &#123; var m = new M(); m.S = ""; XmlSerializer xs = new XmlSerializer(typeof(M)); StringWriter sw = new StringWriter(); xs.Serialize(sw, m); Console.WriteLine(sw.ToString()); &#125;&#125; 建議: 優先使用 bool ShouldSerialize{PropertyName} 方法, 主要原因是因為他名字比較好記也比較直覺, 另外一個做法比較麻煩. 將屬性和條件拆開成個獨立的檔案搭配 partial class, 範例如下: 12345678910111213141516&gt; // M.cs&gt; public partial class M&gt; &#123;&gt; public string S &#123; get; set; &#125;&gt; public int N &#123; get; set; &#125;&gt; &#125;&gt; &gt; // M.Ignore.cs&gt; public partial class M&gt; &#123;&gt; public bool ShouldSerializeS()&gt; &#123;&gt; return !string.IsNullOrEmpty(S);&gt; &#125;&gt; &#125;&gt; 結論找到解法的時候其實很驚訝, 因為這種做法維護上其實會有點困擾, 想想如果屬性要改名, 結果還要有意識的刻意找出 ShouldSerialize{PropertyName} 或是 {PropertytName}Specified 來修改, 對於維護其實不太友善, 只是沒有找到其他做法也就先拿來用了. 參考Xml serialization - Hide null values How to exclude null properties when using XmlSerializer]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[依字位 (grapheme) 處理字串]]></title>
    <url>%2Fcontent%2F20220528-grapheme-cluster-string.html</url>
    <content type="text"><![CDATA[以前在處理字串的時候, 不管是反轉或是取字元都沒考慮到有些語言的一個字母可能是由多個字組成的, 直到遇到問題. 舉個越南文的例子, ơ 是由 o 和 ̛ (%cc%9b) 組成的, 所以處理的時候就容易有預料外的結果, 以字串反轉來說, ơa 反轉後變成 a̛o 關於 Grapheme 與相關這部分沒有仔細研究, 但是網路資源很多可以需要時知道細節時再查詢. What’s the difference between a character, a code point, a glyph and a grapheme? Glossary of Unicode Terms: 相關關鍵字 Abstract Character / Character / Glyph / Grapheme 使用 TextElementEnumerator 處理字串使用 TextElementEnumerator 就能正確的將 ơa 反轉成 ơa 了. 123456789101112using System.Globalization;public string ReverseGraphemeClusters(string s)&#123; TextElementEnumerator enumerator = StringInfo.GetTextElementEnumerator(s); StringBuilder sb = new StringBuilder(); while (enumerator.MoveNext()) &#123; sb.Insert(0, enumerator.GetTextElement()); &#125; return sb.ToString();&#125; 結論就是個沒遇到不會想到的問題, 處理方式也很簡單, 只是背後細節要看很多文件才能了解很麻煩所以乾脆紀錄一下備查. 參考What’s the difference between a character, a code point, a glyph and a grapheme?Glossary of Unicode TermsCorrectly reversing a stringC# grapheme]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flatten JSON]]></title>
    <url>%2Fcontent%2F20211114-flatten-json.html</url>
    <content type="text"><![CDATA[幾年前因為需要將”不固定格式且不可預期”的 JSON 字串轉換成 Dictionary&lt;strin, string&gt; 而做了擴充方法, 但後來發現實作得太複雜了.所以想記錄一下比較簡單的做法. 搭配 Newtonsoft.Json一開始的思路是將字串轉換成 JObject 後再迴圈所有的欄位, 根據那些欄位是 Object / Aarray / Value 搭配遞迴把整個 JSON 字串轉換成 Dictionary&lt;strin, string&gt;, 雖然遞迴有點費神但是整體也就四五十行程式碼, 寫完覺得很滿意. 沒想到最近發現了這一篇回答的精妙解法, 才發現之前的作法簡直是土法煉鋼, 所以稍微改了一下. 連結中的 Code 不支援第一層是陣列的 JSON, 例如: [{&quot;key&quot;, &quot;a&quot;}, {&quot;key&quot;, &quot;b&quot;}], 所以需要改過. 12345678public static class JContainerExtensions&#123; public static Dictionary&lt;string, string&gt; Flatten(this JContainer jContainer) &#123; IEnumerable&lt;JToken&gt; jTokens = jContainer.Descendants().Where(p =&gt; p.Count() == 0); return jTokens.ToDictionary(jToken =&gt; jToken.Path, jToken =&gt; jToken.ToString()); &#125;&#125; 不到十行而且又簡單明瞭, 呼叫端使用上也很容易:12var jContainer = JToken.Parse(testData) as JContainer;var flattenJContainer = jContainer?.Flatten(); JToken.Parse(testData) as JContainer 這一行是成立的, 會成立是因為 JToken.Parse(testData) 的結果可能是 JObject / JArray / JValue, 除了 JValue 外都繼承了 JContainer, 所以轉型上不會有問題, 而 JValue 是沒有 key 的純值 (例如: JToken val = JToken.Parse(&quot;abc&quot;);), 本來就不適合出現在要轉換成 Dictionary&lt;string, string&gt; 的情境. 搭配 Sysetem.Text.Json這個是內建的 Json 處理工具, 不過功能沒有 Newtonsoft.Json 那麼多, 沒找到比較簡單的做法所以只好還是用遞迴, 在實作上會麻煩很多. 先來點擴充方法: 1234567891011121314151617181920212223242526272829303132333435public static class JsonDocumentExtensions&#123; public static Dictionary&lt;string, string&gt; Flatten(this JsonDocument document) &#123; var result = new Dictionary&lt;string, string&gt;(); FlattenElement(string.Empty, document.RootElement, result); return result; &#125; private static void FlattenElement(string key, JsonElement element, Dictionary&lt;string, string&gt; result) &#123; switch (element.ValueKind) &#123; case JsonValueKind.Object: foreach (var pty in element.EnumerateObject()) &#123; string nextKey = string.IsNullOrEmpty(key) ? pty.Name : $"&#123;key&#125;.&#123;pty.Name&#125;"; FlattenElement(nextKey, pty.Value, result); &#125;; break; case JsonValueKind.Array: int i = 0; foreach (var arrayItem in element.EnumerateArray()) &#123; string nextKey = $"&#123;key&#125;[&#123;i&#125;]"; FlattenElement(nextKey, arrayItem, result); i++; &#125; break; default: result.Add(key.ToString(), element.ToString()); break; &#125; &#125;&#125; 呼叫端是這樣:1var flattenJsonDocument = JsonDocument.Parse(testData).Flatten(); 結論用了 Newtonsoft.Json 結果因為沒發現套件已經提供的功能而自己土法煉鋼真的沒效率又容易錯, 算是被以前的自己雷到. 另外為了方便驗證, 有範例專案在這裡. 參考C# flattening json structure]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[.NET Core 中單一介面多實作搭配依賴注入的幾種方式]]></title>
    <url>%2Fcontent%2F20211031-netcore-inject-multiple-implementation.html</url>
    <content type="text"><![CDATA[在 .NET Core 中注入多個實作有幾種方式，各自有不同的優缺點與試用情境，相關範例程式碼會放在 這個 GitHub 專案 上。 Implementation FactoryMicrosoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions 提供的多載，以 AddScoped 為例：public static IServiceCollection AddScoped&lt;TService&gt;(this IServiceCollection services, Func&lt;IServiceProvider, TService&gt; implementationFactory) where TService : class 第二個參數提供一個工廠方法來決定要使用哪種實作。 優點 非常簡單。 缺點與限制 只適用於在注入時就知道要用什麼規則決定使用哪個實作。 彈性低，雖然簡單但是適用情境狹窄。 注入 IEnumerable註冊多個實作，使用時注入 IEnumerable&lt;I&gt; 後再決定要使用哪個實作，可以搭配一個欄位用來標示該實作的名字 (要用類別名稱來標示也可以)。 註冊服務：1234567public void ConfigureServices(IServiceCollection services)&#123; services.AddControllers(); services.AddSingleton&lt;IFoo, Foo1&gt;(); services.AddSingleton&lt;IFoo, Foo2&gt;();&#125; 注入與使用：12345678910111213141516171819202122[ApiController][Route("[controller]")]public class DemoController : ControllerBase&#123; private IEnumerable&lt;IFoo&gt; _allFoo; public DemoController(IEnumerable&lt;IFoo&gt; allFoo) &#123; _allFoo = allFoo; &#125; [HttpGet] public ActionResult&lt;string&gt; Get(string name) &#123; var sb = new StringBuilder(); var foo = _allFoo.FirstOrDefault(r =&gt; r.Name == name); sb.Append(foo?.Hi()); return Ok(sb.ToString()); &#125;&#125; 優點 簡單。 彈性高。 缺點與限制 因為是注入所有的實作後再挑出要使用的那一個，其他的都用不到，會有浪費資源的疑慮，所以通常搭配 AddSingleton 使用。 每次搜尋 ( _allFoo.FirstOrDefault(r =&gt; r.Name == name) )的時間複雜度都是 O(n)，需要多次搜尋時這個缺點會更明顯。 Dictionary註冊成一個 Dictionary 或類似的物件。 註冊服務：123456789101112public void ConfigureServices(IServiceCollection services)&#123; services.AddControllers(); services.AddScoped&lt;IBar, Bar1&gt;(); services.AddScoped&lt;IBar, Bar2&gt;(); services.AddScoped&lt;IReadOnlyDictionary&lt;string, IBar&gt;&gt;(provider =&gt; &#123; var allBar = provider.GetService&lt;IEnumerable&lt;IBar&gt;&gt;(); return allBar.ToDictionary(bar =&gt; bar.Name, bar =&gt; bar); &#125;);&#125; 注入與使用：1234567891011121314151617181920212223[ApiController][Route("[controller]")]public class DemoController : ControllerBase&#123; private IReadOnlyDictionary&lt;string, IBar&gt; _allBar; public DemoController(IReadOnlyDictionary&lt;string, IBar&gt; allBar) &#123; _allBar = allBar; &#125; [HttpGet] public ActionResult&lt;string&gt; Get(string name) &#123; var sb = new StringBuilder(); // bar _allBar.TryGetValue(name, out IBar bar); sb.Append(bar?.Hello()); return Ok(sb.ToString()); &#125;&#125; 優點 簡單。 彈性高。 可擴充性高，如果是作為一個套件，即使沒提供適合的實作，使用者仍然可以自己實作 IBar 後注入。 只有第一次初始化的時候將 IEnumerable&lt;T&gt; 轉成 Dictionary 時比較耗時，之後每次取用的時間複雜度都是 O(1)，在生命週期範圍內多次取用的效能優於 IEnumerable&lt;T&gt;。 缺點與限制 沒有那麼直覺，對於使用者來說要記得注入時要注入為 IReadOnlyDictionary&lt;string, IBar&gt;。 透過另一個類別來轉接 (橋接模式)這種做法的概念在於提供一個橋接用的類別來使用那些實作。 註冊服務：12345678public void ConfigureServices(IServiceCollection services)&#123; services.AddControllers(); services.AddScoped&lt;IBaz, Baz1&gt;(); services.AddScoped&lt;IBaz, Baz2&gt;(); services.AddScoped&lt;IBazBridge, BazBridge&gt;();&#125; 注入與使用：12345678910111213141516171819202122[ApiController][Route("[controller]")]public class DemoController : ControllerBase&#123; private IBazBridge _bazBridge; public DemoController(IBazBridge bazBridge) &#123; _bazBridge = bazBridge; &#125; [HttpGet] public ActionResult&lt;string&gt; Get(string name) &#123; var sb = new StringBuilder(); // baz sb.Append(_bazBridge.Hey(name)); return Ok(sb.ToString()); &#125;&#125; Bridge 相關類別：123456789101112131415161718192021public interface IBazBridge&#123; string Hey(string name);&#125;internal class BazBridge : IBazBridge&#123; private IReadOnlyDictionary&lt;string, IBaz&gt; _allBazDictionary; public BazBridge(IEnumerable&lt;IBaz&gt; allBaz) &#123; _allBazDictionary = allBaz.ToDictionary(baz =&gt; baz.Name, baz =&gt; baz); &#125; public string Hey(string name) &#123; _allBazDictionary.TryGetValue(name, out IBaz baz); return baz?.Hey(); &#125;&#125; 如果有多個情境要使用 Bridge，可以將建構子中轉換 IEnumerable&lt;T&gt; 為 Dictionary 的部分抽成 BridgeBase，提供給所有 Bridge 繼承。 優點 彈性極高，Brige 中甚至可以做各種轉接與變化。 可擴充性高，如果是作為一個套件，即使沒提供適合的實作，使用者仍然可以自己實作 IBaz 後注入。 只有第一次初始化的時候將 IEnumerable&lt;T&gt; 轉成 Dictionary 時比較耗時，之後每次取用的時間複雜度都是 O(1)，在生命週期範圍內多次取用的效能優於 IEnumerable&lt;T&gt;。 相較於之前的注入 Dictionary 的解法，這種高彈性/擴充性的作法更適合放在套件中，這種設計相似於 HttpClient 與 IHttpClientFactory 之間的關係，所以相對於之前 Dictionary 的解法來說，使用上不直覺的問題相對低了一些。 缺點與限制 複雜很多。 多個介面需要套用時會需要很多組 Bridge。 註冊較不友善，services.AddScoped&lt;IBazBridge, BazBridge&gt;(); 這邊使用者要認識具體實作 BazBridge。 透過另一個類別來管理 (Provider)這種做法的概念在於提供一個管理用的類別來提供那些實作。 註冊服務：12345678910111213141516171819202122232425262728293031323334public void ConfigureServices(IServiceCollection services)&#123; services.AddControllers(); services.AddScoped&lt;IQux, Qux1&gt;(); services.AddScoped&lt;IQux, Qux2&gt;(); services.AddScoped&lt;IProvider&lt;IQux&gt;, Provider&lt;IQux&gt;&gt;();&#125;, ``注入與使用： ``` csharp[ApiController][Route("[controller]")]public class DemoController : ControllerBase&#123; private IProvider&lt;IQux&gt; _quxProvider; public DemoController(IProvider&lt;IQux&gt; quxProvider) &#123; _quxProvider = quxProvider; &#125; [HttpGet] public ActionResult&lt;string&gt; Get(string name) &#123; var sb = new StringBuilder(); // baz sb.Append(_quxProvider.Get(name).Yo()); return Ok(sb.ToString()); &#125;&#125; Provider 相關類別：1234567891011121314151617181920212223public interface IProvider&lt;T&gt; where T : INameable&#123; T Get(string name);&#125;public class Provider&lt;T&gt; : IProvider&lt;T&gt; where T : INameable&#123; private IReadOnlyDictionary&lt;string, T&gt; _dictionary; public Provider(IEnumerable&lt;T&gt; nameable) &#123; _dictionary = nameable.ToDictionary(n =&gt; n.Name, n =&gt; n); &#125; public T Get(string name) &#123; _dictionary.TryGetValue(name, out T imp); return imp; &#125;&#125; 優點 有幾乎等同 Bridge 解法的優點 (除了彈性略低)。 泛用性極高，可重複套用在任何單介面多實作的情境。 缺點與限制 因為不需要實作各種 Bridge，彈性較 Bridge 解法低一點。 註冊較不友善，services.AddScoped&lt;IProvider&lt;IQux&gt;, Provider&lt;IQux&gt;&gt;(); 這邊使用者要認識具體實作 Provider&lt;T&gt;，且兩層泛型參數比較不好閱讀。 綜合以上最佳化使用者體驗這是我用在一個套件 - MoreNet.DependencyInjection 上的作法，介紹直接看 GitHub。 優點 泛用性極高，可重複套用在任何單介面多實作的情境。 註冊簡易，對使用者比較友善。 缺點與限制 實作很複雜。 結論方法很多種，大致可以分為兩個面向 注入全部後再挑選。 提供管理用的類別 (不論是工廠/橋接或是其他模式)。 上面的範例只是為了展示這兩個大方向，實際運用時需要視情境變化調整，例如這篇文章提到幾種做法，都和上面範例不太一樣但大方向是一致的。 參考Service registration methods .NET6 Dependency Injection — One Interface, Multiple Implementations]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基於 ASP.NET Core WebAPI 讀取 Request / Response Body]]></title>
    <url>%2Fcontent%2F20210626-aspnetcore-webapi-read-body.html</url>
    <content type="text"><![CDATA[之前在 WebAPI 安全的取得 Request Body 這篇文章有提到讀取 Request Body 的方式, Response 的部分其實大同小異, 且在 ASP.NET Core 中也是相同邏輯(即使實作可能不同), 但有個不同的地方是 ASP.NET Core 中的 request body 預設是讀完無法回捲的(也就是讀完後指標會在 stream 最後面, 無法重複讀取), 且 response body 是唯寫 (WriteOnly) 的, 所以無法讀取, 就需要一點小技巧. 程式碼這邊直接實作在 Middleware 為例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class RequestResponseMiddleware&#123; private readonly RequestDelegate _next; public RequestResponseMiddleware(RequestDelegate next) &#123; _next = next; &#125; public async Task InvokeAsync(HttpContext httpContext) &#123; #region Request part var request = httpContext.Request; // 重要, 才能允許回捲 (request.Body.Seek(0, SeekOrigin.Begin)) request.EnableBuffering(); using var requestReader = new StreamReader(request.Body, leaveOpen: true); var body = await requestReader.ReadToEndAsync(); request.Body.Seek(0, SeekOrigin.Begin); Debug.WriteLine(body); #endregion var response = httpContext.Response; var originalStream = response.Body; using (var readableBodyStream = new MemoryStream()) &#123; response.Body = readableBodyStream; await _next(httpContext); response.Body.Seek(0, SeekOrigin.Begin); using var responseReader = new StreamReader(response.Body, leaveOpen: true); var responseBody = await responseReader.ReadToEndAsync(); Debug.WriteLine(responseBody); response.Body.Seek(0, SeekOrigin.Begin); await readableBodyStream.CopyToAsync(originalStream); // 即使沒有換回原本的物件, 得到的回傳仍然不會有錯, 猜測是回傳的內容是直接參考 response.Body 所指的物件, // 因此 response.Body 被換掉不會影響結果(反而上面的 stream copy 才是必要的), 但為了完整還是會把它換回來. response.Body = originalStream; &#125; #region Response part #endregion &#125;&#125; 上面來說, Request 部分就 request.EnableBuffering() 最重要, 不然讀完回無法回捲, Response 的話 await readableBodyStream.CopyToAsync(originalStream) 和 response.Body = originalStream 這兩行算是比較特別的, 如註解中所述. 結論細節很多很難解釋, 只好貼 code 解決, 希望不會以後自己看不懂…]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Friend Assembly]]></title>
    <url>%2Fcontent%2F20210606-use-friend-assembly.html</url>
    <content type="text"><![CDATA[如果組件 A 是組件 B 的 Friend Assembly, 則在組件 A 中能存取別的組件內的 internal 類別或成員, 更多細節在官方介紹. 用法加上一行 [assembly: InternalsVisibleTo(&quot;AssemblyName&quot;)] 就好, 建議放在 Properties 資料夾下的 AssemblyInfo.cs 檔案中. 使用情境目前有想到適合的情境是 跨組件的內部 API: 拆分成好幾個組件組合成一個完整產品, 希望給在這個產品中讓特定組件能跨組件存取, 但又不希望用 plubic . 測試目的: 因為測試的目的, 需要開放給測試專案存取. 結論使用上很簡單, 但是比較需要想的是試用在甚麼情境, 目前也就為了給測試專案存取而使用有用到而已. 參考Friend assemblies]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[傳遞依賴 (transitive dependency)]]></title>
    <url>%2Fcontent%2F20210523-transitive-dependency.html</url>
    <content type="text"><![CDATA[為了降低多個專案間的複雜度, 我們通常會謹慎的控制專案之間的依賴, 但在最近新開案的 .NET Core 一系列的新專案中發現傳遞依賴會讓專案之間產生預期外的依賴. 傳遞依賴 (transitive dependency) 指的是, 當 A 專案依賴 B 專案, 而 B 專案依賴 C 專案時, A 專案會傳遞依賴 C 專案 (即在 A 專案中能存取 C 專案的公開成員), 用下面的圖當範例說明 專案間的傳遞依賴就上圖的例子, 現在三層都是我們自己建立的專案, WebAPI 依賴 Service, 而 Service 依賴 Data Access, 本來不希望能從 WebAPI 中直接存取到 Data Access, 但卻因為傳遞依賴而失算. 現在直接依賴的關係是這樣的: WebAPI (project) –&gt; Service (project) –&gt; Data Access (project) 解決方式是要在 WebAPI 專案的 csproj 檔案中將傳遞依賴關閉, 如下:12345&lt;Project&gt; &lt;PropertyGroup&gt; &lt;DisableTransitiveProjectReferences&gt;true&lt;/DisableTransitiveProjectReferences&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; 專案間和套件的傳遞依賴這個情境的直接依賴的關係是這樣的, 假設 Data Access 是一個套件 (就叫 DataAccess 好了), Service 透過 NuGet 安裝並使用他 WebAPI (project) –&gt; Service (project) –&gt; Data Access (Package) 這時候 &lt;DisableTransitiveProjectReferences&gt; 是沒有用的, 解決方式就變成要在 Service 專案的 csproj 檔案中 用 &lt;PrivateAssets&gt; 排除, 如下123&lt;PackageReference Include="DataAccess" Version="1.1.0"&gt; &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&lt;/PackageReference&gt; 關於 &lt;PackageReference&gt; 更細緻的設定可以看這裡官方相關的介紹. 套件間的傳遞依賴最後一種情況, 套件之間的傳遞依賴, 現在 Service 也是個套件, 但他依賴 Data Access WebAPI (project) –&gt; Service (Package) –&gt; Data Access (Package) 其實這個跟上個情境是一樣的, 就是在 Service 中加上 PrivateAssets, 但如果們是站在 WebAPI 專案開發者而不是套件 (本例中的 Service) 開發者的角度, 就目前所知是無能為力, 只能期待後面維護的人不要誤用. 真實情境現實中遇到的情境是這樣的, 某項任務中要用到一個公司內部的套件, 而這個套件依賴了一個 JSON 的序列化套件 Jil, 那問題在於 Visual Studio 的提示功能可能會引導開發者使用 Jil 提供的類別, 但我們專案內部其實是用 Json.NET, 如果維護的人不小心就跟著 Visual Studio 的提示用了, 就變成一個功能用兩種套件處理而容易亂. 另外一個疑慮是, 就算我們真的也是用 Jil, 如果有天我們移除對這個內部套件的依賴, 或是更版後內部套件不使用 Jil 了, 那就會讓我們因為升版一個套件而造成另一個套件的使用問題, 雖然不難解決, 但多個疑慮總不是好事. 還有第三個疑慮最麻煩, 今天如果使用 A 和 B 兩個套件, 而他們分別依賴不同版本的 Jil 的時候就很糟了, 稍微用簡單情境實測一下是會使用高版的 Jil, 這意味著, 當你依賴 A 套件並透過傳遞依賴使用 Jil 時, 可能會因為後來依賴 B 套件而讓 Jil 被升版.而 A 套件在執行階段其實是呼叫到被升版的 Jil, 這會使得 A 套件的執行結果可能被改變或因為新版 Jil 的 breaking changes 而在執行階段拋出例外. 綜合以上疑慮, 可以考慮不要透過傳遞依賴而是直接依賴該套件, 這樣版本衝突時在安裝套件過程 有 機 會 能發現. 是的, 只是有機會能發現, 如果專案直接依賴高版本, 傳遞依賴低版本, 是不會警示的, 這種情境下最後還是會使用高版本的套件, 上面的疑慮還是無法獲得解決. 套件版本衝突的問題在 套件相依性問題 這邊已經遇過, 而且這還是直接依賴的還算好掌握, 如果是透過傳遞依賴使用的掌握上就困難了. 我在 GitHub 上有放一個專案來展示這些疑慮. 其他可能的做法主要是參考這篇 NuGet &gt; Dependencies. 限定套件版本範圍如範例:12345&lt;!-- Accepts 1.0 up to 1.x, but not 2.0 and higher. --&gt;&lt;PackageReference Include=&quot;ExamplePackage&quot; Version=&quot;[1.0,2.0)&quot; /&gt;&lt;!-- Accepts exactly 1.0. --&gt;&lt;PackageReference Include=&quot;ExamplePackage&quot; Version=&quot;[1.0]&quot; /&gt; 這個想法是限定套件版本讓版號衝突時直接失敗, 但是這樣可能會導致多個套件很難一起運作, 而且官方不建議. 用一個獨立專案管理套件依賴這個之前有實驗過, 就是開一個 Shared 專案, 他會被很多專案依賴, 而套件依賴都在 Shared 專案內管理再讓依賴他的其他專案們都能使用一致的套件組, 但是副作用是其他專案可能會存取到設計上不允許存取的套件, 以下面為例: WebAPI (project) –&gt; Service (project) –&gt; Data Access (project) –&gt; Shared (Project)Service (project) –&gt; Shared (Project)WebAPI (project) –&gt; Shared (Project) 如上的多層式設計, 且 Shared (Project) –&gt; Entity Framework Core (Package), 這時候很容易有人跳過中間幾層直接從 WebAPI 層用 Entity Framwork Core 存取資料庫, 所以需要依照真實情境去部分限縮傳遞依賴, 比較麻煩. 結論接下來可能會做一些內部套件類的專案, 還是要稍微注意一下傳遞依賴的問題, 避免讓使用者依賴到沒必要依賴的套件引發維護上的困擾. 而在使用套件時也應該要更謹慎, 以用最少量的多功能套件解決最多的問題, 不然引發的問題都是很難發現的, breaking changes 造成執行階段才拋例外已經不是好現象了, 萬一問題是得到錯誤的結果而非拋錯那真的會哭哭. 參考Transitive project references (ProjectReference): 這篇很完整 Controlling dependency assets) NuGet &gt; Dependencies]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Encoding.UTF8 vs new UTF8Encoding() 和 xml 序列化的可能問題]]></title>
    <url>%2Fcontent%2F20210510-encoding-utf8-vs-new-utf8encoding-about-preamble.html</url>
    <content type="text"><![CDATA[Encoding.UTF8 和 new UTF8Encoding() 所建立的物件內容是極其相似的, 甚至有些問答網站是說完全一樣, 但實際上有個小小不同的地方, 雖然多數時候不會造成影響, 但前陣子在寫 xml 序列化的測試的時候就出現結果不同的情境, 所以稍微紀錄一下. 問題點我們用下面的範例來做實驗 (示範用的, 忽略 clean code 的要求), 範例是基於 .Net Core 3.1. 12345678910111213141516171819202122232425262728public class FakeClass&#123; public string FakeString &#123; get; set; &#125; = "A";&#125;class Program&#123; static void Main(string[] args) &#123; var serializer = new XmlSerializer(typeof(FakeClass)); var obj = new FakeClass(); var xmlWriterSettings = new XmlWriterSettings() &#123; Encoding = Encoding.UTF8 &#125;; var b = Serialize(serializer, xmlWriterSettings, obj); var xmlWriterSettings2 = new XmlWriterSettings() &#123; Encoding = new UTF8Encoding() &#125;; var b2 = Serialize(serializer, xmlWriterSettings2, obj); &#125; static byte[] Serialize&lt;T&gt;(XmlSerializer serializer, XmlWriterSettings xmlWriterSettings, T obj) &#123; var ms = new MemoryStream(); using (var xmlWriter = XmlWriter.Create(ms, xmlWriterSettings)) &#123; serializer.Serialize(xmlWriter, obj); return ms.ToArray(); &#125; &#125;&#125; 從上面的範例可以發現, b 和 b2 的內容是不一樣的, 其中 b (使用Encoding.UTF8) 的最前面多了 BOM (三個 bytes, 內容就是 Encoding.UTF8.GetPreamble()), 雖然看起來沒有問題, 但是如同 XmlSerializer 的序列化/反序列化 與 BOM 這一篇提到的, 如果合作對象無法反序列化含 BOM 的 xml 時, 在資料交換過程就會有很多阻礙, 且含 BOM 的 XML 在文字編輯器上是無法用肉眼看出來的 (除非有特別設定顯示特殊字元). 另外一件有趣的事, 只要 bytes 內容一樣, 兩種方式轉成字串得到的內容是相同的, 亦即 Encoding.UTF8.GetString(b) == new UTF8Encoding().GetString(b) 且 Encoding.UTF8.GetString(b2) == new UTF8Encoding().GetString(b2). 相關內容之前那篇提過, 這篇主要是要稍微將範圍縮小到 Encoding.UTF8 和 new UTF8Encoding() 不完全一樣 這件事上. 看看原始碼.Net Core那既然從執行結果知道這兩者不同, 那就令人好奇這兩者的差別到底有多大了, 這時候就需要看看原始碼長怎樣了. 先從 Encoding.UTF8 開始, 從 .NET Source Browser 往下追蹤, 可以發現最後使用的是呼叫 UTF8Encoding(bool encoderShouldEmitUTF8Identifier) 這個建構子, 參數帶的是 true, 如下:12345public UTF8Encoding(bool encoderShouldEmitUTF8Identifier) : this()&#123; _emitUTF8Identifier = encoderShouldEmitUTF8Identifier;&#125; 然後是 new UTF8Encoding(), .NET Source Browser 往下追蹤, 可以發現呼叫的是 UTF8Encoding() 這個建構子, 如下:1234public UTF8Encoding() : base(UTF8_CODEPAGE)&#123;&#125; 可以看到這兩個情境只差別會不會將 _emitUTF8Identifier 設為 true 而已. .Net Framework在 .Net Framework 上更簡單, 如下兩段對比一目瞭然Encoding.UTF8 對比 new UTF8Encoding(). 結論這個差別很隱諱, 而且使用起來雖然大多情境都沒問題, 但遇到問題時容易卡住很久找不到主因, 尤其是跟外部廠商交互過程遇到這種問題真的要靠大量溝通加一點通靈能力才能找到. 另外如果沒看錯的話, UTF 系列的只有 UTF8 會有這個小差異, UTF7 和 UTF32 使用 Encoding.UTF7 / Encoding.UTF32 都各自和直接透過 UTF7Encoding / UTF32Encoding 無參數建構子得到的實例 (instance) 是一樣的. 參考.NET Source Browser]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨組件反射的注意事項]]></title>
    <url>%2Fcontent%2F20200802-cross-assembly-reflection.html</url>
    <content type="text"><![CDATA[問題的起源在於某次搬遷程式碼的時候, 雖然看起來只是將一個方法移動到別的專案, 卻不小心讓一個有使用反射的方法在執行階段拋錯, 雖然查明後發現不是太刁鑽的問題, 但卻是容易不小心出錯的, 所以稍微紀錄一下. 問題點當時的情況是有兩個專案, 假設是 LogicLayer 和 Shared, 要將一個 Create(string typeName) 方法從原本的 LogicLayer 專案搬到 Shared 中, 讓這個共用的工具方法能建立在正確的專案上, 方法如下: 123456// T must be base type of typeNamepublic static T Create&lt;T&gt;(string typeName)&#123; var type = Type.GetType(typeName); return (T)Activator.CreateInstance(type);&#125; 呼叫端則是這樣呼叫的: 12var typeName = "LogicLayer.DerivedModel";var type = Create&lt;BaseModel&gt;(typeName); Create&lt;T&gt;(string typeName) 方法沒有這麼單純, 範例只是為了描述問題, 而 “LogicLayer.DerivedModel” 是存在資料庫中的資料, 被取出來後做為引數代入 Create&lt;T&gt;(string typeName) 方法中. 當時覺得就只是將方法原封不動的搬去 Shared 專案中, 編譯和單元測試都有過也就不應該出什麼問題, 沒想卻在執行階段卻出現 Exception. 原因與解決方式主要是因為 typeName 並不是目前組件 Shared 中的類別, 所以 Type.GetType(typeName) 會回傳 null, 導致接下來的 NullReferenceException. 由於這個 Create&lt;T&gt;(string typeName) 方法必須在 Shared 專案才合理, 不能因為這樣不搬 ; 而如果使用完整的組件限定名稱 (assembly-qualified name), 像這個樣子 LogicLayer.DerivedModel, LogicLayer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null 也不適當, 因為這個值是存在資料庫中的, 在相容舊資料的限制下不能這樣做. 最後是把 Create&lt;T&gt;(string typeName) 改成 Create&lt;T&gt;(Type type), 由呼叫端取得 Type 後再傳入, 由於目前系統的前提是 typeName 必定屬於 LogicLayer 專案中的類別, 所以這樣做是合理的. 結論其實是低級錯誤, 因為這個方法其實是有做單元測試的, 但是測資 (typeName) 用了完整的組件限定名稱, 跟資料庫的真實資料格式不一樣, 所以測了也是白測才會拖到執行階段才發現錯誤. 另外題外話就是, 把類別名稱 (type name) 存在資料庫後再拿出來反射, 就我目前的觀點是很不好的行為, 因為這樣子會讓資料庫的資料本身跟應用程式的語言特性產生依賴, 別說應用程式換語言的時候這個資料就不能用了 (或是需要經過轉換才能用) , 就算只要類別改名都能讓舊資料直接造成在執行階段出錯, 變成類別的命名與資料庫資料這兩個八竿子打不著的事情產生依賴, 提高維護的風險與成本. 不只是類別名稱與反射, 應該要避免跟程式語言或框架執行有關的資料進資料庫進而產生依賴, 就算特殊情境也應該特別拿出來專門討論後面的維護風險以及是否有適合的替代方案.]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NUnit 中一次性初始化的涵蓋範圍]]></title>
    <url>%2Fcontent%2F20200606-nunit-one-time-setup-level.html</url>
    <content type="text"><![CDATA[一般來說套件的使用方式沒什麼好寫的, 但是使用 NUnit 的 OneTimeSetUp 時, 究竟是在多大的範圍做一次性的行為會根據這個特性 (Attribute) 的使用位置而不同, 這部分文件是放在 SetUpFixture Attribute 一節 說明, 不過沒有所有情境的範例程式, 所以做了一些實驗來簡單紀錄一下更細節的部分. 使用方式與範圍OneTimeSetUp 根據所使用的位置不同, 涵蓋的範圍會不同, 主要有三種: 類別層級 :該類別下加上 OneTimeSetUp 特性的方法只會執行一次. 命名空間層級 :該命名空間下加上 OneTimeSetUp 特性的方法只會執行一次, 且該類別上需要加 SetUpFixture 特性, 包含子命名空間, 例如命名空間 NS 下的 OneTimeSetUp 在 NS 和 NS.Sub 命名空間總共只會執行一次. 組件層級 :若不在任何命名空間下, 則加上 OneTimeSetUp 特性的方法在整個組件中只會執行一次, 而該類別上也需要加 SetUpFixture 特性. 範例程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107using NUnit.Framework;using System.Diagnostics;[SetUpFixture]public class OneTimeSetupClass&#123; [OneTimeSetUp] public void OneTimeSetupMethod() &#123; Debug.Print($"-- Assembly wide one-time setup."); &#125;&#125;namespace NS&#123; [SetUpFixture] public class OneTimeSetupClass &#123; [OneTimeSetUp] public void OneTimeSetupMethod() &#123; Debug.Print($"-- Namespace wide one-time setup."); &#125; &#125; [TestFixture] public class TestClass1 &#123; [OneTimeSetUp] public void OneTimeSetupMethod() &#123; Debug.Print($"-- Class wide one-time setup."); &#125; [Test] public void TestMethod1() &#123; Debug.Print($"Executeing NS.TestClass1.TestMethod1()"); &#125; [Test] public void TestMethod2() &#123; Debug.Print($"Executeing NS.TestClass1.TestMethod2()"); &#125; &#125; [TestFixture] public class TestClass2 &#123; [OneTimeSetUp] public void OneTimeSetupMethod() &#123; Debug.Print($"-- Class level one-time setup 2."); &#125; [Test] public void TestMethod1() &#123; Debug.Print($"Executeing NS.TestClass2.TestMethod1()"); &#125; [Test] public void TestMethod2() &#123; Debug.Print($"Executeing NS.TestClass2.TestMethod2()"); &#125; &#125;&#125;namespace NS.Sub&#123; [TestFixture] public class TestClass1 &#123; [Test] public void TestMethod1() &#123; Debug.Print($"Executeing NS.Sub.TestClass1.TestMethod1()"); &#125; [Test] public void TestMethod2() &#123; Debug.Print($"Executeing NS.Sub.TestClass1.TestMethod2()"); &#125; &#125;&#125;namespace NotNS&#123; [TestFixture] public class TestClass1 &#123; [Test] public void TestMethod1() &#123; Debug.Print($"Executeing NotNS.TestClass1.TestMethod1()"); &#125; [Test] public void TestMethod2() &#123; Debug.Print($"Executeing NotNS.TestClass1.TestMethod2()"); &#125; &#125;&#125; 以上是示範程式碼, 可以從下方的輸出訊息中看出一次性行為的範圍:123456789101112-- Assembly wide one-time setup.Executeing NotNS.TestClass1.TestMethod1()Executeing NotNS.TestClass1.TestMethod2()-- Namespace wide one-time setup.Executeing NS.Sub.TestClass1.TestMethod1()Executeing NS.Sub.TestClass1.TestMethod2()-- Class wide one-time setup.Executeing NS.TestClass1.TestMethod1()Executeing NS.TestClass1.TestMethod2()-- Class level one-time setup 2.Executeing NS.TestClass2.TestMethod1()Executeing NS.TestClass2.TestMethod2() 結論因為 OneTimeSetUp 是根據所使用的位置不同而有不同的涵蓋範圍, 所以一開始有點不確定怎麼用, 就稍微寫一下簡單的筆記紀錄一下. 參考SetUpFixture Attribute]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Aggregate Services 收斂依賴注入的物件]]></title>
    <url>%2Fcontent%2F20200403-dependency-injection-aggregate-services.html</url>
    <content type="text"><![CDATA[這篇是為了紀錄依賴注入時, 利用建構子注入的情境下, 當注入到有繼承關係的類別時所引發的維護上的困擾與解決方案. 問題背景考慮下面的程式碼 1234567891011121314151617181920public class BaseServcie&#123; private IFooDAO _fooDAO; public BaseServcie(IFooDAO fooDAO) &#123; _fooDAO = fooDAO; &#125;&#125;public class DerivedService : BaseServcie&#123; private IBarDAO _barDAO; public DerivedService(IFooDAO fooDAO, IBarDAO barDAO) : base(fooDAO) &#123; _barDAO = barDAO; &#125;&#125; 由於這個情境下, 父類別 (基底類別) 只有一個有參數的建構子, 所以不會從編譯器取得公開無參數建構子 (註1) , 而子類別 (衍生類別) 的建構子必須明確指定所要使用的父類別的建構子. 註1:Unless the class is static, classes without constructors are given a public parameterless constructor by the C# compiler in order to enable class instantiation 這樣的問題在於, 當父類別的建構子參數數量改變時, 所有子類別的建構子要同時修改, 如果子類別很多的話, 必然會造成維護上的困擾. 直覺上當然可以改用其他注入方式, 例如直接從 DI 套件提供的 service provider 去取得實體, 但這樣會有比較難做單元測試的缺點, 不是優先選項. Aggregate Service要避免這樣的問題的切入點就是 讓父類別的參數數量固定一個就好, 也就是 Aggregate Service 的概念, 這樣子不管之後要怎麼改動父類別所依賴的物件數量, 不論是父類別還是廣大的子類別們都不需要修改任何建構子的參數列. 通用作法如下程式碼: 12345678910111213141516171819202122232425262728public class BaseServcie&#123; private IFooDAO _fooDAO; public BaseServcie(AggregateBaseServiceDAO aggregateDAO) &#123; _fooDAO = aggregateDAO.FooDAO; &#125;&#125;public class DerivedService : BaseServcie&#123; private IBarDAO _barDAO; public DerivedService(AggregateBaseServiceDAO aggregateDAO, IBarDAO barDAO) : base(aggregateDAO) &#123; _barDAO = barDAO; &#125;&#125;public class AggregateBaseServiceDAO&#123; public AggregateBaseServiceDAO(IFooDAO _fooDAO) &#123; FooDAO = _fooDAO; &#125; public IFooDAO FooDAO &#123; get; &#125;&#125; IFooDAO 收納進 AggregateBaseServiceDAO 成為一個屬性, 就算之後 BaseServcie 需要增加其他的依賴, BaseServcie 和 DerivedService 的建構子也都不會受到影響.這個通用做法也不是什麼特別的概念, 就是在建構子注入的基礎下加上一點變化而已, 理論上也不會受限於使用哪一個 DI 套件. 如果沒必要的話, 不一定要多新增一個介面 IAggregateBaseServiceDAO 來讓 AggregateBaseServiceDAO 實作. Autofac 的 RegisterAggregateServiceAutofac 提供了比較方便的用法, Aggregate Service 簡化成如下面這樣, 但是 Aggregate Service 必須是介面, 且除了 Autofac 本身外需要安裝另外一個套件 Autofac.Extras.AggregateService. 1234public interface IAggregateBaseServiceDAO&#123; IFooDAO FooDAO &#123; get; &#125;&#125; 另外, 註冊的時候要改用 RegisterAggregateService 方法如下:1builder.RegisterAggregateService&lt;IAggregateBaseServiceDAO&gt;(); 這邊可以看到 Autofac 簡化了 Aggregate Service 內部的建構子注入的部分, 讓使用的時候不會覺得為了封裝這些物件而需要多做很多事, 限制 Aggregate Service 必須是介面且不需要實作類別, 某種程度上也有暗示後面維護者不要去誤用它的效果, 比起前面介紹的通用型 Aggregate Service 來說優點更多. 結論總體來說, 如果用 Autofac 且多安裝一個套件 Autofac.Extras.AggregateService 不會造成困擾的話, 用 Autofac 的作法會比較漂亮一點. 但如果 DI 套件沒有相關功能的話, 用通用的作法也是很不錯的. 參考Autofac Aggregate Services]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[套件相依性問題]]></title>
    <url>%2Fcontent%2F20200301-dependent-assembly-issue.html</url>
    <content type="text"><![CDATA[這個問題比較複雜, 一開始引發問題的情境是 A 專案依賴 B 專案, 且雙方都依賴同一個套件, 但卻是不同版本的套件 由於情境比較複雜, 所以我開了一個範例專案 DependentAssemblyIssue 來做示範, 內文會依照情境來描述處理方式以及所造成的後遺症. 初始可運作的情境以範例專案中, 第一個 commit 1c5d263 為例, 依賴關係如下: Client.MVC 依賴 Library Client.MVC 依賴 Newtonsoft.Json 6.0.1 版 Library 依賴 Newtonsoft.Json 6.0.1 版 其中在 Client.MVC 專案的 Global.asax.cs 中呼叫 Library 專案的靜態方法 Worker.Do() 如下:123456789protected void Application_Start()&#123; AreaRegistration.RegisterAllAreas(); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); Worker.Do();&#125; Worker.Do() 會在 Client.MVC 開啟後在 Visual Studio 的 Output 視窗印一行 log, 可以正常運作. 升版 Library 依賴的 Newtonsoft.Json 引發錯誤接下來我們假設維護 Library 專案的小組將 Newtonsoft.Json 的版本升級到 8.0.1 (commit 89d3eb9), 這時候 Client.MVC 還是依賴 6.0.1 版, 而當其呼叫 Worker.Do() 時, 就會拋出例外1System.IO.FileLoadException: &apos;Could not load file or assembly &apos;Newtonsoft.Json, Version=8.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed&apos; or one of its dependencies. The located assembly&apos;s manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)&apos; 這是因為 Client.MVC 在編譯期間根據 Web.config 中的設定將對版本 0.0.0.0 到 6.0.0.0 (oldVersion) 的參考導向 6.0.0 (newVersion) 但是 Library 專案依賴的是 8 版的關係.1234&lt;dependentAssembly&gt; &lt;assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" /&gt; &lt;bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" /&gt;&lt;/dependentAssembly&gt; 解決方式解決方式有兩個方向, 但是都有相對的副作用. 修改 oldVersion將 bindingRedirect 的屬性 oldVersion 改成 0.0.0.0-8.0.0.0, 將 8 版以下的 Newtonsoft.Json 依賴繫結到 6 版, 如 commit b827286 或下方所示.1&lt;bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="6.0.0.0" /&gt; 但是這會有個嚴重的副作用, 由於編譯出來後是使用 6 版的套件, 當 Library 專案中呼叫了 8 版的套件的新 API 時, 會發生編譯時期甚至單元測試都沒問題, 但是卻在 Client.MVC 的執行階段發生錯誤, 如 commit 2cc0617 所示. 另一個更難除錯的情境的是, 當所使用的 API 接口沒有改變, 但是改變了實作細節導致新舊版本執行結果不同的時候, 可能連錯誤訊息都沒有就更難除錯了(這部分沒找到適合展示與驗證的 API, 只是推測). 同時升版 Client.MVC 依賴的 Newtonsoft.Json這就像 commit 4ec7c50 這樣, 直接將 Client.MVC 所依賴的套件版本升到跟 Library 相同版本, 另外 bindingRedirect 也要修改如下.1&lt;bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" /&gt; 但這也意味了 Library 所依賴的套件版本更改時, Client.MVC 也需要修改相應的套件版本, 這在維護上是很容易忽略的細節, 而如果 Library 和 Client.MVC 是兩個不同的小組維護的時候, 這個問題就更容易延後發現了. 除了維護不方便的問題外, Client.MVC 修改相應的套件版本也就意味著他直接使用該套件的程式碼都需要重新測試, 避免新版本的 API 與舊版本運作結果不同. 結論這個問題發生的時候其實花了不少時間去找, 因為對於 Client.MVC 來說是明明什麼都沒做但他就壞了, Web.config 中的設定是一開始引入套件時就自動加好的, 所以也沒有想到有這一段. 事後其實有想過怎麼在未來預防這類的問題, 目前來說還沒想到如何簡單又漂亮的完全避開這個問題, 一個想法就是盡量避免這樣的依賴關係, 從簡化專案與套件的依賴這個角度可以有一定程度的效果, 但無法完全避免, 因為從現實專案來看就真的兩個專案都要直接依賴 Newtonsoft.Json, 而特別幫 Newtonsoft.Json 做一層隔離層讓兩個專案依賴也是一種方式, 但如果類推到每個套件都要做公用的隔離層那改動就比較大了. 參考Redirecting Assembly Versions Understanding a csproj assembly reference]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[透過 Jenkins 開關 dotnet core 應用程式]]></title>
    <url>%2Fcontent%2F20200120-dotnet-command-by-jenkins.html</url>
    <content type="text"><![CDATA[前陣子做了一個 dotnet core 的新專案, 上線前需要先跟 Jenkins 佈署流程整合, 本來很單純的想說用 dotnet MyCore.dll 指令開啟應用程式, 至於停止的時候就暴力用 kill 指令來關閉 (當然這種暴力解只是在實驗階段用來建立信心的, 接下來還是要找看有沒有其他更好的做法). 沒想到連信心都建立不起來, 透過 Jenkin 用 kill 指令時, 會出現錯誤 (沒有把錯誤細節記錄下來, 反正用 kill 也太暴力, 終究還是要換個方法的, 所以就果斷放棄去找尋新方法了). 使用 dotnet 指令方便歸方便, 但如同一開始說的, 跟 Jenkins 整合的時候會有問題, 這裡就是順便紀錄一下指令而已, 沒什麼特別的. 開啟應用程式dotnet MyCore.dll &gt; /dev/null 2&gt;&amp;1 &amp; 停止應用程式kill -9 11905 11905 是 pid 用 systemctl 指令管理建立服務新增 MyCore.servicevim /etc/systemd/system/MyCore.service 編輯內容 12345678910[Unit]Description=This is MyCore[Service]WorkingDirectory=/usr/dotnet/MyCore/ExecStart=/usr/bin/dotnet /usr/dotnet/MyCore/MyCore.dllEnvironment=ASPNETCORE_ENVIRONMENT=Development[Install]WantedBy=multi-user.target 這裡要注意的是環境變數要設定在服務檔裡面才有效. 上面服務檔的範例只是極簡版, 能動而已, 官方範例參考這裡 啟用用 systemctl 開關應用程式. 12systemctl start MyCore systemctl stop MyCore 結論如果會用 linux 的話其實不用特別紀錄, 只要知道用 systemctl 取代 dotnet 來開關應用程式就好, 但是我很不會用 linux, 所以還是要備忘一下, 免得下次遇到一樣的問題要 google 連關鍵字都不會下. 參考Manage Kestrel process with systemdHost ASP.NET Core on Linux with NginxHow to run ASP.NET Core as a service on Linux (RHEL)]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[追蹤與反組譯 C# 程式碼]]></title>
    <url>%2Fcontent%2F20191229-trace-csharp-source-code.html</url>
    <content type="text"><![CDATA[在開發 C# 程式或是學習過程, 會用到許多不是由我們開發的框架或套件, 很多時候會需要知道內部的運作方式, 這篇紀錄幾個方式來讓我們能知道套件內部究竟做了什麼. 官方原始碼最準確的方式, 直接看官方提供的原始碼, 可能存放在 GitHub 或其他儲存庫, 一般小型第三方套件應該都能快速了解, 但是如果要看的是 .NET Framework 或是超大型套件時, 就會比較費神, 而且也無法期待所有套件都有開源. 另外 .NET Framework 和 .NET Core 都有原始碼查詢網站, 可以快速找到原始碼的實作內容. .NET Framework Reference Source .NET Core Source Browser Visual Studio 2019直接內建在 Visual Studio 中, GoToDefinition (F12) 進入就可以看到, 設定方式也很簡單:Tools &gt; Options &gt; Text Editor &gt; C# &gt; Advanced &gt; enable navigation to decompiled sources (experimental) 但是這個功能在 .NET Core 的專案上無法反組譯出正確內容, 選項上也標明 experimental. 其他工具ILSpy第三方反組譯工具很多, 其中我最推薦的是 ILSpy, 可在 Extensions &gt; Manage Extensions 裡面找到並安裝, 能在 Visual Studio 直接按右鍵開啟 ILSpy 非常方便. 開啟後也可以選擇 C# 版本 另外也可以選擇 C# 跟 IL 同時顯示, 可以對照著看, 了解不同寫法編譯後是不是一樣的內容, 看不懂 IL Code 也沒關係, 滑鼠移過去還會出現說明框, 點擊後會開啟瀏覽器導頁到 msdn, 這部分在實驗學習的過程很好用. dotPeek 和 JustDecompile比起 ILSpy 介面好看很多, 很多方便的功能, 如果是要仔細看程式流程的話, 這兩者更適合. 結論反組譯工具所產生的程式碼不一定跟原本的內容一樣, 如果真的要研究實作方式等細節的話, 還是直接看開源的程式碼內容比較準確. 參考ILSpydotPeekJustDecompile]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Json.NET 反序列化數字時, 尾數 0 可能被捨棄]]></title>
    <url>%2Fcontent%2F20191126-json-net-trailing-zero-number-problem.html</url>
    <content type="text"><![CDATA[用 Json.NET 來將 JSON 字串反序列化成物件是很典型的做法, 以前也沒出過什麼問題, 但在某些使用方式下, 會出現數字的尾數 0 被移除的狀況, 例如: 10.00 會被轉成 10, 而 10.10 會被轉成 10.1. 雖然這個結果乍看之下沒什麼影響, 但如果資料是在跟第三方 API 介接時, 簽章 (sign) 所需要的欄位時, 就會直接導致簽章檢核錯誤. 正常情境以我之前習慣將 JSON 字串反序列化成 Model 的用法來說, 是不會有這個問題的, 如下. 12345678910111213public class Data&#123; [JsonProperty("money")] public string Money &#123; get; set; &#125;&#125;static void Main(string[] args)&#123; string jsonString = "&#123;\"money\":10.10&#125;"; var data = JsonConvert.DeserializeObject&lt;Data&gt;(jsonString); // output: 10.10 Console.WriteLine(data.Money);&#125; 出問題的情境問題描述如果我們的 API 接受大量來自外部的呼叫, 且 JSON 的欄位名稱與結構不固定, 我們可能不希望建立大量的 Model 來反序列化, 那程式碼可能會變成下面這樣: 1234string jsonString = "&#123;\"money\":10.10&#125;";var data = JObject.Parse(jsonString);// output: 10.1Console.WriteLine(data.GetValue("money")); 不只是直接用 JObject 取值的情境, 要把 JSON 字串轉成一個 Dictionary 或類似情境時, 都會碰到這個問題. 解決方式雖然複雜很多, 但用在解析不固定結構的 JSON 字串 (jsonString) 並取出特定欄位或所有欄位時很方便, 且要取出的欄位名稱可做為參數也支援巢狀的結構(只要符合 JSONPath expression 的規則). 12345678910string jsonString = "&#123;\"money\":10.10&#125;";using (var sr = new StringReader(jsonString))using (var jr = new JsonTextReader(sr))&#123; jr.FloatParseHandling = FloatParseHandling.Decimal; var jsonContent = JToken.ReadFrom(jr); var target = jsonContent.SelectToken("money"); // output: 10.10 Console.WriteLine(target);&#125; 結論一般情境下, 反序列化還是建議盡量轉換成 Model, 後續會好操作很多, 且可以減少用 JObject 等方式操作造成執行階段容易出錯的疑慮. 但在現實專案中, 條件總是比較複雜, 還要考慮原本系統的設計與現況, 所以還是可能會遇到不適合反序列化成特定 Model 的情境, 就需要靈活變化了.]]></content>
      <categories>
        <category>C#</category>
        <category>Packages</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不依賴 DDEX provider 使用 Entity Framework 操作 SQLite]]></title>
    <url>%2Fcontent%2F20191017-manually-use-sqlite-with-ef.html</url>
    <content type="text"><![CDATA[在之前的文章 在 vs2017 中使用 Entity Framework 操作 SQLite 使用方式雖然方便, 但是相對的非常依賴工具, 所以這篇用來記錄用盡量少的工具來使用 Entity Framework 操作 SQLite. 套件與工具安裝不同於之前, 這次只需要 安裝 NuGet 套件 System.Data.SqliteSystem.Data.Sqlite 會一併安裝依賴的套件與 Entity Framework 本身. 設定 App.configApp.config 中主要有三個部分要設定, 有些在安裝 System.Data.Sqlite 與 Entity Framework 時會有預設的內容, 預設內容可能需要調整, 可運作的版本如下: &lt;providers&gt; 區塊這個區塊在 &lt;entityFramework&gt;&lt;/entityFramework&gt; 中, 安裝完 Entity Framework 會自動生成一組範本, 修改後只留必要的.123&lt;providers&gt; &lt;provider invariantName="SQLiteProvider" type="System.Data.SQLite.EF6.SQLiteProviderServices, System.Data.SQLite.EF6" /&gt;&lt;/providers&gt; &lt;system.data&gt; 區塊這個區塊在 &lt;configuration&gt;&lt;/configuration&gt; 中.12345&lt;system.data&gt; &lt;DbProviderFactories&gt; &lt;add name="SQLite Data Provider" invariant="SQLiteProvider" description=".NET Framework Data Provider for SQLite" type="System.Data.SQLite.SQLiteFactory, System.Data.SQLite" /&gt; &lt;/DbProviderFactories&gt;&lt;/system.data&gt; &lt;connectionStrings&gt; 區塊這個區塊在 &lt;configuration&gt;&lt;/configuration&gt; 中, 跟 &lt;system.data&gt; 同一層. 123&lt;connectionStrings&gt; &lt;add name="NorthwindConnection" providerName="SQLiteProvider" connectionString="data source=C:\Users\Ron\Desktop\SqliteDemo\SqliteDemo\Northwind.sqlite"/&gt;&lt;/connectionStrings&gt; 說明相較於之前透過工具產生的內容, 這邊手動調整後簡短很多, 要注意的大概就是 providerName, invariant 和 invariantName 要對得起來, connectionString 寫好就好. 新增 Model以北風資料庫中的 Category 表為例, 新增一個相應的 Model 如下:123456public partial class Category&#123; public long Id &#123; get; set; &#125; public string CategoryName &#123; get; set; &#125; public string Description &#123; get; set; &#125;&#125; 新增 NorthwindContext繼承 DbContext 並覆寫 OnModelCreating(DbModelBuilder) 方法, 設定資料表跟 Model 的對應, 並增加相應的 DbSet&lt;T&gt;. 12345678910111213public partial class NorthwindContext : DbContext&#123; public NorthwindContext() : base("name=NorthwindConnection") &#123; &#125; protected override void OnModelCreating(DbModelBuilder modelBuilder) &#123; modelBuilder.Entity&lt;Category&gt;().ToTable("Category"); base.OnModelCreating(modelBuilder); &#125; public virtual DbSet&lt;Category&gt; Categories &#123; get; set; &#125;&#125; DbContext 的部分就我目前理解是 UnitOfWork Pattern 的實作, 而 DbSet&lt;T&gt; 則像是 Generic Repository. 寫段程式用用看123456789101112131415class Program&#123; static void Main(string[] args) &#123; using (var context = new NorthwindContext()) &#123; var categories = context.Categories.ToList(); foreach (var category in categories) &#123; Console.WriteLine($"&#123;category.CategoryName&#125;: &#123;category.Description&#125;"); &#125; &#125; Console.ReadLine(); &#125;&#125; 結論用這種方式來優點就是彈性, 減少開發工具的相容性的問題, 另一方面, 實作過程能更清楚每個環節的角色, 即使不完全了解細節也能避免過度依賴工具自動產生程式碼而忘記要去了解內容. 缺點也是顯而易見的, 資料庫欄位變動後都需要手動維護 Model 和 NorthwindContext, 沒有工具幫忙同步, 維護成本高. 總結來說, 用在產品開發上太耗時間有點不實際, 但作為工具限制下的方案或是學習用途還是很適合的.]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在 vs2017 中使用 Entity Framework 操作 SQLite]]></title>
    <url>%2Fcontent%2F20190907-use-sqlite-with-ef-and-vs2017.html</url>
    <content type="text"><![CDATA[有時候做一些實驗的時候會需要用到資料庫, 但是為了實驗特別架一個 SQL Server 的環境實在是很麻煩, 電腦重灌或是虛擬機重裝的時候重建也麻煩, 所以就把腦筋動到 SQLite 上了, 不過操作上沒有想像中的簡單呢. 因為是為了建構實驗用的資料庫, 不希望花太多時間, 希望能盡可能方便的將資料存取層建起來, 所以採用資料庫優先 (database first) 的方式來建立 ADO.NET Entity Data Model (*.edmx). 套件與工具安裝System.Data.SQLite DDEX provider 不支援 Visual Studio 2017, 所以需要借助其他套件的幫忙, SqlCeToolbox 提供套件支援與安裝教學, 內容很完整, 所以這邊只稍微列一下步驟. 安裝 SqlCeToolbox 安裝 SQLite 到 GAC這邊要注意只能安裝特定版本才行, 特定版本會有下面的標註 (粗體放大應該不難找), 我是安裝 Setups for 32-bit Windows (.NET Framework 4.6) 這個版本. This is the only setup package that is capable of installing the design-time components for Visual Studio 2015. 安裝 NuGet 套件 System.Data.SqliteSystem.Data.Sqlite 會一併安裝依賴的套件與 Entity Framework 本身. 新增 ADO.NET Entity Data Model (*.edmx) 這些步驟有些地方要稍微注意一下 NorthwindContext 會成為 App.config 中 connectionStrings 這一段的預設名字, 如下: App.config 123&lt;connectionStrings&gt; &lt;add name="NorthwindContext" connectionString="metadata=res://*/DataAccess.Northwind.csdl|res://*/DataAccess.Northwind.ssdl|res://*/DataAccess.Northwind.msl;provider=System.Data.SQLite.EF6;provider connection string=&amp;quot;data source=C:\Users\Ron\Desktop\SqliteDemo\SqliteDemo\Northwind.sqlite;version=3&amp;quot;" providerName="System.Data.EntityClient" /&gt;&lt;/connectionStrings&gt; Northwind.Context.cs 123456789public partial class NorthwindContext : DbContext&#123; public NorthwindContext() : base("name=NorthwindContext") &#123; &#125; // skip...&#125; Model Namespace 一欄的值 “Northwind” 會在 Northwind.edmx 中用來作為命名空間, 取個合理的名字就好. 寫段程式用用看12345678910111213141516class Program&#123; static void Main(string[] args) &#123; using (var context = new NorthwindContext()) &#123; var categories = context.Categories.ToList(); foreach (var category in categories) &#123; Console.WriteLine($"&#123;category.CategoryName&#125;: &#123;category.Description&#125;"); &#125; &#125; Console.ReadLine(); &#125;&#125; 沒意外的話, 會拋出 Exception, 預設在 App.config 中填入的設定是需要一些調整的. 調整 App.config調整調整一下 App.config 中,DbProviderFactories1234&lt;DbProviderFactories&gt; &lt;remove invariant="System.Data.SQLite.EF6" /&gt; &lt;add name="SQLite Data Provider" invariant="System.Data.SQLite.EF6" description=".NET Framework Data Provider for SQLite" type="System.Data.SQLite.SQLiteFactory, System.Data.SQLite" /&gt;&lt;/DbProviderFactories&gt; App.config 相關內容節錄:1234567891011121314151617181920&lt;entityFramework&gt; &lt;defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework"&gt; &lt;parameters&gt; &lt;parameter value="mssqllocaldb" /&gt; &lt;/parameters&gt; &lt;/defaultConnectionFactory&gt; &lt;providers&gt; &lt;provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer" /&gt; &lt;provider invariantName="System.Data.SQLite.EF6" type="System.Data.SQLite.EF6.SQLiteProviderServices, System.Data.SQLite.EF6" /&gt; &lt;/providers&gt;&lt;/entityFramework&gt;&lt;system.data&gt; &lt;DbProviderFactories&gt; &lt;remove invariant="System.Data.SQLite.EF6" /&gt; &lt;add name="SQLite Data Provider" invariant="System.Data.SQLite.EF6" description=".NET Framework Data Provider for SQLite" type="System.Data.SQLite.SQLiteFactory, System.Data.SQLite" /&gt; &lt;/DbProviderFactories&gt;&lt;/system.data&gt;&lt;connectionStrings&gt; &lt;add name="NorthwindContext" connectionString="metadata=res://*/DataAccess.Northwind.csdl|res://*/DataAccess.Northwind.ssdl|res://*/DataAccess.Northwind.msl;provider=System.Data.SQLite.EF6;provider connection string=&amp;quot;data source=C:\Users\Ron\Desktop\SqliteDemo\SqliteDemo\Northwind.sqlite;version=3&amp;quot;" providerName="System.Data.EntityClient" /&gt;&lt;/connectionStrings&gt; &lt;provider invariantName=&quot;System.Data.SQLite.EF6&quot;&gt; 中 invariantName 會被以下幾個地方參考, 要換名字的話四個地方都要換, 不然執行階段會拋例外 &lt;DbProviderFactories&gt; 下的 &lt;add&gt; 的屬性 invariant &lt;connectionStrings&gt; 下的 &lt;add&gt; 的屬性 connectionString 內的 provider Northwind.edmx 中 &lt;Schema&gt; 的屬性 Provider 結論這種做法對於快速開發應用來說很適合, 畢竟工具已經幫忙產出大部分的設定與程式碼. 但也由於很多內容是自動產生的, 所以如果沒有特別去研究, 會不知道究竟自動產生了什麼設定與程式, 不知道相關細節修改起來就容易出錯, 而且自動產生 *.edmx 還要看所用版本的 visual stuio 有沒有支援, 如果用到不支援的版本就會變得很麻煩. 參考EF6 workflow with SQLite DDEX providerSQLiteSQLite EntityFramework 6 Tutorialnorthwind-SQLite3]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在 WebAPI 中處理 multipart/form-data 資料]]></title>
    <url>%2Fcontent%2F20190826-handle-multipart-formdata-by-webapi.html</url>
    <content type="text"><![CDATA[在跟外部廠商介接的過程發現少數廠商在發送到我們的 WebAPI 的 request 是 multipart/form-data 的, 以前舊的老專案中要處理這種資料還要透過第三方套件, 後來在遷移到 .NET 的過程中發現,用 .NET 處理這類型的資料是可以不用第三方套件的, 所以紀錄一下碰到的幾種情境的處理方式. 這邊除了用 MultipartFormDataContent 和 HttpClient 來模擬客戶端呼叫我們的 WebAPI 之外, 也會用 postman 模擬 (比較方便不用寫程式), 而用 postman 模擬要注意不要額外將 content-type 設成 multipart/form-data, 理由這篇討論的回應中有提到. 包含 FileName客戶端呼叫 API 的程式碼約略如下:12345678using (var content = new MultipartFormDataContent())&#123; content.Add(new StringContent("key1"), "value1", "file1.txt"); content.Add(new StringContent("key2"), "value2", "file2.txt"); var req = new HttpClient(); req.PostAsync("http://localhost:50640/api/multipart", content).Wait();&#125; 用 postman 模擬的話會是這樣: 而 body 的內容如下:1234567891011--29874ecd-2a56-406a-a2c0-18eff0d3ae85Content-Type: text/plain; charset=utf-8Content-Disposition: form-data; name=value1; filename=file1.txt; filename*=utf-8&apos;&apos;file1.txtkey1--29874ecd-2a56-406a-a2c0-18eff0d3ae85Content-Type: text/plain; charset=utf-8Content-Disposition: form-data; name=value2; filename=file2.txt; filename*=utf-8&apos;&apos;file2.txtkey2--29874ecd-2a56-406a-a2c0-18eff0d3ae85-- 從 ApiController.Request 取得資料這個情境下 ApiController.Request.Content.IsMimeMultipartContent() 會回傳 true, 可用這個方法來作為判斷基準. 12345678910111213141516171819private async void GetMultipartFromHttpRequestMessage()&#123; Debug.WriteLine("===== Get from HttpRequestMessage (multipart) ====="); var multi = await Request.Content.ReadAsMultipartAsync(); Debug.WriteLine("===== Get from file ====="); foreach (var content in multi.Contents) &#123; string key = content.Headers.ContentDisposition.Name; string value = string.Empty; using (Stream s = content.ReadAsStreamAsync().Result) using (StreamReader sr = new StreamReader(s)) &#123; s.Seek(0, SeekOrigin.Begin); value = sr.ReadToEnd(); Debug.WriteLine($"key: &#123;key&#125;, value: &#123;value&#125;"); &#125; &#125;&#125; 不含 filename客戶端呼叫 API 的程式碼約略如下, 差別在於 contnet.Add(...) 沒有帶第三個參數:12345678using (var content = new MultipartFormDataContent())&#123; content.Add(new StringContent("key1"), "value1"); content.Add(new StringContent("key2"), "value2"); var req = new HttpClient(); req.PostAsync("http://localhost:50640/api/multipart", content).Wait();&#125; 用 postman 模擬的話會是這樣, 差別在不是用檔案上傳: 而 body 的內容如下:1234567891011--9b753acb-2b3a-4214-bfc4-47b25799436fContent-Type: text/plain; charset=utf-8Content-Disposition: form-data; name=value1key1--9b753acb-2b3a-4214-bfc4-47b25799436fContent-Type: text/plain; charset=utf-8Content-Disposition: form-data; name=value2key2--9b753acb-2b3a-4214-bfc4-47b25799436f-- 雖然跟上一個例子比起來, 似乎只少了 Content-Disposition 中的 filename 一段, 但這會讓我們在取資料上變得更方便. 從 ApiController.Request 取得資料在不含 filename 的情境下, ApiController.Request.Content.IsMimeMultipartContent() 依然會是 true, 所以上一個情境的解法依然適用. 從 HttpContext.Current.Request 取得資料在不含 filename 的情境下, 操作上可以視同一般的 form post 來取得資料, 不用做額外的處理, 如下:12345678910private void GetFormFromHttpRequest()&#123; Debug.WriteLine("===== Get from HttpRequestMessage (form) ====="); var formData = HttpContext.Current.Request.Form; foreach (var key in formData.AllKeys) &#123; string value = formData[key]; Debug.WriteLine($"key: &#123;key&#125;, value: &#123;value&#125;"); &#125;&#125; 有趣的地方是雖然操作上跟一般 form post 一樣, 但是如果試圖透過 ApiController.Request.Content.ReadAsFormDataAsync() 取得資料是會拋出例外, 且ApiController.Request.Content.IsFormData() 的回傳值是 false. 結論目前因為確定合作廠商使用 multipart/form-data 的情境都不會帶 filename, 所以是視同一般 form post 直接從HttpContext.Current.Request 中取得資料, 省去額外的判斷跟處理. 但嚴格來說, 不管是不是有 filename 這段, 都應該用 ApiController.Request.Content.ReadAsMultipartAsync() 來處理比較恰當, 目前的做法比較像是因為剛好可以相容又可以省事, 就這樣用了. 參考24503961How to get string representation of a MultipartFormDataContent]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[.NET core 測試專案版本不符]]></title>
    <url>%2Fcontent%2F20190622-dotnetcore-testproject-cs1705.html</url>
    <content type="text"><![CDATA[前陣子的新專案用的是 .NET core 2.1, 在加測試專案的時候發現測試專案編譯無法通過, 拋出類似於版本衝突/版本錯誤之類的錯誤 (錯誤碼忘了, 不知道是不是 CS1705), 經過檢查後發現產品專案和測試專案的相關組件版本都一樣, 一時間還真的找不到方向. 不過很快的就靠谷歌大神找到了答案, 雖然一般來說這麼容易找到的答案實在不用記, 又遇到就再找就好, 不過這個情境比較特殊, 萬一再遇到沒下好關鍵字說不定就找不到了, 想想還是速記一下好了. 解法總之就是手動編輯 csproj 檔, 在 ItemGroup 裡面加上一段引用如下1&lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; /&gt; 結論解決這個問題我自己是完全沒分析什麼, 就完全是剛好找到相關的文章, 而且正好命中問題一下就解決了, 神奇的是, 事後要在家裡重現問題都無法重現, 也不知道是不是特殊條件才會觸發這個問題, 就這樣留下一個謎… 參考[UnitTest] ASP.NET Core 2.2 測試專案中的版本衝突Version conflicts in test project depending on a Microsoft.AspNetCore.App project]]></content>
      <categories>
        <category>C#</category>
        <category>.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在建構子中取得 WebAPI 的 request 內容]]></title>
    <url>%2Fcontent%2F20190526-get-request-in-constructor-of-derived-ApiController.html</url>
    <content type="text"><![CDATA[事情是這樣的, 有一天我需要在某個共用的 BaseApiController 中取得 request 中的內容並做一些操作, 所以寫下了像是這樣的內容, 然後 他就死掉了 就出現 NullReferenceException 了. 123456789public class BaseApiController : ApiController&#123; public BaseApiController() &#123; var request = Request; // do someting from request, ex: read headers var myHeader = request.Headers.GetValues("MyHeader"); &#125;&#125; 改用 HttpContext.Current.Request發生這個問題其實一開始有點驚訝, 畢竟以前在 Action 中操作 ApiController.Request 都非常順利, 接著很快的在網路上查到了一個相同的提問, 表示改用 HttpContext.Current.Request 就好了, 然後問題就解決了. 根據討論串的說法, ApiController.Request 不能在建構子中使用, 因為在這個階段他還沒被初始化, 所以必然是 null. 兩者有什麼差別?接著試著了解一下 HttpContext.Current.Request 和 ApiController.Request 之間的差別. 首先可以發現 ApiController.Request 回傳了一個 HttpRequestMessage 物件, 且這個屬性是可讀寫的, 而 HttpContext.Current.Request 回傳的是 HttpRequest 物件, 但這個屬性是唯讀的, 另外從下面的原始碼可以看到 HttpRequestMessage 是回傳 ControllerContext.Request 且往上可以追朔到 ActionContext, 由此”推測” ApiController.Request 比較適合在 Action 中使用. 推測跟框架的生命週期與相關成員的初始化時間有關, 但要驗證的話要去爬 code, 目前沒這個需要就先偷懶一下了, 至於 HttpRequest 和 HttpRequestMessage 的差別在 HttpRequest vs HttpRequestMessage vs HttpRequestBase 這篇文章有稍微提到, 不過沒講得太深入. 1234567891011121314151617181920212223242526272829303132333435// copy from https://github.com/aspnet/AspNetWebStack/blob/master/src/System.Web.Http/ApiController.cspublic HttpRequestMessage Request&#123; get &#123; return ControllerContext.Request; &#125; set &#123; if (value == null) &#123; throw Error.PropertyNull(); &#125; HttpRequestContext contextOnRequest = value.GetRequestContext(); HttpRequestContext contextOnController = RequestContext; if (contextOnRequest != null &amp;&amp; contextOnRequest != contextOnController) &#123; // Prevent unit testers from setting conflicting requests contexts. throw new InvalidOperationException(SRResources.RequestContextConflict); &#125; ControllerContext.Request = value; value.SetRequestContext(contextOnController); RequestBackedHttpRequestContext requestBackedContext = contextOnController as RequestBackedHttpRequestContext; if (requestBackedContext != null) &#123; requestBackedContext.Request = value; &#125; &#125;&#125; 結論會碰到這個大概就是對於相似的成員之間的差異與生命週期不了解, 可能要找個時間好好了解一下了. 不過不知道這個 //TODO 會拖多久就是. 參考Request is always null in web api?HttpRequest vs HttpRequestMessage vs HttpRequestBase]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RSA 加解密與簽名]]></title>
    <url>%2Fcontent%2F20190518-rsa-by-dotnet.html</url>
    <content type="text"><![CDATA[.NET 提供的 RSACryptoServiceProvider 用來做 RSA 加解密與驗簽非常方便, 相關的網路資源也很多, 本來是沒什麼好寫的畢竟隨便 google 一下都有, 但是最近發現不知道為什麼用一次查一次然後忘一次, 想想還是稍微紀錄一下用法方便以後速查好了. 加解密使用 XML 格式的公私鑰沒什麼特別的, 就是用 RSACryptoServiceProvider 加解密. 123456789101112131415161718192021public string RSAEncryptFromXMLKey(string publicKey, string plaintext)&#123; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); rsa.FromXmlString(publicKey); var plaintextBytes = Encoding.UTF8.GetBytes(plaintext); var ciphertextBytes = rsa.Encrypt(plaintextBytes, false); var ciphertext = Convert.ToBase64String(ciphertextBytes); return ciphertext;&#125;public string RSADecryptFromXMLKey(string privateKey, string ciphertext)&#123; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); rsa.FromXmlString(privateKey); var ciphertextBytes = Convert.FromBase64String(ciphertext); var plaintextBytes = rsa.Decrypt(ciphertextBytes, false); var plaintext = Encoding.UTF8.GetString(plaintextBytes); return plaintext;&#125; 載入 pfx 檔123456789101112131415161718192021public string RSAEncryptFromPFX(string plaintext)&#123; X509Certificate2 certificate = new X509Certificate2("path/to/certificate.pfx", "password"); var rsa = (RSACryptoServiceProvider)certificate.PublicKey.Key; var plaintextBytes = Encoding.UTF8.GetBytes(plaintext); var ciphertextBytes = rsa.Encrypt(plaintextBytes, false); var ciphertext = Convert.ToBase64String(ciphertextBytes); return ciphertext;&#125;public string RSADecryptFromPFX(string ciphertext)&#123; X509Certificate2 certificate = new X509Certificate2("path/to/certificate.pfx", "password"); var rsa = (RSACryptoServiceProvider)certificate.PrivateKey; var ciphertextBytes = Convert.FromBase64String(ciphertext); var plaintextBytes = rsa.Decrypt(ciphertextBytes, false); var plaintext = Encoding.UTF8.GetString(plaintextBytes); return plaintext;&#125; 註: 方便示範所以把一些參數與物件都寫死在方法中, 實務上該抽參數或是抽離出 X509Certificate2 的操作等都要再考慮 簽名與驗簽使用 XML 格式的公私鑰123456789101112131415161718192021public string RSASignFromXMLKey(string privateKey, string plaintext)&#123; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); rsa.FromXmlString(privateKey); var plaintextBytes = Encoding.UTF8.GetBytes(plaintext); var signBytes = rsa.SignData(plaintextBytes, new SHA1CryptoServiceProvider()); var sign = Convert.ToBase64String(signBytes); return sign;&#125;public bool RSAVerifyFromXMLKey(string publicKey, string sign, string data)&#123; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); rsa.FromXmlString(publicKey); var signBytes = Convert.FromBase64String(sign); var dataBytes = Encoding.UTF8.GetBytes(data); bool isValid = rsa.VerifyData(dataBytes, new SHA1CryptoServiceProvider(), signBytes); return isValid;&#125; 這也沒什麼難的, 不過 VerifyData 這個方法第一個參數是明文, 第三個參數是簽名後的密文比較容易弄反. 另外一個有趣的地方是 VerifyData 的第二個參數和 SignData 的第二個參數型別是 object, 這意味著他可以接受任意型別的輸入, 例如: new SHA1CryptoServiceProvider() 或 &quot;sha1&quot;(不分大小寫的字串), 在使用上我會傾向在封裝 wrapper 時刻意限縮個參數的的型別, 否則呼叫端會很難預期傳入的值是不是正確的, 例如以上例為延伸, 下面的每一行程式碼如果沒經過實測很道運作結果是否一樣(而事實上結果是一樣的). 12345678910var signBytes = rsa.SignData(plaintextBytes, "sha1");var signBytes = rsa.SignData(plaintextBytes, "SHA1");var signBytes = rsa.SignData(plaintextBytes, "SHa1");var signBytes = rsa.SignData(plaintextBytes, SHA1.Create());var signBytes = rsa.SignData(plaintextBytes, new SHA1Managed());var signBytes = rsa.SignData(plaintextBytes, new SHA1CryptoServiceProvider());var signBytes = rsa.SignData(plaintextBytes, new SHA1Cng());var signBytes = rsa.SignData(plaintextBytes, typeof(SHA1));var signBytes = rsa.SignData(plaintextBytes, typeof(SHA1Managed));// etc... 載入 pfx 檔用私鑰簽名時載入 pfx 擋的方式跟加解密時一樣, 簽名與驗簽的相關方法都跟上例一樣, 就不重複貼程式碼了. 結論目前只知道 XML 格式的公私鑰和 PFX 格式的憑證擋在 .NET 下是最方便操作的, 如果還要讀取自其他格式的檔案或公私鑰內容(例如 PEM), 大多要靠其他套件才比較好做, 例如: Bouncy Castle. 參考]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 語言特性更新 - C# 6]]></title>
    <url>%2Fcontent%2F20190322-csharp-language-specification-6.html</url>
    <content type="text"><![CDATA[C# 的版本最近幾年更新的越來越頻繁, 雖然官方有提供版本歷程以及各版本的新特性, 但是還是想整理起來, 在官方提供的語言特性說明外多一點思考並紀錄自己使用上的想法. 本篇是 C# 6.0 C# 6唯讀屬性 (Read-only auto-properties)Read-only auto-properties 1public string Name &#123; get; &#125; 雖然舊版可以用 public string Name { get; private set; } 最大限度的限縮寫入權, 但仍然不是唯讀(只允許在建構子中改變屬性值), 硬要拆成私有唯讀欄位 (private readonly fieldName) 和 getter 方法的組合又失去了自動實作屬性的優點, 難免可惜. 這個特性讓我們能更精細的控制屬性的存取範圍, 用在需要嚴謹的控制屬性的存取範圍的時候很好用. 屬性初始化器 (Auto-property initializers)Auto-property initializers 1public string Name &#123; get; set; &#125; = "Ron"; 極相似於舊版在建構子中初始化屬性的做法, 舊版做法在建構子中初始化屬性的做法在屬性很多時, 排版上會影響可讀性.這個特性能讓屬性初始化更為簡潔, 更容易避免舊的做法的潛在問題. 會說”極相似”從建構子初始化屬性代表還是有一點差異的 舊的做法: 從建構子初始化屬性其實是預設呼叫 setter 方法, 如果沒有 setter 方法則直接操作自動產生的欄位 (但舊版不支援唯讀屬性) 新特性: 直接操作自動產生的欄位, 不管有沒有 setter 方法 以上結論是透過 Msiler 套件產生 IL 碼後觀察的結果 具有運算式主體的函式成員 (Expression-bodied function members)Expression-bodied function members 讓只有單一運算式的方法或唯讀屬性可以用較短的程式碼完成. 這個特性我平常其實不太用, 因為下面這三行的長相太相似了, 在閱讀上比較容易造成混淆, 且如果不小心用錯雖然不會造成編譯錯誤, 但含意卻會完全不同, 而增加的方便性給我的感受不是很強烈.123public string FirstName =&gt; "Ron";private string _lastName = "Sun";public string GetFullName() =&gt; $"&#123;FirstName&#125; &#123;_lastName&#125;"; 不小心手滑用錯的範例如下, 看起來很詭異, 但依然能正常運作:12345678910// "=&gt;" 變成 "=" 從唯讀屬性變成欄位// FirstName 現在看起來像公開欄位, 是私有欄位寫錯變公開了? // 還是應該是唯讀屬性, 只是不小心少了一個 "&gt;"?public string FirstName = "Ron";// "=" 變成 "=&gt;" 從欄位變成唯讀屬性private string _lastName =&gt; "Sun";// 少了 "()" 從方法變成唯讀屬性public string GetFullName =&gt; $"&#123;FirstName&#125; &#123;_lastName&#125;"; 其實如果專案有良好的程式碼規範, 從命名基本上就可以分辨出這個成員應該要是欄位, 屬性還是方法, 加上工程師如果夠謹慎, 上面的失誤應該不會發生, 但假設專案沒有良好的規範又加上手滑打錯的狀況, 後面維護的人就可能會很混亂. 這不是說這個特性不好, 如果對團隊成員的嚴謹度與基礎有信心, 用這個特性也是很不錯的. using staticusing static 12345678910111213141516171819202122using static ConsoleApp1.Person;class Program&#123; static void Main(string[] args) &#123; var nestedPerson = new NestedPerson(); var fullName = GetFullName(); &#125;&#125;public class Person&#123; public static string GetFullName() &#123; return "Ron Sun"; &#125; public class NestedPerson &#123; public string Name &#123; get; set; &#125; = "Ron"; &#125;&#125; 以上面的例子來說, 舊的做法如果要初始化 NestedModel 要寫成 new Model.NestedModel, 呼叫靜態方法 GetFullName() 要寫成 Model.GetFullName() 這個特性我比較不喜歡, 主要是巢狀類別跟靜態方法這樣使用或呼叫的話, 外觀上跟一般類別或該類別內的方法呼叫一樣, 閱讀時如果沒有進去類別或方法中看, 難以分辨他究竟是不是該類別內部的方法. Null 條件運算子 (Null-conditional operators)Null-conditional operators 12345string name = person?.Name;string nameWithDefault = person?.Name ?? "John";var company = person?.Team?.Company;int? age = dictionary?["Ron"];int ageWithDefault = dictionary?["Ron"] ?? -1; 用來省下空值判斷, 要取得物件中的屬性值的時候很好用, 也可以用在需要存取陣列或是索引子(indexer) 的情境. 這個特性神好用, 搭配 ?? 更神, 可以縮短非常多空值判斷的程式碼, 尤其是像 model.Nested.Property 這種巢狀的存取更明顯, 就上面的範例來說, 舊的做法就明顯冗長, 如下面比較: 123456789101112131415161718192021222324// string name = person?.Name;string name = null;if(person != null)&#123; name = person.Name;&#125;// string nameWithDefault = person?.Name ?? "John";string nameWithDefault = "John";if(person != null)&#123; nameWithDefault = person.Name;&#125;// Company company = person?.Team?.Company;Company company = null;if(person != null &amp;&amp; person.Team != null)&#123; company = person.Team.Company;&#125;// int? age = dictionary?["Ron"];// int ageWithDefault = dictionary?["Ron"] ?? -1;// ...依此類推 舊的做法的範例還是為了避免巢狀 if-else 而簡化過的, 如果是直覺式的 if-else 一層層科下去, 差異就更明顯了. 字串插補 (String interpolation)String interpolation 1public string FullName =&gt; $"&#123;FirstName&#125; &#123;LastName&#125;"; 神好用, 真心不騙, 這個範例看起來可能沒有感覺, 會覺得用 string.Format() 做也不錯啊, 但情境夠複雜的話無疑是海放最古典的字串相加, 也避免了 string.Format() 遇到大量參數的時候容易排錯順序的問題, 如果有用過組過 SOAP 用的 XML 內容的話, 就能明顯感受到它的威力了. 另外, 搭配 @ 使用, 效果更好. 這個特性還有有很多進階用法, 官方資源如下: Use string interpolation to construct formatted strings $ - string interpolation (C# Reference) String interpolation in C# 例外狀況篩選條件 (Exception filters)Exception filters 這個特性還沒機會用到, 不過目前看起來有兩個好處: 讓 Catch 區塊的情境更精細, 減少 Catch 區塊內的條件判斷. 攔截例外前多了一個機制可以判斷真的要攔截這個例外或是讓他繼續往外拋, 可以避免掉有條件重拋例外所造成的 StackTrace 被改變的問題, 重拋例外產生的問題之前寫過一篇 正確重拋例外. nameof 運算式 (The nameof expression)The nameof expression 12345678// output: MethodConsole.WriteLine(nameof(Class1.Method));// output: PropertyConsole.WriteLine(nameof(Class1.Property));// output: PropertyConsole.WriteLine(nameof(Class1.NestedClass.Property)); 好東西, 這個特性比較偏可維護性的優化, 很在意可維護性的工程師會很愛用. 需要在字串中放型別名稱, 方法名稱, 欄位名稱, 屬性名稱等等的情境時, 舊方法都是直接寫死字串, 這樣會導致重新命名的時候 visual studio 會將這些字串忽略掉, 老舊專案的 log 中就很常出現與實際不吻合的方法名稱. 另外一個情境是反射, 如果專案中有用反射存取特定成員或呼叫方法, 在重新命名的時候往往會被忽略, 偏偏這種情境只能等到執行階段才會被發現, 導致重新命名風險提高, 但使用 nameof 之後, 可以避免這類問題, 重新命名時也可以更安心. Catch 和 Finally 區塊中的 AwaitAwait in Catch and Finally blocks Initialize associative collections using indexersInitialize associative collections using indexers 12345var dic = new Dictionary&lt;string, string&gt;()&#123; ["key1"] = "value1", ["key2"] = "value2",&#125;; 舊的寫法是如下面這樣.12345var dic = new Dictionary&lt;string, string&gt;()&#123; &#123; "key1", "value1" &#125;, &#123; "key2", "value2" &#125;&#125;; 恩…乍看之下就是用換個初始化的語法, 但內部運作卻是不一樣的, 讓我們繼續看下去… 透過工具看了一下編譯出來的 IL 碼發現兩者實際的運作並不同, 舊的做法呼叫的是 Add(System.String,System.String) 方法, 而 C# 6 的語法呼叫的是 set_Item(System.String,System.String), 而這樣的差別會在某些情境下使得運作結果不同.12345678910111213141516171819202122// var dic = new Dictionary&lt;string, string&gt;()// &#123;// &#123; &quot;key1&quot;, &quot;value1&quot; &#125;// &#125;;IL_002B newobj System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::.ctor()IL_0030 dupIL_0031 ldstr &quot;key1&quot;IL_0036 ldstr &quot;value1&quot;IL_003B callvirt System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::Add(System.String,System.String)IL_0040 nopIL_0041 stloc.0// var dic2 = new Dictionary&lt;string, string&gt;()// &#123;// [&quot;key1&quot;] = &quot;value1&quot;// &#125;;IL_0042 newobj System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::.ctor()IL_0047 dupIL_0048 ldstr &quot;key1&quot;IL_004D ldstr &quot;value1&quot;IL_0052 callvirt System.Void System.Collections.Generic.Dictionary`2&lt;System.String,System.String&gt;::set_Item(System.String,System.String)IL_0057 nopIL_0058 stloc.1 根據官方說明, 新的語法是個 “Index Initializers”, 搭配 New Ways to Initialize Collections in C# 6 這篇大神文章中的描述: There is one caution. The new initializer syntax calls the indexer method to add items to the collection. That same indexer method replaces items as well as adding items. 可以發現新的寫法由於是直接操作 indexer, 所以當索引 (key) 重複的時候會直接將值覆蓋, 不同於舊版做法的拋出例外, 可以由下面兩段程式碼來比較兩者差異123456789101112131415// throw an exception because of duplicate keyvar dic = new Dictionary&lt;string, string&gt;()&#123; &#123; "k", "v1" &#125;, &#123; "k", "v2" &#125;&#125;;Console.WriteLine(dic["k"]);var dic2 = new Dictionary&lt;string, string&gt;()&#123; ["k"] = "v1", ["k"] = "v2",&#125;;// the value should be "v2" because the second value of key "k" replace first oneConsole.WriteLine(dic2["k"]); Extension Add methods in collection initializersExtension Add methods in collection initializers 這個又需要大神文章救援了. 總之就是讓下方語法預設呼叫另外寫的擴充方法 Add 使得初始化能在語意上更為順暢.12345var myCollection = new MyStringCollection()&#123; "Ron", "Sun"&#125; Improved overload resolutionImproved overload resolution Deterministic compiler outputDeterministic compiler output 結論本來以為對 C# 特性已經算熟了, 沒想到還是有不少平常沒用到就以為他不存或是一直有錯誤理解的特性, 看來要找個時間一個一個仔細看看了. 參考New Ways to Initialize Collections in C# 6What’s New in C# 6]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web API 回傳資料的方式]]></title>
    <url>%2Fcontent%2F20190317-webapi-response-data-format.html</url>
    <content type="text"><![CDATA[這篇是要稍微記一下 Web API 回傳資料的幾種方式與格式, 會想要記這一篇是因為以前碰過的 Web API 專案都有統一的回傳 (response) 格式, 但是最近碰到一些專案的 Web API 在回傳資料時是沒有規範的, 例如直接就 return true, 所以就稍微整理一下回傳資料的幾種方式與優缺點. 直接回傳物件這個就是上面說的, 直接像 return anyObject 這樣回傳, 如下面的程式碼 1234567891011121314151617181920212223242526public bool Get()&#123; return true;&#125;public DemoModel Get()&#123; var data = new DemoModel() &#123; Name = "Ron", Age = 18 &#125;; return data;&#125;public Dictionary&lt;string,string&gt; Get()&#123; var data = new Dictionary&lt;string, string&gt;() &#123; ["Name"] = "Ron", ["Age"] = "18" &#125;; return data;&#125; 優缺點優點 簡單直覺又方便 缺點 凌亂不統一, 回傳的資料可能出現原生型別, model 或是其他各種型別 只回傳資料, 沒有任何狀態類的欄位與 http status, 當 client 端收到空物件或例外時難以判斷問題 後期需要加狀態時很麻煩, 例如每支 API 各自加狀態欄位容易亂, 如果要抽共用還要考慮資料的結構或階層被改變對客戶端的影響 使用時機這種做法適合用在 簡單的小專案, 複雜度小就沒太大影響 Web API 只提供內部使用, client 跟 API 是同一組人開發的, 狀態類欄位的必要性不大 套用共用回傳物件與狀態同時考慮回傳資料, http status 與例外內容三種情況, 如下 IHttpActionResult 是 Web API 2 的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ResponseModel&lt;T&gt;&#123; public string Code &#123; get; set; &#125; = "0000"; public string Message &#123; get; set; &#125; = "Success"; public T Data &#123; get; set; &#125;&#125;// Web APIpublic HttpResponseMessage Get(bool isError)&#123; var responseModel = new ResponseModel&lt;DemoModel&gt;(); if (isError) &#123; responseModel.Code = "0001"; responseModel.Message = "Prameter 'isError' should be false."; var response = Request.CreateResponse(HttpStatusCode.BadRequest, responseModel); throw new HttpResponseException(response); &#125; responseModel.Data = new DemoModel() &#123; Name = "Ron", Age = 18 &#125;; return Request.CreateResponse(HttpStatusCode.OK, responseModel);&#125;// Web API 2public IHttpActionResult Get(bool isError)&#123; var responseModel = new ResponseModel&lt;DemoModel&gt;(); if (isError) &#123; responseModel.Code = "0001"; responseModel.Message = "Prameter 'isError' should be false."; return Content(HttpStatusCode.BadRequest, responseModel); &#125; responseModel.Data = new DemoModel() &#123; Name = "Ron", Age = 18 &#125;; return Ok(responseModel);&#125; 特別的 HttpResponseException上面例子中, HttpResponseException 是一個很特別的例外, 這個例外不會被 ExceptionFilterAttribute, ExceptionHandler 或是 ExceptionLogger 所攔截, 所以在 service 層中使用 HttpResponseException 是一個很好的選項, 既能直接返回 http status 和內容, 又不會被全域例外處理機制攔截, 像是這樣 throw new HttpResponseException(response). 順帶一提, ExceptionHandler 和 ExceptionLogger 是實測的時候才發現會忽略 HttpResponseException, 官方文件只提到 ActionFilterAttribute 的部分, 節錄如下: An exception filter is executed when a controller method throws any unhandled exception that is not an HttpResponseException exception. The HttpResponseException type is a special case, because it is designed specifically for returning an HTTP response. 優缺點優點 明確回傳 http status, 對 client 端來說遇到問題容易釐清方向 細部狀態碼 (Code) 與訊息 (Message) 方便 client 端對接與使用 缺點 比較麻煩, 需要花時間了解並選擇適合的 http status, 也需要定義細部狀態碼 (Code) 與訊息 (Message) 共用回傳物件的幾種設計回傳物件的共用部分要怎麼設計也是有幾種方式 泛型版包一層 ResponseModel&lt;T&gt;, 可以直接套用到所有需要回傳物件的 API 上, 但是因為多包了一層, 序列化的結果會多一層, 如果套用在舊的 API 上會使得回傳資料的階層被改變, 會影響所有 client 端. 12345678public class ResponseModel&lt;T&gt;&#123; public string Code &#123; get; set; &#125; = "0000"; public string Message &#123; get; set; &#125; = "Success"; public T Data &#123; get; set; &#125;&#125; 不用泛型沒有泛型, ResponseModel 讓其他要回傳的 model 繼承或包含, 如果套用在舊的 API 上, 在序列化後只會增加欄位, 不會改變舊有欄位的階層, 對現存 API 的擴展很友善, 但是相對於泛型版比較不好用, 因為即使只是要回傳一個基本型別(bool / string) 也需要建立 model. 123456public class ResponseModel&#123; public string Code &#123; get; set; &#125; = "0000"; public string Message &#123; get; set; &#125; = "Success";&#125; 回傳物件型別有兩種使用 ResponseModel 的方法, 繼承或包含, 序列化結果不同, 視情境或團隊共識使用. 1234567891011121314151617// 繼承public class DemoModel : ResponseModel&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125;// 包含public class DemoModel&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public ResponseModel Error &#123;get; set; &#125;&#125; 使用時機這種做法適合用在 邏輯複雜或是有各種驗證狀態與結果的 API 需要對外開放的 API (跨部門 / 公開 API) 結論雖然稍微整理一下幾種做法與適用情境, 不過實際運用不太會照抄, 還是要視情況做細部的調整, 就跟設計模式在使用的時候常常需要配合專案需求變形過一樣. 參考Best practice to return errors in ASP.NET Web APIException Handling in ASP.NET Web API]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web API 中的全域錯誤處理]]></title>
    <url>%2Fcontent%2F20190308-global-exception-handle-in-webapi.html</url>
    <content type="text"><![CDATA[在 Web API 中, 例外處理是一定會遇到的問題, 以前常常見到一些專案為了怕出現 unhandled exception 就地毯式的將所有方法都加上 try-catch, 但是這樣使用 try-catch 會有很大的副作用, 一來無差別的吃掉所有例外會導致程式不易除錯, 二來到處散布的 try-catch 和相關的 log 在維護上的成本也很高, 尤其是大型專案更是明顯, 第三也會使得商務邏輯跟這些例外處理混雜在一起 (try-catch 不是不能用, 但是他是有使用時機的). 而 ASP.NET Web API 2 中其實提供了很多種全域的例外處理方式, 例如: ExceptionFilterAttribute, ExceptionLogger, ExceptionHandler, 能將攔截未處理的例外的任務抽離出來, 讓我們開發時能更專注在重要的商務邏輯上, 這篇主要紀錄一下這三種全域例外處理的方式與差別. ExceptionFilterAttribute 在 WebApi 2 中的 FilterAttribute 介紹與應用 這篇文章中已經有提到 FilterAttribute 的用法, 但是 ExceptionFilterAttribute 他在整個 Web API 的生命週期中是比較後面的, 所以某些階段所引發的例外他無法捕捉到, 官方也明確指出了這個特性, 節錄如下: Some unhandled exceptions can be processed via exception filters, but there area number of cases that exception filters can’t handle. For example: Exceptions thrown from controller constructors. Exceptions thrown from message handlers. Exceptions thrown during routing. Exceptions thrown during response content serialization. We want to provide a simple, consistent way to log and handle (where possible)these exceptions. ExceptionFilterAttribute 是個不錯的選項, 但受限於生命週期, 所以攔截的範圍沒那麼廣. ExceptionLogger / ExceptionHandlerExceptionLogger 和 ExceptionHandler 能攔截 ExceptionFilterAttribute 所攔截不到的例外, 下面分別是 ExceptionLogger 和 ExceptionHandler 的實作方式. 實作方式1234567891011121314151617public class DemoExceptionHandler : ExceptionHandler&#123; public override void Handle(ExceptionHandlerContext context) &#123; Debug.WriteLine("======== DemoExceptionHandler ======="); context.Result = new InternalServerErrorResult(context.Request); &#125;&#125;public class DemoExceptionLogger : ExceptionLogger&#123; public override void Log(ExceptionLoggerContext context) &#123; Debug.WriteLine("======== DemoExceptionLogger ======="); &#125;&#125; 實作後要在 WebApiConfig.cs 中註冊. 123456789101112public static class WebApiConfig&#123; public static void Register(HttpConfiguration config) &#123; // skip... config.Services.Replace(typeof(IExceptionHandler), new DemoExceptionHandler() config.Services.Add(typeof(IExceptionLogger), new DemoExceptionLogger());); // skip... &#125;&#125; 另外有幾個要注意的點: ExceptionHandler 只能有一個, 所以呼叫 config.Services.Replace() ExceptionLogger 可以有多個, 所以呼叫 config.Services.Add(), 存在多個 ExceptionLogger 時, 先加入的先執行 ExceptionLogger 會比 ExceptionHandler 先執行 ExceptionLogger 也可以呼叫 config.Services.Replace(), 不管之前加了幾個 ExceptionLogger, config.Services.Replace() 會將全部都取代成一個, 所以他不是換掉某一個而已 差異ExceptionLogger 是用於紀錄攔截到的例外, ExceptionHandler 是用於攔截到錯誤後的處理, 所以 ExceptionHandlerContext 中多了一個 public IHttpActionResult Result { get; set; } 屬性, 讓我們可以決定攔截到錯誤後要回傳什麼給客戶端, 這在上面程式碼中也可以看出差異. 如果同時要紀錄攔截到的錯誤並回傳特定內容給客戶端, 目前我是只用 ExceptionHandler 處理, 沒有同時實作 ExceptionLogger 和 ExceptionHandler. 結論以前都只用 ExceptionFilterAttribute 來攔截錯誤, 也沒有特別去找其他做法, 剛好跟別人聊天時有提到全域例外處理跟生命週期的話題才被提醒有這個差別, 意外賺到一個之前都不知道的好東西. 參考Global Error Handling in ASP.NET Web API 2Exception Handling in ASP.NET Web API]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[整合 DocFx 和 Visual Studio 並佈署上 GitHub Pages]]></title>
    <url>%2Fcontent%2F20190124-docfx-with-visual-studio-on-github-pages.html</url>
    <content type="text"><![CDATA[DocFx 是一個很方便的專案文件製作工具, 能將 XML 文件註解轉換成靜態網頁, 也可以轉化其他另外寫的 Markdown 格式的文件, 這篇主要的目的是紀錄如何將 DocFx 與 Visual Studio 整合, 在編譯後產出專案文件並佈署到 GitHub Pages. 順便提一下, 適用情境是在 visual stuiod 上開發 .NET 專案, 並且希望能統一管理, 其他情境不一定適合這樣整合. 如何建立建立工具專案建一個獨立的工具專案用來放 DocFx 需要的套件, 刻意跟產品專案分開的目的是希望文件建立工具與產品程式碼不要混在同一個專案, 另外這個工具專案不含程式碼但要是可以在 visual studio 中編譯的, 所以選用 Class Library. 專案結構與 Demo 程式碼如下圖 (TryDocFx.DocFx 是工具專案, 而 TryDocFx.ClassLib 是產品專案): 由於目標是能簡單佈署文件到 GitHub Pages 上, 所以這邊是用 docs 資料夾來做為 GitHub Pages 的根目錄, 而不是 gh-pages 分支, 也因此資料夾結構是如下面所示: 12345TryDocFx |---- docs |---- src |---- TryDocFx.ClassLib |---- TryDocFx.DocFx 安裝 docfx.console從 Nuget 中找到 docfx.console 並安裝在上一步建立好的工具專案 (TryDocFx.DocFx) 中, 安裝完後, 會自動在工具專案中建立必要的檔案, 如下圖: 修改設定設定檔是 docfx.json, 官方文件有提供這個設定檔的說明, 以本例來說需要修改幾個地方. 因為產品程式碼不在目前專案中, 所以需要需要指定產品程式碼來源: &quot;src&quot;: &quot;../TryDocFx.ClassLib&quot;. 套件預設會把靜態網頁放在目前專案的 _site 資料夾下, 因為我們要佈署到 GitHub Pages 上, 所以需要修改輸出路徑: &quot;dest&quot;: &quot;../../docs&quot;. exclude 的部分, 由於本例輸出路徑和工具專案是分開的, 所以可以從 exclude 設定中將 &quot;_site/**&quot; 拿掉. 其實整個設定檔應該可以更簡潔, 例如說在本文的情境中 exclude 節點可能是可以移除的, 不過細節要一一研究太花時間了, 如果之後工作上有用到再來詳細了解設定檔的完整內容吧. 修改後範例如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; "metadata": [ &#123; "src": [ &#123; "files": [ "*.csproj" ], "cwd": ".", "exclude": [ "**/obj/**", "**/bin/**" ], "src": "../TryDocFx.ClassLib" &#125; ], "dest": "obj/api" &#125; ], "build": &#123; "content": [ &#123; "files": [ "api/**.yml" ], "cwd": "obj" &#125;, &#123; "files": [ "api/*.md", "articles/**.md", "toc.yml", "*.md" ], "exclude": [ "obj/**" ] &#125; ], "resource": [ &#123; "files": [ "images/**" ], "exclude": [ "obj/**" ] &#125; ], "overwrite": [ &#123; "files": [ "apidoc/**.md" ], "exclude": [ "obj/**" ] &#125; ], "dest": "../../docs", "template": [ "default" ] &#125;&#125; 編譯專案改好設定後, 只要在 visual studio 中編譯 TryDocFx.DocFx 這個工具專案, 他就會根據設定將產品專案的 XML 文件註解轉換成靜態網頁並輸出到設定的輸出路徑中 (../../docs).最後只要設定好 GitHub Pages 並將專案全部推上 GitHub 就完成了. 結論可以將 C# 中的 XML 文件註解自動轉換成文件的方式很多, 不過如果要同時能整合 visual studio 又能包含自己寫的 Markdown 文件, 還得方便佈署的話, DocFx 是不錯的選擇. 而從設定檔的結構與內容不難看出, 他的功能應該更強大, 不過這就等之後遇到複雜的情境時在來仔細研究了. 參考DocFx]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[將 Stopwatch 封裝成小工具]]></title>
    <url>%2Fcontent%2F20190112-stopwatch-util.html</url>
    <content type="text"><![CDATA[Stopwatch 經常被用來觀察程式的運行時間, 在開發階段能協助我們抓出一些效能的問題, 不過他的基本使用方式不是很漂亮, 在程式碼中插入一堆 Stopwatch 會干擾開發或是不小心沒移除而 commit 上版控也不好. 另一方面, 如果有需要用他來觀察 production 環境的運作效能的時候, 這些穿插在主要程式碼中的 Stopwatch 就更加干擾了, 所以找了兩個方法來將 Stopwatch 封裝成小工具. Action這個方式是將主要邏輯 action() 以及紀錄運行時間的方法 report(ticks) 做為 Action 傳進工具中執行, 並在執行前後加上 Stopwatch 計算運行時間後呼叫紀錄運行時間的方法 report(ticks). 其中第二個參數 report(ticks) 會存在主要是假設呼叫端對於回傳執行時間的所做的處理不同, 如果覺得兩個 Action 參數過於複雜, 可以把第二個參數改成選擇性參數, 沒傳入的話就執行預設的行為就好, 或者目前系統沒這個需求的話, 也可以不需要第二個參數. 範例如下: 1234567891011121314public class StopwatchReporter&#123; public static void Execute(Action action, Action&lt;long&gt; report) &#123; var stopwatch = Stopwatch.StartNew(); action(); stopwatch.Stop(); var excusionTicks = stopwatch.ElapsedTicks; report(excusionTicks); &#125;&#125; 這樣封裝非常簡單易懂, 使用上也還算方便, 可以輕易的將主要邏輯與效能監控分開, 如下:123456789StopwatchReporter.Execute( () =&gt; &#123; // Do anything here &#125;, ticks =&gt; &#123; // Logging excusion time or something else here &#125;); 實作 IDisposable上一個方法唯一的小缺點就是還是需要將主要流程包進 Action 裡面, 雖然 C# 提供的語法糖已經大幅提高可讀性了, 不過還是有其他方法能讓呼叫端看起來更簡潔. 123456789101112131415161718192021222324public class StopwatchReporter : IDisposable&#123; private string _name; private Stopwatch _stopwatch; public StopwatchReporter(string name) &#123; _name = name; _stopwatch = new Stopwatch(); _stopwatch.Start(); &#125; public void Dispose() &#123; _stopwatch.Stop(); var excusionTime = _stopwatch.ElapsedMilliseconds; // logging here Debug.WriteLine($"&#123;_name&#125; excusion time: &#123;excusionTime&#125; ms"); _name = null; _stopwatch = null; &#125;&#125; 這種做法最大的優點就是呼叫端極致簡潔, 如下:1234using (new StopwatchReporter("something"))&#123; //Do anything here...&#125; 但其實這種做法缺點比較多, 一來是實作複雜度提高很多, 且在我所參考的文章下面的回覆中有提到, 為了這個便利性而讓程式碼在釋放資源用的方法中去操作資源, 下面節錄自該則回覆: You implement IDisposable when you are managing resources. Implementing it communicates to other developers that you’re doing dealing with memory usage, and implies that you SHOULD call Dispose as soon as reasonably possible. Using it as syntactic sugar confuses that message. Patterns and interfaces communicate intent. Using a pattern because you like the way it reads while ignoring what the interface intends creates cluttered code. 其實我個人是滿認同這則回覆的, 雖然對於呼叫端來說並不需要知道實作細節, 但就設計的角度來看, 的確是在一個釋放資源的 Dispose() 方法中做了意想不到的行為, 如果是單純把 Stopwatch 停止並釋放倒是還好, 但是如果要紀錄時間就可能會依賴其他組件, 當複雜度一提高, 這個做法的缺點就會更明顯. 結論兩種做法要選的話, 我會選第一種用 Action 的作法, 比較合理好懂且呼叫方式也夠整潔. 但總體來說, 目前為止對於特別封裝這麼一個工具我還是覺得有點雞肋, 只是說如果真的很必要在真實的 production 環境監控的話也是一種可行方案, 就先記起來備忘, 搞不好哪天真的會用上. 參考Exact time measurement for performance testingCode Tip: Simpler Performance Timer Logging in C#]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指示詞(#if) 和 ConditionalAttribute]]></title>
    <url>%2Fcontent%2F20190111-if-directive-and-conditional.html</url>
    <content type="text"><![CDATA[有時候我們會需要用到 C# 的前置處理器指示詞(Preprocessor Directives) 中的 #if 等相關指示詞, 最常見的就是用來區分 Debug 和 Release 的編譯模式. 也有另外一種方式 (ConditionalAttribute) 可以達到類似的效果, 但兩種方式的運作機制是不一樣的. 這類型的條件編譯最常用在環境區分, 而不管用 #if 還是 ConditionalAttribute, 都要定義專案在各種模式下的 compilation symbol, 要注意的是這部分是大小寫敏感, 雖然用小寫不會有問題, 但一般來說是用全大寫, 例如: DEBUG. 設定方式如下: #if, #elif, #else運作方式被 #if, #elif 包起來的區間不符合定義的 compilation symbol 時, 編譯時會直接略過區間內的程式碼, 也就是說不會被編譯, 以下面程式碼與 IL 為例 12345678910public void Caller()&#123;#if DEBUG Console.WriteLine("DEBUG: IfDirective Executed");#elif RELEASE Console.WriteLine("RELEASE: IfDirective: Executed");#else Console.WriteLine("IfDirective Executed");#endif&#125; 12345IL_0000 nopIL_0001 ldstr &quot;DEBUG: IfDirective Executed&quot;IL_0006 call System.Void System.Console::WriteLine(System.String)IL_000B nopIL_000C ret 透過工具, 我們可以看到在 DEBUG 下編譯, 只剩 DEBUG 區塊的程式碼. 優缺點這樣雖然不需要的程式碼不會被編譯, 但是從使用方式看來, 如果不小心使用的話很容易讓程式碼變得很髒亂, 到處都是 #if, #elif 和 #else. 而從另外一個角度看, 因為不滿足條件的區塊不會被編譯, 所以很多 visual studio 提供的功能都會無法使用, 維護上很容易造成困擾, 例如在 DEBUG 下將一個方法重新命名, 結果這個方法在 RELEASE 區間有被呼叫到, 卻不會被修改到, 當切換到 RELEASE 的時候就無法通過編譯, 又例如尋找所有引用 (Find All References) 的功能也是一樣. ConditionalAttribute運作方式當不符合 ConditionalAttribute 所套用的 compilation symbol 時, 編譯後會忽略呼叫端的呼叫, 但是保留被呼叫部分的程式碼, 以下面程式碼與 IL 為例 1234567891011121314151617public void Caller()&#123; DebugConditional(); RELEASEConditional();&#125;[Conditional("DEBUG")]public void DebugConditional()&#123; Console.WriteLine("DEBUG: Conditional Executed");&#125;[Conditional("RELEASE")]public void RELEASEConditional()&#123; Console.WriteLine("RELEASE: Conditional Executed");&#125; 1234567891011121314151617181920// Selected method: LazyGuy.Demo.CallerIL_0000 nopIL_0001 ldarg.0IL_0002 call System.Void LazyGuy.Demo::DebugConditional()IL_0007 nopIL_0008 ret// Selected method: LazyGuy.Demo.DebugConditionalIL_0000 nopIL_0001 ldstr &quot;DEBUG: Conditional Executed&quot;IL_0006 call System.Void System.Console::WriteLine(System.String)IL_000B nopIL_000C ret// Selected method: LazyGuy.Demo.RELEASEConditionalIL_0000 nopIL_0001 ldstr &quot;RELEASE: Conditional Executed&quot;IL_0006 call System.Void System.Console::WriteLine(System.String)IL_000B nopIL_000C ret 透過工具, 我們可以看到在 DEBUG 下編譯, 呼叫端的呼叫只剩 DebugConditional(), 而 RELEASEConditional() 這個方法還是會被編譯, 只是沒被呼叫. 優缺點ConditionalAttribute 有很多使用限制 只能加在 void method 以及 attribute class 上 不能加在實作介面的方法上 不能加在 override 方法上 這個方法雖然限制很多, 但是也有很多好處如下: 首先, 因為 ConditionalAttribute 只能加在 void method 以及 attribute class 上, 所以變相強制我們將這些程式碼抽出成獨立的方法, 避免 #if 會產生的副作用. 即使將 #if 中的程式碼抽出成獨立方法, 但因為編譯時並不會移除呼叫端的呼叫, 所以會變成呼叫一個空方法, 也不是太好, 反之 ConditionalAttribute 就不會有這個問題. 第二, 他也不會有 #if 在使用 visual studio 的輔助功能時的問題. 結論如果就這兩個來比較, 使用 ConditionalAtrribute 取代 #if 會比較好, 如果因為 ConditionalAtrribute 的限制而無法使用, 最後再改用 #if.不過這種需要依照環境切換邏輯的情境, 我會優先往 config 或後臺設定的方向思考, 除非用設定還是處理的不夠好, 才會往 ConditionalAtrribute 的方向想. 參考C# : Conditional Attribute and #if DirectiveIf You’re Using “#if DEBUG”, You’re Doing it Wrong#if (C# Reference)Conditional (C# Programming Guide))#if DEBUG vs. Conditional(“DEBUG”)]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[將 RSA 金鑰轉成 XML 格式的少見問題]]></title>
    <url>%2Fcontent%2F20190105-bouncycastle-rsa-key-with-leading-zero-to-xml.html</url>
    <content type="text"><![CDATA[.NET 內建的 RSA 加解密相關元件可以用讀取憑證檔或是 XML 格式的金鑰的方式來初始化, 之前的專案都是用讀取 XML 的方式來操作, 讓管理者能夠方便的從後台來管理金鑰. 而在 PEM 檔中, 金鑰的格式是 base64 字串, 這用 JAVA 是可以正常讀取的, 但卻不是 .NET 接受的 XML 格式, 因此用了一個第三方套件 Bouncy Castle 來幫忙轉換, 但是在一個少見的情境下 (其實也沒有多少見, 我用 OpenSSL 隨機生 500 組, 就有 10 組觸發), 轉換出來的 XML 是錯誤的, 且只有私鑰有發生過. 問題如果有在網路上找過金鑰轉換的方式的話, 應該不難找到下面段轉換私鑰的程式碼, 透過 RSAPrivateKeyJava2DotNet(string privateKey) 方法來將 base64 格式的私鑰轉換成 XML 格式. 12345678910111213141516171819202122232425public string SignDataByPrivateKey(string data, string key)&#123; string xmlData = RSAPrivateKeyJava2DotNet(key); RSACryptoServiceProvider privateKey = new RSACryptoServiceProvider(); privateKey.FromXmlString(xmlData); var signBytes = privateKey.SignData(Encoding.UTF8.GetBytes(data), "sha1"); return Convert.ToBase64String(signBytes);&#125;public string RSAPrivateKeyJava2DotNet(string privateKey)&#123; RsaPrivateCrtKeyParameters privateKeyParam = (RsaPrivateCrtKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKey)); return string.Format( "&lt;RSAKeyValue&gt;&lt;Modulus&gt;&#123;0&#125;&lt;/Modulus&gt;&lt;Exponent&gt;&#123;1&#125;&lt;/Exponent&gt;&lt;P&gt;&#123;2&#125;&lt;/P&gt;&lt;Q&gt;&#123;3&#125;&lt;/Q&gt;&lt;DP&gt;&#123;4&#125;&lt;/DP&gt;&lt;DQ&gt;&#123;5&#125;&lt;/DQ&gt;&lt;InverseQ&gt;&#123;6&#125;&lt;/InverseQ&gt;&lt;D&gt;&#123;7&#125;&lt;/D&gt;&lt;/RSAKeyValue&gt;", Convert.ToBase64String(privateKeyParam.Modulus.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.PublicExponent.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.P.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.Q.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.DP.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.DQ.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.QInv.ToByteArrayUnsigned()), Convert.ToBase64String(privateKeyParam.Exponent.ToByteArrayUnsigned()) );&#125; 這段程式碼一般情境下沒有問題, 但是如果用下面的測試私鑰來試, 就會在 privateKey.FromXmlString(xmlData); 這一行拋出 CryptographicException 且錯誤資訊只有短短的 “Bad Data.\r\n”. Private Key :MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAOEZbmixVVPO6Z96 sGqb8G3gBOgBuLc6o673GyxLZPXPk6VaBF+2LJ+WnIbuYu3iDE2pR1SHeA09BCyz YJnJTYl77vqzRqyzf9lWHGJDkwpEnftlDfeIc5ICfWpu3bHuBuzmtIfqrErCbaJJ 3HkhOsuJ3oL8dAYQN5RTt66IpSn9AgMBAAECgYBEOuotj7sWeTx1W8IHvpbFJ0c1 b/gmif69dSdmaMAEhlPxpfR3cofaI9P0TmPsST2DeNEnPRzVnm4agpDAbLU0ana1 I8pfjRq3xrlTJkDjWKOyaFF2afo2y1pyIFsm1G5wVEFwKWSNUo/1Jy61H4snYxMk /SCZqAYxO3S12jAFHQJBAP6Cv1MV8HcBMuDgyl9Obq/tU6r9zrGOmR1bWBA61DVw jcWgMSpo8dkBAs0Hd5SfWNNzUIVH2gryAcy5Skyq8mMCQQDiaqBM2nCLfQ3EaLzy e1tYZCuZYiZl60OX9nS9FNLFwSI6sFsy/+aGg1ivSVHvXpi9N1oaNgvSI13z9DT0 B/AfAkAArfqyzxkwSCmJnjAMJxp2j8ysZTcbFEVmZasLiAyvA9jtEStwcI1Mxgrq 3z07gV1sWx9466MyakkE8e233LD/AkEA244n+b6NCkZu1jn2l3CVaIZiXO93areT qUV9eGk75jXdemnPVgoeQewWUIvZ3zOtCzcksWwdVF2lWs5Bly4nYwJBAK+niJt3 7jWf13muppL1aRN/i1otm3yNZuNGhrCZ/nEfehhBtege3IHn337fuyLhlXMc37OY k1iKRpcW8kn4LFQ= 原因當初也是找了很久, 最後發現 privateKeyParam.DP.ToByteArrayUnsigned() 中的 DP 只有 63 bytes, 少了一個位元組, 而造成這個現象的原因是因為 privateKeyParam.DP 是數值型態, Org.BouncyCastle.Math.BigInteger 在初始化的時候, 跳過了開頭的所有 0, 而且這個問題在 DP , DQ , Exponent , QInv 這四段上面都會發生. 根據官方JIRA 上的單子 BMA-92 可以看出是在 Org.BouncyCastle.Math.BigInteger 初始化過程造成的, 從原始碼中看起來也很合理(不過我只是看看原始碼推測的, 沒有直接拉下來驗證, 不保證真的是):從 public BigInteger(byte[] bytes) : this(bytes, 0, bytes.Length)=&gt; public BigInteger(byte[] bytes, int offset, int length)=&gt; private static int[] MakeMagnitude(byte[] bytes, int offset, int length)中的 firstSignificant 這個 flag 以第一個非 0 位置為起點 而用這個發現來推論, 也可以理解為什麼公鑰不會有這問題, 因為公鑰只有 Modulus 和 Exponent 這兩段. 解決方式其實這個轉換過程 Bouncy Castle 有提供更簡便的方式, 不需要自己串, 將 RSAPrivateKeyJava2DotNet(string privateKey) 改成像下面這樣(公鑰的部分也一併改了): 1234567891011private static string RSAPrivateKeyJava2DotNet(string privateKey)&#123; RsaPrivateCrtKeyParameters privateKeyParam = (RsaPrivateCrtKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKey)); return DotNetUtilities.ToRSA(privateKeyParam).ToXmlString(true);&#125;public static string RSAPublicKeyJava2DotNet(string publicKey)&#123; RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKey)); return DotNetUtilities.ToRSA(publicKeyParam).ToXmlString(false);&#125; 如果有追進去原始碼看可以發現, 他在要轉換成 XML 字串前, 將開頭有 0 被忽略的部分再補回來, 實測後也確實可以避免原本的問題, 他的 call stack 有點長, 這裡直接列出最關鍵的地方如下, 就是 ConvertRSAParametersField 這個方法才避免掉這個問題的: 12345678910111213141516171819202122232425262728public static RSAParameters ToRSAParameters(RsaPrivateKeyStructure privKey)&#123; RSAParameters rp = new RSAParameters(); rp.Modulus = privKey.Modulus.ToByteArrayUnsigned(); rp.Exponent = privKey.PublicExponent.ToByteArrayUnsigned(); rp.P = privKey.Prime1.ToByteArrayUnsigned(); rp.Q = privKey.Prime2.ToByteArrayUnsigned(); rp.D = ConvertRSAParametersField(privKey.PrivateExponent, rp.Modulus.Length); rp.DP = ConvertRSAParametersField(privKey.Exponent1, rp.P.Length); rp.DQ = ConvertRSAParametersField(privKey.Exponent2, rp.Q.Length); rp.InverseQ = ConvertRSAParametersField(privKey.Coefficient, rp.Q.Length); return rp;&#125;private static byte[] ConvertRSAParametersField(BigInteger n, int size)&#123; byte[] bs = n.ToByteArrayUnsigned(); if (bs.Length == size) return bs; if (bs.Length &gt; size) throw new ArgumentException("Specified size too small", "size"); byte[] padded = new byte[size]; Array.Copy(bs, 0, padded, size - bs.Length, bs.Length); return padded;&#125; 案外案 - 套件版本但是但是但是 剛剛的解決方式只在 1.8.0 之後才有效, 1.7.x 以前的版本即使這樣使用還是會出錯. 這部分從上面有出現過一個 JIRA 的列表就可以看到這個問題是 1.8.0 才修復的, 但是 GitHub 的時候已經是 1.8.0 版了, 所以如果真的想比對舊版的原始碼的話, 就要去官網考古了. 結論其實如果直接讀憑證檔, 就不會有這個問題, 但是專案特性的關係, 這個金鑰會常常新增或更新, 為了不要每次增加或修改都要重新佈署, 只能花時間下去找原因跟解法了. 當時遇到這個問題的時候真的是很難過, 因為錯誤訊息超級少, 想找 google 都不知道關鍵字怎麼下, 還好弄了兩三天之後意外發現資料長度不對才有突破口, 這個專案中加解密的部分是存在好幾年的共用方法, 一直沒人遇到過這個情境, 既然被我踩到了也算是得到一個難得的經驗吧. 另外, 既然套件有封裝好這麼方便的方法, 之後有需要寫類似的方法時, 就不用再用以前流傳的那種方式了, 直接用解法中的做法就好, 這也是在網路上搜尋解決方案的時候要注意的, 多找幾種解決方案比較過再決定, 會更有機會找到比較適合的解決方案. 參考RSA Key Formats - Key File EncodingC#和JAVA的RSA密钥、公钥转换JIRA of Bouncy Castle]]></content>
      <categories>
        <category>C#</category>
        <category>Packages</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SymmetricAlgorithm 中 Key 和 KeySize 的依賴造成的少見問題]]></title>
    <url>%2Fcontent%2F20181230-interaction-between-key-and-keysize-in-symmetric-algorithm.html</url>
    <content type="text"><![CDATA[之前在寫 AES 加解密用的工具方法的時候, 意外發現某個特殊的情境, 會導致解密時因為沒有 Key 而拋出例外 (但 Key 確實有設定). 問題解析首先要來看一下示意的程式碼 12345678910// Main logicvar aes = new AesCryptoServiceProvider()&#123; Mode = CipherMode.ECB, Key = GenerateKey(128), KeySize = 128,&#125;string ciphertext = "jYCA05v0hL52/wT5WEJitQ==";string plaintext = aes.Decrypt(ciphertext); 12345678910111213141516// extension method for decryptpublic static string Decrypt(this SymmetricAlgorithm symmetric, string ciphertext)&#123; string plaintext = string.Empty; MemoryStream ms = new MemoryStream(); using (CryptoStream cs = new CryptoStream(ms, symmetric.CreateDecryptor(), CryptoStreamMode.Write)) &#123; var ciphertextBytes = Convert.FromBase64String(ciphertext); cs.Write(ciphertextBytes, 0, ciphertextBytes.Length); cs.FlushFinalBlock(); plaintext = Encoding.UTF8.GetString(ms.ToArray()); &#125; return plaintext;&#125; 接著來分析一下錯誤內容錯誤訊息: System.Security.Cryptography.CryptographicException: ‘Decrypting a value requires that a key be set on the algorithm object.’堆疊追蹤最後一行:at System.Security.Cryptography.AesCryptoServiceProvider.CreateDecryptor() 這看起來像是 Key 不存在, 但我們確實有指定 Key, 而用中斷點進去 symmetric.CreateDecryptor() 這一行的 symmetric 中卻發現 Key 的值已經不是一開始指定的值了. 問題點說明總之是耗了一點時間在排除問題, 最後發現是 KeySize = 128 這一行導致的, 因為設定 KeySize 這件事本身會使得 Key 被釋放掉. 這個現象要看官方的原始碼才能知道, 從 AesCryptoServiceProvider.cs 中可以看到 KeySize 的 setter 會將一開始設定的 Key 釋放掉, 導致 AesCryptoServiceProvider.CreateDecryptor() 執行時發現 m_key 沒有值而拋錯. 再更進一步去看父類別中 SymmetricAlgorithm 中的 KeySize 就可以發現, 其實不只 AES, 整個 SymmetricAlgorithm 的衍生類別都會在 KeySize 的 setter 中清掉現有的 Key (除非有誰特別將這段邏輯覆寫掉). 結論相關的程式碼想看可以去上面那些連結裡面深入了解, 總之 Key 和 KeySize 之間是有依賴的, 指定 Key 之前如果先指定 KeySize 沒有意義, 因為指定 Key 的時候, KeySize 也會被改變, 所以下面範例最後的 KeySize 是 256 而不是 128. 123456new AesCryptoServiceProvider()&#123; Mode = CipherMode.ECB, KeySize = 128, Key = GenerateKey(256),&#125; 同理, 如果指定了 Key, 就不可以在後面再指定 KeySize, 不然原本指定的 Key 會被清掉, 也就是本文遇到的問題. 需要指定 KeySize 的時機是, 加密時要指定 Key 的長度且不想自己產生 Key, 例如 12345new AesCryptoServiceProvider()&#123; Mode = CipherMode.ECB, KeySize = 128&#125; 相關問題, 網路上也有人討論, 附在下方參考中 其實這樣想起來也合理, Key 的值本身就可以算出 KeySize, 如果 KeySize 被指定時沒有清掉舊的 Key, 那就會可能發生 Key 的實際長度跟 KeySize 紀錄的長度不一樣的問題. 然後 Reference Source 和 Source Browser - .net core 真的是神物, 很多時候能靠這兩個東西了解細部的運作與問題發生的具體原因. 參考RijndaelManaged - What does setting KeySize property do?]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSD 的使用與應用]]></title>
    <url>%2Fcontent%2F20181225-use-xml-schema-definition.html</url>
    <content type="text"><![CDATA[XSD 的文章很早之前就寫過, 但是當時剛開始寫部落格, 所以雖然寫了三篇但內容沒有編排又很亂, 因此最近想說稍微重寫一下, 留下重點就好. 前言XSD 全名為 XML Schema Definition, 用來定義並驗證一個 XML 文件的格式, 除此之外他對我們在 Visual Studio 中編寫 XML 的時候能提供很大的幫助如下: 在 Visual Studio 中檢查 XML 的格式與內容是否符合定義. 在 Visual Studio 中使用自動提示 (Intellisence) 的功能來提示我們該怎麼寫. 移到自動提示的選項上還會顯示這個選項的註解(當然要先定義在 XSD 中), 滑鼠移過到上面也會跳出註解, 就像平常開發在呼叫 API 會有的自動提示和註解提示一樣. 因此當一個專案需要依賴大量的 XML 設定檔去設定或是設定檔本身比較複雜的時候, 定義一份完整的 XSD 能讓設定檔在編寫時能有更充足的提示, 不用一直花時間去翻設定說明, 也可以避免花時間去抓因手誤造成的bug. 本文會用之前為自訂 StyleCop 的規則需寫的 XML 所做的 XSD - SourceAnalyzer.xsd 來做範例. 建立一個新的 XSD 檔在 Visual Studio 中開啟一個專案, 並加入一個 XML Schema 檔案, 預設內容如下 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;xs:schema id="XMLSchema1" targetNamespace="http://tempuri.org/XMLSchema1.xsd" elementFormDefault="qualified" xmlns="http://tempuri.org/XMLSchema1.xsd" xmlns:mstns="http://tempuri.org/XMLSchema1.xsd" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;&lt;/xs:schema&gt; 其中的幾個屬性說明如下: targetNamespace: 目前文件命名空間. elementFormDefault: 選填, qualified 或 unqualified, 預設是unqualified, 建議用 qualified. xmlns / xmlns:mstns / xmlns:xs: 各種引用的 XSD 與命名空間, 其中 http://www.w3.org/2001/XMLSchema 就是用來定義xsd的xsd schema, 這也是為什麼在 visual studio 中編寫 xsd 時能有自動提示與驗證. 雖然預設的命名空間看起來是一個 URL, 但實際上命名空間只是用來做識別用的, 並非必要是 URL, 用 URL 的好處是可以提示使用者連上該網站得到更詳細的說明, 如下面範例. URL 應該是放專案的 GitHub Pages 連結比較好, 不過這個專案我沒有建 GitHub Pages 所以就直接放 GitHub 專案的連結了. 1234567&lt;xs:schema id=&quot;SourceAnalyzer&quot; targetNamespace=&quot;https://github.com/ronsun/ExtendedStyleCopRules&quot; elementFormDefault=&quot;qualified&quot; xmlns:this=&quot;https://github.com/ronsun/ExtendedStyleCopRules&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;/xs:schema&gt; 套用到 XML 上如何套用XSD 寫好後, 在 Visual Studio 中點選 XML &gt; Schemas 可以看到這個 XSD 已經被自動套用了, 接著建立一個新的 XML 檔並指定 xmlns 為剛剛建立的 XSD 的 targetNamespace 就可以套用到該 XML 檔上了. 123456789101112&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;SourceAnalyzer Name="Extend Naming Rules" xmlns="https://github.com/ronsun/ExtendedStyleCopRules"&gt; &lt;Description&gt; Extended naming rules. &lt;/Description&gt; &lt;Rules&gt; &lt;Rule Name="PrivateFieldNamesMustStartWithUnderscore" CheckId="EA1301"&gt; &lt;Context&gt;Private filed name must start with Underscore&lt;/Context&gt; &lt;Description&gt;Validates that names of private field must start with an underscore.&lt;/Description&gt; &lt;/Rule&gt; &lt;/Rules&gt;&lt;/SourceAnalyzer&gt; 自動提示 (Intellisence) 與檢查套用上之後就可以有自動提示與檢查功能. 不合規則時會有警示不合規則時, 右側卷軸會有一個淡藍色小點, 輸入的文字本身下面也會有一條淡藍色毛毛蟲, 滑鼠移過去可以看到詳細的警告描述, 且在 Error List 地方也會有警告, 非常方便. 自動提示功能選到提示的選項時, 會彈出預先在 XSD 中寫好的註解. 滑鼠移過文字時, 會彈出預先在 XSD 中寫好的註解. 在程式碼中套用檢查規則雖然 Visual Studio 會顯示警告, 但總有些時候有人會自動忽略警告, 無法提早發現錯誤, 這時候還可以在程式中檢查, 在應用程式啟動時, 直接呼叫驗證方法, 如果有違反就直接拋例外, 做為最後一道防線. 但其實我是覺得這一段程式碼沒必要, 應該是要參考 Warning 的資訊, 並盡可能不要讓 Warning 存在而不是忽略它才是比較嚴謹的做法. 大致的程式碼如下, 邏輯上就是載入 XSD 與相關的 XML, 接著透過 XDocument.Validate(...) 方法來驗證. 1234567891011121314151617181920212223public static void CheckXML()&#123; var currentAssembly = Assembly.GetExecutingAssembly(); XmlSchemaSet schemas = new XmlSchemaSet(); Stream xsdStream = currentAssembly.GetManifestResourceStream("ronsun.github.io.lab.SourceAnalyzer.xsd"); using (var reader = XmlReader.Create(xsdStream)) &#123; schemas.Add("https://github.com/ronsun/ExtendedStyleCopRules", reader); &#125; using (Stream xmlStream = currentAssembly.GetManifestResourceStream("ronsun.github.io.lab.ExtendedNamingRules.xml")) &#123; XDocument.Load(xmlStream).Validate(schemas, (sender, e) =&gt; &#123; // Actions for validate results if (e.Severity == XmlSeverityType.Error) &#123; throw new Exception(e.Message); &#125; &#125;); &#125;&#125; 學習資源XSD 相關的學習資源如下:tutorials pointw3schools (en)w3schools (zh-cn) 結論其實 XSD 不算很常用的功能, 有些大型專案需要的 XML 也不一定有 XSD, 在寫設定檔的時候就只能依賴文件跟記憶力, 但如果時間允許, 我還是贊成補上 XSD 文件的, 一方面可以讓後面的人上手比較容易, 另一方面 XSD 本身也扮演著文件的角色了, 就比較不需要另外去維護文件來說明 XML 應該怎麼寫. 不過, XSD 本身做為文件可讀性不好, 之前我也 fork 出一個開源專案 xs3p 做了一些修改, 可以將 XSD 傳換成 html 文件, 細節也曾經寫過一篇文章 利用xs3p將xsd轉換成文件 記錄. 參考How to: Validate Using XSD (LINQ to XML) (C#)]]></content>
      <categories>
        <category>XML</category>
        <category>XSD</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vsual Studio 中的工作清單(Task List)]]></title>
    <url>%2Fcontent%2F20181213-use-task-list-in-visual-studio.html</url>
    <content type="text"><![CDATA[在開發的過程, 常常有一些需要改進但現階段沒時間做的部分, 我們在上面加上一個 // TODO: 的註解來標註, 甚至依照特性的不同會用不一樣的語彙(Token)來標註, 例如: // BadSmell: 等等, Visual Studio 已經有內建幾個常用語彙, 除了這些內建語彙外我們也可以自己新增團隊內部使用的語彙. 另一方面, 這些工作清單慢慢累積後就會變得不好管理, 這部分也可以通過 Visual Studio 提供的相關功能來協助我們管理. 語彙(Token)的種類Visual Studio 內建幾種語彙與建議使用方式如下 TODO: 未實作的功能. HACK: 為了解決緊急問題而寫的程式, 但不是個適當的做法, 例如寫死一些變數或參數的數值先應急, 但這個數值不應該是寫死的. UNDONE: 為了解決短期問題而移除或註解掉程式碼, 或是需要切換並觀察兩個不同的做法哪種比較好. UnresolvedMergeConflict: 某一小段程式碼單獨運作良好, 但放到整個專案中運作會有問題, 需要 debug 找出問題. UnresolvedMergeConflict 的情境看起來比較像單元測試都能過, 但是整個流程測下來有問題, 可能是跟依賴物件的互動不正確, 或是是依賴度太高, 導致很容易被流程或是依賴物件影響他的正確性. 雖然說教學是這樣建議, 不過團隊如果有其他共識的話其實就大家說好就好, 另外, 這些語彙是不分大小寫的, 所以 TODO 和 ToDo 是一樣的, 但還是跟著團隊習慣, 盡量一致比較好. 工作清單視窗 (Task List Explorer)我們可以點選 View &gt; Task List 來打開工作清單視窗, 工作清單視窗中可以有篩選器或是關鍵字搜尋可以用, 很方便, 不需要用全域搜尋之類的方式找關鍵字. 自定義語彙我們可以在 Tools &gt; Options 中的 Task List 頁籤中增加自定義的語彙, 例如我們要加入一個語彙叫做 BadSmell, 用來表示程式碼中的壞味道, 方便之後重構或整理. 可以在 Task List 中改語彙的優先權(Piority), 但無法改名, 想要改名只能加上新的再刪掉舊的. 結論這篇也沒什麼特別難的, 主要是對於內建語彙的使用時機跟目的沒找到太多說明, 剛好有一本書有提到, 就稍微記一下, 而且自己平常很少用這個功能容易忘, 就順便備忘一下, 然後再順便試試一下用螢幕錄影轉 GIF 檔來說明操作流程的效果. 參考Mastering Web Development with Microsoft Visual Studio 2005 (P.45-P.46)]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自訂 StyleCop 規則與測試方式]]></title>
    <url>%2Fcontent%2F20181208-custom-stylecop-rules-and-testing.html</url>
    <content type="text"><![CDATA[很多 .NET 開發人員對於 StyleCop 應該是不陌生, 它能有效地協助我們讓程式碼的風格保持一致, 預設的規則其實已經足夠了, 但有些團隊可能有自已的特殊編碼規範, 這些編碼規範甚至是跟預設的規則是衝突的, 這時候就需要自己寫規則來套用. 這篇主要是針對自訂規則可能會面臨的問題所記錄的, 尤其是要怎麼測試這些規則沒寫錯, 所以對於一些 google 就可以很容易找到的部分只會簡單帶過, 另外由於 StyleCop 也滿大的, 所以有些太細的設定或是內部運作這篇也不打算深入探索, 等之後有需要或是有興趣再根據各個主題或面向來專題探討. 安裝 StyleCop安裝 StyleCop 的方式隨便問一下 google 大師就有很多教學了, 可以從 NuGet 找到 StyleCop.Analyzers 裝在各自專案上也可以從 Tools &gt; Extensions and Updates 找到 StyleCop 裝到本機電腦上, 我會比較推薦從 Extensions and Updates 裡面裝, 因為只有需要裝一個 StyleCop 擴充元件就能夠套用到所有的專案上, 各專案只需要編輯各自的設定檔就可以了, 非常方便. 安裝後的目錄在 C:\Users\{username}\AppData\Local\Microsoft\VisualStudio\{version}\Extensions\{key} 中, 其中 username 是本機使用者登入的名稱, version 是 visual studio 的版本號, key 是隨機產生的, 如果安裝很多擴充元件的話要一個個點進去找一下才知道哪個是 StyleCop 的. 使用 StyleCop都是 visual studio 上面點一點就好的, 教學資源也極多, 基本的使用就不多說了. 編輯 StyleCop 設定檔編輯 StyleCop 設定檔的方式一般只要從 visual studio 上開啟圖形介面就可以編輯專案要用的設定了, 另外一種方式是使用 StyleCop 的安裝目錄 (如上一段所說的位置) 中的 StyleCop.SettingsEditor.exe 來編輯, 雙擊設定檔或是用命令提示字元下 StyleCop.SettingsEditor.exe Settings.StyleCop 指令就可以, 其中 Settings.StyleCop 是設定檔的路徑, 這個工具是用來編輯設定檔的, 所以不能建立一個新的設定檔, 要編輯的設定檔也必須是符合規定的格式, 不然讀取會錯誤. 比起在 visual studio 中開啟圖形介面編輯設定檔, 用工具編輯雖然看起來不實用, 但是在需要製作很多份不同設定檔的時候卻很適合 (例如要測試自訂規則的驗證結果時), 這部分後面會說. 如果覺得 StyleCop.SettingsEditor.exe 不能建立一個新的設定檔很不方便, 可以把原始碼 fork 出來, 自己改造成適用的小工具. 自訂規則自訂規則的部分步驟還不少, 而且很多情況下做錯也不會跳錯誤訊息, 所以花了不少時間在 try and error 上, 我在 GitHub 上面有放了一個簡單的自訂規則的專案 - ExtendedStyleCopRules, 這一段的說明會以這個專案的內容當作範例. 依賴組件有幾個需要依賴的組件 StyleCop StyleCop.CSharp 依賴的組件可以選擇從 NuGet 裝, 也可以直接依賴到前面從 Extensions and Updates 裝好的 StyleCop 的安裝目錄下, 這邊是建議直接從 NuGet 裝, 因為 StyleCop 擴充元件的安裝資料夾名稱是隨機的, 換台電腦就找不到引用了, 很難管理. 另外這邊要注意一下, 依賴的組件如果是從 NuGet 抓的, 必須跟從 Extensions and Updates 上安裝的 StyleCop 版號一致, 例如: 如果我從 Extensions 上安裝 StyleCop 6.0, 開發自訂規則時依賴的是從 NuGet 上面安裝的 StyleCop, 這樣編譯出來的組件無法讓 StyleCop 正確載入. 規則設定檔要讓 StyleCop 能夠將自定規則的相關設定放在設定頁面, 需要一個 xml 格式的設定檔, 並將這個檔案屬性設定為編譯成 Embedded Resource, 這邊以 ExtendedNamingRules.xml 以及一張設定截圖為例. 123456789101112&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;SourceAnalyzer Name="Extend Naming Rules" xmlns="https://github.com/ronsun/ExtendedStyleCopRules"&gt; &lt;Description&gt; Extended naming rules. &lt;/Description&gt; &lt;Rules&gt; &lt;Rule Name="PrivateFieldNamesMustStartWithUnderscore" CheckId="EA1301"&gt; &lt;Context&gt;Private filed name must start with Underscore&lt;/Context&gt; &lt;Description&gt;Validates that names of private field must start with an underscore.&lt;/Description&gt; &lt;/Rule&gt; &lt;/Rules&gt;&lt;/SourceAnalyzer&gt; xmlns=&quot;....&quot; : 非必要, 只是沒有自動提示 (IntelliSense) 要寫這些 XML 太難過了, 所以自己刻了一個 SourceAnalyzer.xsd 來引用. Name=&quot;Extend Naming Rules&quot; : 這個 SourceAnalyzer 的名字, 會顯示在圖中 A 點. &lt;Description&gt;Extended naming rules.&lt;/Description&gt; : 這個 SourceAnalyzer 的描述, 點擊圖中 A 點時會顯示在圖中 C 點的位置. Name=&quot;PrivateFieldNamesMustStartWithUnderscore&quot; : 規則名字, 顯示在圖中 B 點, 必須是大寫字母開頭. CheckId=&quot;EA1301&quot; : 規則代號, 圖中 B 點, 也是違反規則時顯示在結果視窗中的代號, 必須是兩個大寫字母加四個數字. &lt;Context&gt;.....&lt;/Context&gt; : 提示訊息, 違反規則時顯示在結果視窗中的訊息之一. &lt;Description&gt;Validates that names...&lt;/Description&gt; : 規則描述, 點擊圖中 B 點時會顯示在圖中 C 點的位置. 其實這個 XML 可以很複雜, 這個範例只是最簡單的情境, StyleCop 的官方文件區也有一些簡易說明, 不過如果要完整的內容的話, 可能需要去整合 StyleCop 所有規則的設定檔, 或是直接爬程式碼分析 XML 的完整結構了. 程式碼先上程式碼再來慢慢說明.12345678910111213141516171819202122232425262728293031[SourceAnalyzer(typeof(CsParser))]public class ExtendedNamingRules : SourceAnalyzer&#123; public override void AnalyzeDocument(CodeDocument document) &#123; CsDocument csdocument = (CsDocument)document; if (csdocument.RootElement != null &amp;&amp; !csdocument.RootElement.Generated) &#123; csdocument.WalkDocument(new CodeWalkerElementVisitor&lt;object&gt;(VisitElement)); &#125; &#125; private bool VisitElement(CsElement element, CsElement parentElement, object context) &#123; // not target element if (element.Generated || element.ElementType != ElementType.Field || element.AccessModifier != AccessModifierType.Private) &#123; return true; &#125; if (!element.Declaration.Name.StartsWith("_")) &#123; AddViolation(element, Rules.PrivateFieldNamesMustStartWithUnderscore); &#125; return true; &#125;&#125; StyleCop 是把原始碼拆解成 Element, Statement 和 Expression, 然後走訪所有節點並根據委派方法決定驗證邏輯與行為. 這個類別需要使用 SourceAnalyzer 這個 Attribute 並繼承 SourceAnalyzer 後覆寫相關的分析方法 void AnalyzeDocument(CodeDocument document), 接著 WalkDocument(...) 這邊會開始走訪所有程式碼, 然後根據委派方法 VisitElement(...) 來判定違規與否以及添加違規訊息等, 另外 WalkDocument 方法還有其他多載能另外多帶兩個參數, 是用來驗證 Statement 和 Expression 的委派方法. 後來在 Element, Statement 和 Expression 外又多了一個 QueryClause, 看起來是針對 LINQ 語句做的, 例如 var q = from prod in db.Prodcut where prod.Category == &quot;shoes&quot;, WalkDocument 方法有一個多載提供委派方法 queryClauseCallback, 用途和其他委派應該差不多. 在刻這些規則時發現, 對於複雜一點的規則很難下手, 其中一個原因是不知道 StyleCop 是把程式碼拆解成什麼樣子, 驗證時需要用的拆解後的程式碼片段也不知道從哪裡得到, 這時候一個方法是去看 StyleCop 的原始碼, 或是偷懶一點, 利用測試在 debug 模式下看 CsDocument 的完整結構與相對應的值, 測試的方式後面會提到. 測試自訂規則這個測試的目的是測試自訂規則是不是能正確驗證程式碼, 比較像整合測試. 這邊的範例需要依賴一些組件, 從 NuGet 安裝即可 StyleCop (必要) NUnit (測試框架) FluentAssertions (Assert 用的套件) 下面是主要的程式碼片段與說明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[TestFixture()]public class ExtendedStyleCopRulesTests&#123; [TestCaseSource(nameof(TestCase_RuleTest))] public void RuleTest(string checkId, StyleCopViolations expectedValidationResult) &#123; // arrange Directory.CreateDirectory(Locations.ValidationResultDirectory); string validationResultPath = Path.Combine(Locations.ValidationResultDirectory, $"&#123;checkId&#125;.xml"); string ruleSettingPath = Path.Combine(Locations.TestDataDirectory, checkId, $"&#123;checkId&#125;.StyleCop"); string codePath = Path.Combine(Locations.TestDataDirectory, checkId, $"&#123;checkId&#125;.cs"); CodeProject project = new CodeProject( checkId.GetHashCode(), Locations.BaseDirectory, new Configuration(null), 0); StyleCopConsole console = new StyleCopConsole( ruleSettingPath, false, validationResultPath, Locations.AddInDirectory, false, Locations.BaseDirectory); console.Core.Environment.AddSourceCode(project, codePath, null); // act console.Start(new CodeProject[] &#123; project &#125;, true); StyleCopViolations actualValidationResult; using (Stream s = new FileStream(validationResultPath, FileMode.Open)) &#123; var serializer = new XmlSerializer(typeof(StyleCopViolations)); actualValidationResult = (StyleCopViolations)serializer.Deserialize(s); &#125; // assert bool testDataExist = File.Exists(ruleSettingPath) &amp;&amp; File.Exists(codePath); testDataExist.Should().BeTrue(); actualValidationResult.ViolationItems.Should().BeEquivalentTo(expectedValidationResult.ViolationItems); &#125; private static List&lt;object[]&gt; TestCase_RuleTest() &#123; var expectedValidationResult = new StyleCopViolations() &#123; &#125;; return new List&lt;object[]&gt;() &#123; EA1301TestResource() &#125;; &#125; private static object[] EA1301TestResource() &#123; string checkId = "EA1301"; var expectedValidationResult = new StyleCopViolations() &#123; ViolationItems = new List&lt;StyleCopViolations.Violation&gt;() &#123; new StyleCopViolations.Violation() &#123; LineNumber = "7", RuleNamespace = "ExtendedStyleCopRules.NamingRules.ExtendedNamingRules", Rule = Rules.PrivateFieldNamesMustStartWithUnderscore.ToString(), RuleId = checkId &#125; &#125; &#125;; return new object[] &#123; checkId, expectedValidationResult &#125;; &#125;&#125; 測試的部分是參考 StyleCope 原始碼中的測試專案, 其實主要功能 StyleCop 都有提供, 也就是上面程式碼中的 CodeProject 和 StyleCopConsole, 這一句 console.Start(new CodeProject[] { project }, true) 執行後會根據指定的程式碼檔案 (codePath) 以及套用的 StyleCop 規則 (ruleSettingPath) 健行驗證, 並將檢查結果輸出成 XML 存檔到指定位置 (validationResultPath), 接著我們再讀取檢查結果驗證是否符合預期. 完整測試程式碼可以看 GitHub 其實 StyleCop 的測試專案是連預期驗證結果都寫成 XML 了, 比這個複雜多了, 不過以自己的小專案來說, 還是先簡單就好, 等規則多到像 StyleCop 那樣再說 (應該不可能). 套用規則編譯好, 把 dll 放到 StyleCop 擴充元件的安裝目錄下, 然後重開 visual studio 就可以了. 結論StyleCop 教學資源多集中在說明怎麼使用, 自訂規則的文章也不少, 但有提到測試的很少了, 所以乾脆直接跳進去看 StyleCop 內建的規則和測試是怎麼寫的, 順便整理了一下相關的 XML 規格刻個 XSD 來輔助使用, 而且測試的部分能協助我們在偵錯模式下去看被 StyleCop 拆解後的程式碼, 也更容易知道怎麼判斷程式碼是否違規. 以往沒看套件原始碼的習慣, 雖然剛開始看覺得很有障礙, 不過當作觀摩練習也是不錯. 參考Instant Stylecop Code Analysis How-to (書)StyleCopHow to Implement a Custom StyleCop RuleC# Code Reviews using StyleCop – Detailed ArticlePart I: Creating Custom Rules for Microsoft Source AnalyzerPart II: Creating Custom Rules for Microsoft Source AnalyzerPart III: Creating Custom Rules for Microsoft Source Analyzer 有些資料比較久了, 小細節和現在不一定相同, 不過說明很詳細, 對於了解 StyleCop 是很有幫助的]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XmlSerializer 的序列化/反序列化 與 BOM]]></title>
    <url>%2Fcontent%2F20181203-xml-serialize-deserialize.html</url>
    <content type="text"><![CDATA[XmlSerializer 提供許多序列化和反序列化相關的多載, 都有各自的優缺點, 例如有些方式在某些編碼下會因為 BOM(byte order mark) 出現在開頭而導致反序列化出現 Exception 或是序列化出含有 BOM 的字串導致接收端無法成功解析, 而各種方式的彈性與易用性都略有不同, 所以稍微記錄幾種序列化和反序列化的方式與特徵. 序列化XmlWriter這種做法最有彈性, 可以靠著改變 XmlWriterSettings 以及 XmlSerializerNamespaces 的設定去控制序列化出來的 XML 字串的格式與內容, 但要特別注意的是 XmlWriterSettings 預設是有 BOM 的 UTF-8 編碼, 如果接收資料的一方無法處理這種格式的話, 需要特別將 XmlWriterSettings.Encoding 設成無 BOM 的編碼格式, 例如: var ws = new XmlWriterSettings() { Encoding = new UTF8Encoding() }, 比較適合用在需要跟許多不同外部系統介接的模組上 123456789101112131415161718public string Serialize(Encoding encoding)&#123; var serializer = new XmlSerializer(typeof(MyModel)); var ws = new XmlWriterSettings() &#123; Encoding = encoding &#125;; var ns = new XmlSerializerNamespaces(new XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;); using (var ms = new MemoryStream()) using (var xw = XmlWriter.Create(ms, ws)) &#123; serializer.Serialize(xw, new MyModel(), ns); return ws.Encoding.GetString(ms.ToArray()); &#125;&#125; StreamWriter這種做法彈性小了一點, 只能用 XmlSerializerNamespaces 來控制 namespace, 比較難透過設定參數來改變輸出格式和內容, 但本例還是可以透過改變參數 encoding 自己決定編碼格式, 且另外一個建構子多載 StreamWriter(Stream) 預設就是無 BOM 的 UTF-8, 比起使用 XmlWriter 能更直覺的避免序列化時產生 BOM. 12345678910111213public string Serialize(Encoding encoding)&#123; var serializer = new XmlSerializer(typeof(MyModel)); var ns = new XmlSerializerNamespaces(new XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;); using (var ms = new MemoryStream()) using (var sw = new StreamWriter(ms, encoding)) // 2nd arg default to utf-8 no BOM &#123; serializer.Serialize(sw, new MyModel(), ns); return encoding.GetString(ms.ToArray()); &#125;&#125; Stream這種做法彈性就更小了, 只能用 XmlSerializerNamespaces 來控制 namespace, 除了比較難透過設定參數來改變輸出格式和內容外, 參數 ecoding 也只能是 UTF-8, 但另一方面, 程式碼比較簡短且序列化出來的 XML 字串不會有 BOM, 用在不需要跟外部系統介接的模組上非常適合. 123456789101112public string Serialize(Encoding encoding)&#123; var serializer = new XmlSerializer(typeof(MyModel)); var ns = new XmlSerializerNamespaces(new XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;); using (var ms = new MemoryStream()) &#123; serializer.Serialize(ms, new MyModel(), ns); return encoding.GetString(ms.ToArray()); &#125;&#125; StringWriter這種跟直接使用 Stream 的做法差不多都不容易改輸出格式和內容, 優點也一樣是簡短清晰且不用考慮 BOM 的問題, 而用 StringBuilder 比上面用 Stream 多了一個特性是連編碼格式都不用考慮, 同樣適合用在不需要跟外部系統介接的模組上. StringBuilder 預設的編碼格式是 UTF-16 12345678910111213public string Serialize()&#123; var serializer = new XmlSerializer(typeof(MyModel)); var ns = new XmlSerializerNamespaces(new XmlQualifiedName[] &#123; XmlQualifiedName.Empty &#125;); var sb = new StringBuilder(); using (var sw = new StringWriter(sb)) &#123; serializer.Serialize(sw, new MyModel(), ns); return sb.ToString(); &#125;&#125; 小結每種做法都有各自的優缺點, 需要在輸出格式上滿足各種情境的話, 用 XmlWriter 操作是最適合的, 如果編碼與輸出格式單一且幾乎不會改變的話, 用 Stream 或 StringWriter 處理會更好懂. 如果使用 XmlWriter 或是 SreamWriter 兩個範例操作的話要注意序列化出來的內容是否有 BOM, 尤其是需要跟外部系統介接時. 反序列化XmlReaderXmlReader 是提供最多參數的方式, XmlReader.Create(Stream, XmlReaderSettings) 和 XmlReader.Create(TextReader, XmlReaderSettings) 的第二個參數有很多選項可以調整, 從方法定義可以看得出來 XmlReader.Create(…) 有很多多載可以用, 如果是從 Stream 讀取資料的話, 即使 XML 字串有 BOM 也不會出錯, 但如果從 StringReader 讀取, 在 XML 字串有 BOM 的情境下會拋出 Exception. 12345678910111213141516171819202122232425262728293031323334public T DeSerialize_FromStream&lt;T&gt;(string xml, Encoding encoding)&#123; var serializer = new XmlSerializer(typeof(T)); var xmlBytes = encoding.GetBytes(xml); using (var ms = new MemoryStream(xmlBytes)) using (var xr = XmlReader.Create(ms)) &#123; xr.Read(); var result = serializer.Deserialize(xr); if (result != null) &#123; return (T)result; &#125; return default(T); &#125;&#125;public T DeSerialize_FromStringReader&lt;T&gt;(string xml)&#123; var serializer = new XmlSerializer(typeof(T)); using (var sr = new StringReader(xml)) using (var xr = XmlReader.Create(sr)) &#123; xr.Read(); var result = serializer.Deserialize(xr); if (result != null) &#123; return (T)result; &#125; return default(T); &#125;&#125; StreamReader / Stream這兩種方式差不多, 即使 XML 字串有 BOM 也都不會出錯, 只差在 StreamReader 建構子的參數比較多, 如果對編碼格式沒特別的需求的話, 直接操作 Stream 比較單純. 1234567891011121314151617181920212223242526272829303132public T DeSerialize_StreamReader&lt;T&gt;(string xml, Encoding encoding)&#123; var serializer = new XmlSerializer(typeof(T)); var xmlBytes = encoding.GetBytes(xml); using (var ms = new MemoryStream(xmlBytes)) using (var tr = new StreamReader(ms, encoding)) &#123; var result = serializer.Deserialize(tr); if (result != null) &#123; return (T)result; &#125; return default(T); &#125;&#125;public T DeSerialize_Stream&lt;T&gt;(string xml, Encoding encoding)&#123; var serializer = new XmlSerializer(typeof(T)); var xmlBytes = encoding.GetBytes(xml); using (var ms = new MemoryStream(xmlBytes)) &#123; var result = serializer.Deserialize(ms); if (result != null) &#123; return (T)result; &#125; return default(T); &#125;&#125; StringReader這種方法在 XML 字串有 DOM 的時候會出 Exception, 優點是不用考慮編碼格式, 只需要知道 XML 字串就可以了. 1234567891011121314public T DeSerialize&lt;T&gt;(string xml)&#123; var serializer = new XmlSerializer(typeof(T)); using (var sr = new StringReader(xml)) &#123; var result = serializer.Deserialize(sr); if (result != null) &#123; return (T)result; &#125; return default(T); &#125;&#125; 小結反序列化大部分的做法都很簡單, 以目前實驗看來, 把 XML 字串先轉成 Stream 再處理都可以相容有 BOM 的資料來源, 需要考量的點似乎也比序列化時少很多. 結論這篇只是要實驗各種序列化與反序列化的方式遇到 BOM 時候的結果, 所以沒有特別實驗各種不同方式在其他複雜的 XML 資料下的轉換結果, 如果之後有遇到其他問題的話再回來補. 範例程式碼可參考 Demo]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WebAPI 安全的取得 Request Body]]></title>
    <url>%2Fcontent%2F20181118-webapi-get-request-body-safety.html</url>
    <content type="text"><![CDATA[標題下的有點奇怪, 框架預設提供 Model Binding 來將請求內容(request body)綁定到參數中, 其實一般情境不需要手工去讀取它的. 但是之前遇到一個情境是需要在 ActionFilterAttribute 中取得請求內容並紀錄到日誌 (log) 中, 這時候問題就來了. 先來段程式碼, 看起來很正常, 就是在 ActionFilterAttribute 中把請求內容抓出來, 然後記錄到日誌中收工, 但接下來有個問題… 1234567891011121314public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; using (Stream s = actionContext.Request.Content.ReadAsStreamAsync().Result) using (StreamReader sr = new StreamReader(s)) &#123; s.Seek(0, SeekOrigin.Begin); var body = sr.ReadToEnd(); // Logging here... logger.Info(body); &#125; &#125;&#125; 上面說到紀錄完日誌收工, 這時候我們回到 WebAPI 中的 Action 來看看下面這段程式碼, 可以看到 Action 中又再次讀取一次請求內容, 但是這次卻會拋出例外(exception), 這就是有問題的地方了. 123456789101112131415public class ValuesController : ApiController&#123; [HttpPost] [DemoActionFilter] public void Post() &#123; string data = string.Empty; using (Stream s = Request.Content.ReadAsStreamAsync().Result) using (StreamReader sr = new StreamReader(s)) &#123; s.Seek(0, SeekOrigin.Begin); data = sr.ReadToEnd(); &#125; &#125;&#125; Stream.Seek(0, SeekOrigin.Begin) 是用來重置 stream 的讀取位置的, 也可以這樣寫 Stream.Position = 0 不用 using簡單暴力的做法就是把 DemoActionFilterAttribute 中讀取時的 using拿掉, 這樣資源就不會被強制回收, 如下: 123456789101112public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; Stream s = actionContext.Request.Content.ReadAsStreamAsync().Result; StreamReader sr = new StreamReader(s); s.Seek(0, SeekOrigin.Begin); string body = sr.ReadToEnd(); // Logging here... logger.Info(body); &#125;&#125; 或是初始化 StreamReader 的時候要用參數最多的那個多載, 並把最後一個參數 leaveOpen 設成 true 讓 stream 本身在 StreamReader 釋放後不會被關閉, 但這樣還要特別去注意其他參數預設要填什麼有點麻煩, 而且也不確定 ReadAsStreamAsync() 這個方法使會不會建立一個新的 Stream 以及是否必須手動釋放 , 例如下面的範例 1234567891011121314public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; Stream s = actionContext.Request.Content.ReadAsStreamAsync().Result; using (var sr = new StreamReader(s, Encoding.UTF8, true, 1024, true)) &#123; s.Seek(0, SeekOrigin.Begin); string body = sr.ReadToEnd(); // Logging here... logger.Info(body); &#125; &#125;&#125; 這兩種做法雖然是能讓程式碼能成功運作, 但是既然這些類別有實作 IDisposable 來允許使用 using 來提早回收資源, 在不完全確定這些資源能被 GC 即時回收的情況下, 冒然把 using 拆掉似乎不是首選. 改用 ReadAsStringAsync這是最簡短的作法, 且這樣做在 Action 中要再次讀取 Sream 時並不會出錯, 但是卻有個限制 - Action 不能有參數.123456789public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; string body = actionContext.Request.Content.ReadAsStringAsync().Result; // Logging here... logger.Info(body); &#125;&#125; 從這張圖可以看出, 如果 Action 有參數的話 (像是這樣 public void Post(MyModel model) ), 會先做 Model Binding (在圖中標註 C 點的地方) 然後才是做 ActionFilter, 所以當進到 ActionFilterAttribute 裡面時, 請求已經被讀取過了, 這時候讀出來的結果會是空字串. 因此, 這種做法必須限制 Action 不能有參數, 但是只為了 ActionFilterAttribute 需要而限制的 Action 的實作方式是不合理的, 會造成未來擴展或維護上的困擾. 複製 Stream既然要讀取內容又不能把資源釋放掉, 不如直接複製一份出來讀取, 再釋放掉複製版的資源就好了. 12345678910111213141516171819public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; using (Stream s = new MemoryStream()) &#123; actionContext.Request.Content.CopyToAsync(s); // need call it twice if model binding works actionContext.Request.Content.CopyToAsync(s); using (StreamReader sr = new StreamReader(s)) &#123; s.Seek(0, SeekOrigin.Begin); string body = sr.ReadToEnd(); // Logging here... logger.Info(body); &#125; &#125; &#125;&#125; 之前在某一本書上看到複製 stream 不好, 但當時沒有仔細看, 所以也不清楚為什麼不好, 不過倒是有在網路上找到一篇關於複製 stream 的效能問題, 基本上是因為短時間大量資料湧入再加上資源來不及釋放, 導致記憶體用量飆高, 這邊的作法跟他提到的解法有點不同, 但原則都是盡早釋放資源. 另外還有一個問題是, 這個做法如果跟 Model Binding 一起使用, actionContext.Request.Content.CopyToAsync(s) 要執行兩次才能才能正確的複製 stream, 推測跟 Stream.Position 有關但不知道怎麼證實. 內建的 Model Binding或是換個方向, Action 必須帶參數且透過 Model Binding 綁定, 而 ActionFilterAttribute 中維持不動, Action 直接操作綁定好的物件就好, 但這樣 ActionFilterAttribute 中還是把資源釋放掉了, 就設計的角度來看我們不希望在一個通用方法 (DemoActionFilterAttribute) 中對全域的資源做一次性的使用, 因為無法預期這個資源是否會再次被使用. (推薦) 直接讀內建的屬性這個思考方向是, 那有沒有可能內建的 request 相關物件就有提供記錄著請求內容的 Stream 型別的屬性讓我們能直接讀取呢? 而內建的物件中的屬性, 我們可以合理預期不用手動去釋放相關的資源. 123456789101112public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; var context = (HttpContextBase)actionContext.Request.Properties["MS_HttpContext"]; var bytes = new byte[context.Request.InputStream.Length]; context.Request.InputStream.Read(bytes, 0, bytes.Length); string body = Encoding.UTF8.GetString(bytes); // Logging here... logger.Info(body); &#125;&#125; 這個做法看起來是最合理的, 一方面可以在 ActionFilter 中讀取請求內容, 不用手動釋放資源所以不會破壞它, 這樣各個 Action 中如果有需要也可以再次讀取. 另外, 讀取 InputStream 的方式也可以搭配 StreamReader, 要特別帶入 leaveOpen 參數避免把 InputStream 關閉了, 比較麻煩, 例如下面的範例 1234567891011121314public class DemoActionFilterAttribute : ActionFilterAttribute&#123; public override void OnActionExecuting(HttpActionContext actionContext) &#123; var context = (HttpContextBase)actionContext.Request.Properties["MS_HttpContext"]; context.Request.InputStream.Seek(0, SeekOrigin.Begin); using (var sr = new StreamReader(context.Request.InputStream, Encoding.UTF8, true, 1024, true)) &#123; string body = sr.ReadToEnd(); // Logging here... logger.Info(body); &#125; &#125;&#125; 結論這是工作上遇到的問題, 研究一番後解是解了, 不過畢竟沒有完全了解底層的運作, 最後的解法是不是好的方法還很難說, 可能之後有空或是又踩到什麼相關問題再來仔細深究了.另外前面幾種解法雖然看起來都有些缺陷, 但也不全然是不好, 只是說在這個情境下不太適合而已. 重置讀取位置這個行為在要讀取的 stream 已經被讀過時要做, 但前面的範例中, 某些情境下要讀取的 stream 不一定已經被讀過, 這個就看各人是習慣不論如何只要讀 stream 都重置讀取位置, 還是只在必要重置的時候重置了. 參考Web Api Request Content is empty in action filterSteam.CopyTo - Performance problemsLeave StreamReader without closing Stream]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XmlWriterSettings.Encoding 設定無效]]></title>
    <url>%2Fcontent%2F20181101-xmlwritersettings-encoding-not-working.html</url>
    <content type="text"><![CDATA[最近在寫一個比較方便使用的工具方法來做 XML 的序列化的時候, 發生了一個神奇的問題, XmlWriterSettings.Encoding 預設應該是 UTF-8, 但是轉出來的 XML 卻是 UTF-16, 這就奇了怪了… XmlWriterSettings.Encoding 設定無效先來看下面這段 Demo123456789101112private static string DemoForFailure()&#123; var xmlWriterSettings = new XmlWriterSettings(); var sb = new StringBuilder(); using (var xmlWriter = XmlWriter.Create(sb, xmlWriterSettings)) &#123; new XmlSerializer(typeof(string)).Serialize(xmlWriter, string.Empty); return sb.ToString(); &#125;&#125; 程式碼就是很簡單的把一個空字串拿去序列化, 但是輸出的字串卻是 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot;?&gt;&lt;string /&gt;, 即使特別再手動設定 Encoding 也是一樣, 如: var xmlWriterSettings = new XmlWriterSettings() { Encoding = Encoding.UTF8 }; 稍微推敲一下程式碼, 猜測應該是 StringBulider 的問題, 可能是因為 StringBulider 操作字串有自己的 Encoding, 所以就往這方面去找. 原因因為今天比較懶不想自己往底部去鑽, 所以先問問 google 大神先, 也是運氣好還真的有找到一篇分析文, 大意上就是 StringBuilder 設計上是直接操作字元而不是 bytes, 而字串在 .NET 裡面都是 UTF-16 編碼的. 解法所以這邊改用存取 Stream 的方式來操作, 如下12345678910111213private static string DemoForSuccess()&#123; var xmlWriterSettings = new XmlWriterSettings() &#123; Encoding = Encoding.UTF8 &#125;; using (var ms = new MemoryStream()) using (var sr = new StreamReader(ms)) using (var xmlWriter = XmlWriter.Create(ms, xmlWriterSettings)) &#123; new XmlSerializer(typeof(string)).Serialize(xmlWriter, string.Empty); ms.Position = 0; return sr.ReadToEnd(); &#125;&#125; 結論也沒什麼特別的技巧好結論, 特別寫出來只是怕之後忘記, 再遇到還要再踩一次. 參考XmlWriterSettings Encoding Being Ignored?]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WebApi 2 中的 FilterAttribute 介紹與應用]]></title>
    <url>%2Fcontent%2F20180923-filters-of-webapi2.html</url>
    <content type="text"><![CDATA[ASP.NET WebApi 2 提供了三個好用的 FilterAttribute 讓開發者可以擴充後將這些 FilterAttribute 套用在 Controller / Action 上面, 也可以在 WebApiConfig.cs 或 Global.asax 裡面註冊 , 並在一個 API request 生命週期中的特定時間被執行.這樣做的好處是可以將跟 API 主業務邏輯無關, 卻又是大部分 API 都要做的事收斂起來, 只需要將 Attribute 套用在正確的地方就能一體適用, 開發者就能更專注在 API 的主要商務邏輯層面. 在了解 FilterAttribute 的運用之前, 必須先知道 Attribute 是什麼以及如何使用 Attribute. 三種 FilterAttribute 介紹ASP.NET WebApi 2 提供了三個好用的 FilterAttribute, 分別是 AuthorizationFilterAttribute, ActionFilterAttribute 與 ExceptionFilterAttribute , 要注意的是命名空間都是 System.Web.Http.Filters, ASP.NET MVC 也有提供同名的 FilterAttribute, 但是命名空間不同, 內容也不盡相同. 這三個 FilterAttribute 提供的功能各異: AuthorizationFilterAttribute 提供的是驗證相關的流程, 能在進 Action 之前就先執行相關的驗證方法. ActionFilterAttribute 會分別在 Action 執行前與執行完畢後執行相關方法. ExceptionFilterAttribute 在例外(unhandled exception)發生後執行. 基本用法這三種 FilterAttribute 的使用方式都一樣, 這邊用 ExceptionFilterAttribute 來當作範例. 繼承對應的 FilterAttribute, 並覆寫父類別中的相關方法. 1234567891011121314public class DemoExceptionFilterAttribute : ExceptionFilterAttribute&#123; public override void OnException(HttpActionExecutedContext actionExecutedContext) &#123; // Call base method base.OnException(actionExecutedContext); // Do somthing, ex: logging exception // _logger.Info(actionExecutedContext.Exception); // Set response information actionExecutedContext.Response = new HttpResponseMessage(HttpStatusCode.InternalServerError); &#125;&#125; 套用 FilterAttribute. 套用到 Action 12345678public class DemoController : ApiController&#123; [DemoExceptionFilter] public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125; 套用到特定 ApiController 12345678[DemoExceptionFilter]public class DemoController : ApiController&#123; public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125; 更進一步, 可以將這些 FilterAttribute 套用在一個共用的 BaseApiController 上, 只要繼承 BaseApiController, 就能直接套用. 12345678910111213[DemoExceptionFilter]public class BaseApiController : ApiController&#123;&#125;public class DemoController : BaseApiController&#123; public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125; 套用到所有 ApiController - 從 ~/App_Start/WebApiConfig.cs 1234567891011121314151617public class DemoController : ApiController&#123; public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125;// ~/App_Start/WebApiConfig.cspublic static void Register(HttpConfiguration config)&#123; // ... config.Filters.Add(new DemoExceptionFilterAttribute()); // ...&#125; 套用到所有 ApiController - 從~/Global.asax 1234567891011121314151617public class DemoController : ApiController&#123; public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125;// ~/Global.asaxprotected void Application_Start()&#123; // ... GlobalConfiguration.Configuration.Filters.Add(new DemoExceptionFilterAttribute()); // ...&#125; 單獨套用只能套用在 ApiController 的衍生類別或 Action 上, 如果是套用在其他方法(例如: xxxService.Do(), 或 this.Do()), 即使那個方法有被 ApiController 的 Action 呼叫到也是無法讓 FilterAttribute 運作的. 重複套用同一個 FilterAttribute 不會壞, 但因為註冊了兩次, 所以也會執行兩次, 所以應該要特別注意套用方式避免重複套用. 排除特定 Action 或 Controller如果大部分 API 都需要套用一個 FilterAttribute, 但有少數不套用, 應該要怎麼實作排除機制呢? 實作標記為排除的 Attribute 123456789public class IgnoreFilterAttribute : Attribute&#123; public Type FilterType &#123; get; &#125; public IgnoreFilterAttribute(Type filterType) &#123; this.FilterType = filterType; &#125;&#125; 擴充 FilterAttribute 以支援排除功能 123456789101112131415161718192021222324252627282930313233public class DemoExceptionFilterAttribute : ExceptionFilterAttribute&#123; public override void OnException(HttpActionExecutedContext actionExecutedContext) &#123; Func&lt;IgnoreFilterAttribute, bool&gt; ignoreCheck = (r) =&gt; &#123; // ignored type is one of... // 1. DemoExceptionFilterAttribute // 2. Base types of DemoExceptionFilterAttribute return r.FilterType.IsAssignableFrom(typeof(DemoExceptionFilterAttribute)); &#125;; var ignoredActions = actionExecutedContext .ActionContext .ActionDescriptor .GetCustomAttributes&lt;IgnoreFilterAttribute&gt;() .Any(ignoreCheck); var ignoredControllers = actionExecutedContext .ActionContext .ControllerContext .ControllerDescriptor .GetCustomAttributes&lt;IgnoreFilterAttribute&gt;() .Any(ignoreCheck); if (ignoredActions || ignoredControllers) &#123; return; &#125; // ... &#125;&#125; 套用標記為排除的 Attribute 1234567891011// apply to Controller//[IgnoreFilter(typeof(DemoExceptionFilterAttribute))]public class DemoController : ApiController&#123; // apply to Action [IgnoreFilter(typeof(DemoExceptionFilterAttribute))] public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125; 執行順序根據 The ASP.NET Web API 2 HTTP Message Lifecycle in 43 Easy Steps 的說明加上 ASP.NET WEB API 2: HTTP MESSAGE LIFECYLE 流程圖的內容來看, AuthorizationFilterAttribute 會先執行, 然後才是 ActionFilterAttribute, 而例外發生時會執行ExceptionFilterAttribute, 至於同種類的多個 FilterAttribute 或是一個 FilterAttribute 中的不同方法執行的順序, 可以從下面的程式碼觀察出結果. 首先, 需要 AuthorizationFilterAttribute 和 ActionFilterAttribute 各兩組, 另外一組 ExceptionFilterAttribute, 接著把這些 FilterAttribute 放在 WebApi 專案預設的 Action 上, 且 ExceptionFilterAttribute 刻意插在中間, 而 Action 就簡單的拋出一個例外. 12345678910111213public class ValuesController : ApiController&#123; // GET api/values [MyAuth2] [MyAuth1] [MyAction1] [MyException1] [MyAction2] public IEnumerable&lt;string&gt; Get() &#123; throw new Exception(); &#125;&#125; 實作部分所有 FilterAttribute 並覆寫所有能覆寫的方法, 內容只是單純寫個簡單的歷程記錄到 RouteTracer.Routes 中, 但ExceptionFilterAttribute 需要另外負責回傳正確的狀態與 RouteTracer.Routes 內容, 才能順利觀察執行順序. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class MyAuth1 : AuthorizationFilterAttribute&#123; public override void OnAuthorization(HttpActionContext actionContext) &#123; RouteTracer.Routes.Add("MyAuth1.OnAuthorization"); base.OnAuthorization(actionContext); &#125; public override Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken) &#123; RouteTracer.Routes.Add("MyAuth1.OnAuthorizationAsync"); return base.OnAuthorizationAsync(actionContext, cancellationToken); &#125;&#125;public class MyAuth2 : AuthorizationFilterAttribute&#123; public override void OnAuthorization(HttpActionContext actionContext) &#123; RouteTracer.Routes.Add("MyAuth2.OnAuthorization"); base.OnAuthorization(actionContext); &#125; public override Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken) &#123; RouteTracer.Routes.Add("MyAuth2.OnAuthorizationAsync"); return base.OnAuthorizationAsync(actionContext, cancellationToken); &#125;&#125;public class MyAction1 : ActionFilterAttribute&#123; public override void OnActionExecuted(HttpActionExecutedContext actionExecutedContext) &#123; RouteTracer.Routes.Add("MyAction1.OnActionExecuted"); base.OnActionExecuted(actionExecutedContext); &#125; public override Task OnActionExecutedAsync(HttpActionExecutedContext actionExecutedContext, CancellationToken cancellationToken) &#123; RouteTracer.Routes.Add("MyAction1.OnActionExecutedAsync"); return base.OnActionExecutedAsync(actionExecutedContext, cancellationToken); &#125; public override void OnActionExecuting(HttpActionContext actionContext) &#123; RouteTracer.Routes.Add("MyAction1.OnActionExecuting"); base.OnActionExecuting(actionContext); &#125; public override Task OnActionExecutingAsync(HttpActionContext actionContext, CancellationToken cancellationToken) &#123; RouteTracer.Routes.Add("MyAction1.OnActionExecutingAsync"); return base.OnActionExecutingAsync(actionContext, cancellationToken); &#125;&#125;public class MyAction2 : ActionFilterAttribute&#123; public override void OnActionExecuted(HttpActionExecutedContext actionExecutedContext) &#123; RouteTracer.Routes.Add("MyAction2.OnActionExecuted"); base.OnActionExecuted(actionExecutedContext); &#125; public override Task OnActionExecutedAsync(HttpActionExecutedContext actionExecutedContext, CancellationToken cancellationToken) &#123; RouteTracer.Routes.Add("MyAction2.OnActionExecutedAsync"); return base.OnActionExecutedAsync(actionExecutedContext, cancellationToken); &#125; public override void OnActionExecuting(HttpActionContext actionContext) &#123; RouteTracer.Routes.Add("MyAction2.OnActionExecuting"); base.OnActionExecuting(actionContext); &#125; public override Task OnActionExecutingAsync(HttpActionContext actionContext, CancellationToken cancellationToken) &#123; RouteTracer.Routes.Add("MyAction2.OnActionExecutingAsync"); return base.OnActionExecutingAsync(actionContext, cancellationToken); &#125;&#125;public class MyException1 : ExceptionFilterAttribute&#123; public override void OnException(HttpActionExecutedContext actionExecutedContext) &#123; RouteTracer.Routes.Add("MyException1.OnException"); base.OnException(actionExecutedContext); actionExecutedContext.Response = new HttpResponseMessage(HttpStatusCode.OK); actionExecutedContext.Response.Content = new ObjectContent&lt;List&lt;string&gt;&gt;(RouteTracer.Routes, new XmlMediaTypeFormatter()); &#125;&#125; 實際運作後頁面顯示結果如下, 可以看出各種 FilterAttribute 以及其中的方法的執行順序. 123456789101112131415&lt;ArrayOfstring xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays"&gt; &lt;string&gt;MyAuth2.OnAuthorizationAsync&lt;/string&gt; &lt;string&gt;MyAuth2.OnAuthorization&lt;/string&gt; &lt;string&gt;MyAuth1.OnAuthorizationAsync&lt;/string&gt; &lt;string&gt;MyAuth1.OnAuthorization&lt;/string&gt; &lt;string&gt;MyAction1.OnActionExecutingAsync&lt;/string&gt; &lt;string&gt;MyAction1.OnActionExecuting&lt;/string&gt; &lt;string&gt;MyAction2.OnActionExecutingAsync&lt;/string&gt; &lt;string&gt;MyAction2.OnActionExecuting&lt;/string&gt; &lt;string&gt;MyAction2.OnActionExecutedAsync&lt;/string&gt; &lt;string&gt;MyAction2.OnActionExecuted&lt;/string&gt; &lt;string&gt;MyAction1.OnActionExecutedAsync&lt;/string&gt; &lt;string&gt;MyAction1.OnActionExecuted&lt;/string&gt; &lt;string&gt;MyException1.OnException&lt;/string&gt;&lt;/ArrayOfstring&gt; 就執行順序的這部分, 總結來說 AuthorizationFilterAttribute 先於 ActionFilterAttribute 執行 (從流程圖上來看合理). 多個同種類的 FilterAttribute 實作, 會依照套用的順序執行, 但 OnActionExecuted 與 OnActionExecutedAsync 是反序 (從流程圖上來看也合理, 因為 OnActionExecuted 系列方法是在 Action 執行後要 response 時才執行). 如果有例外發生的話, ExceptionFilterAttribute 會在最後才執行. 一個 FilterAttribute 內部的方法執行順序看起來是非同步方法先於同步方法. 單一測試就下結論其實不穩妥, 所以我後來又做了幾次不一樣的排序實驗, 看起來結果是符合推測的, 但無法完全保證. 有些特性可能會隨著版本的變遷改變, 如果實際專案要用, 又真的很在意這些順序或其他細節的話, 還是要再就實際狀況測試一輪. 結論想像一下, 當有一天團隊要導入 log 收集與分析工具, 需要統一 log 的格式時, 如果當初有用 FilterAtrribute 來印通用訊息就可以省下非常多瑣碎的工, 而例外處理也是同理, 且能避免到處都是為了抓 unhandled exception 而寫的 try-catch 語句. 參考How to disable a global filter in ASP.Net MVC selectivelyASP.NET Web API Exception FilterExclude A FilterThe ASP.NET Web API 2 HTTP Message Lifecycle in 43 Easy StepsASP.NET WEB API 2: HTTP MESSAGE LIFECYLE]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安全的使用遞迴]]></title>
    <url>%2Fcontent%2F20180915-use-recursive-safety.html</url>
    <content type="text"><![CDATA[遞迴有一個很大的好處是能用非常簡短的程式碼達到相對複雜很多的功能, 一般來說可讀性高很多, 但也伴隨著一些問題, 例如不慎引發堆疊溢位(stack overflow), 這篇主要是要紀錄怎麼安全的使用遞迴. 堆疊溢位.NET 中的 StackOverflowException 有兩種觸發情境, 一種是在程式碼中刻意拋出的, 像這樣: throw new StackOverflowException(), 這和一般的例外沒什麼差別, 只要有 catch 到就可以做後續處理, 但另一種真的因為堆疊溢位所引發的例外, 根據 MSDN 的說明是無法被 catch 的, 且經過實測發現問題發生時, 程序會直接被終止.堆疊溢位這個問題通常是由無限遞迴所引發的, 如果在 production 環境發生這個錯誤, 造成服務直停擺, 那真的會很悲劇. 其實就 MSDN 看來, 似乎有其他方式可以讓系統不要因為堆疊溢位而停擺, 但太深奧了看不懂, 另一方面來說, 會出現這個問題大多是因為 bug, 所以目前不打算深入去看這一塊. 防止堆疊溢位控制遞迴深度目前看到最簡明的方法是利用一個參數去紀錄目前堆疊的深度, 並在超過設定的最高深度時終止遞迴(或做其他相應的處理).12345678910111213public void Foo(int depth = 0)&#123; if (depth &gt; 9) &#123; return; &#125; // do something... Foo(++depth); // do something...&#125; 做好單元測試即使有控制遞迴深度, 但還是有可能會把控制深度的地方寫錯, 所以單元測試還是寫完整點才能多一層保障. 結論雖然無限遞迴引發的問題比較嚴重, 但只要做好控制與測試, 其實遞迴還是很好用的, 比較需要在意的地方反而是因為遞迴相對抽象一點, 如果遞迴寫得太複雜的話, 後人會比較難維護. 參考MSDN: Troubleshooting Exceptions: System.StackOverflowExceptionWhat’s a good general way of catching a StackOverflow exception in C#? - 最佳解下面的推文部分有提到看似有方法處理堆疊溢位, 但有點矯枉過正 (a bit overkill)]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 的自動實作屬性]]></title>
    <url>%2Fcontent%2F20180909-auto-implemented-properties.html</url>
    <content type="text"><![CDATA[自動實作屬性(auto implemented properties)是 C# 非常基本的規格, 雖然他跟 欄位(fileds) 使用上非常相似, 但本質上是不一樣的東西.這篇主要是紀錄一些網路上的比較資訊以及自己好奇下做的一個小實驗, 沒什麼太特別的內容. 欄位, 屬性與自動實作屬性先來看看官方對於欄位(fileds), 屬性(properties)與自動實作屬性(auto implemented properties)的介紹, 這部分的介紹與比較網路資料多到看不完, 我就懶得再多整理一次了. 建議: private 時使用欄位, 除此之外使用自動實作屬性. 如果需要對欄位進行自動實作屬性的預設行為以外的操作時, 使用屬性. 自動實作屬性編譯後變什麼?根據官方與大量網路資料的說法, 自動實作屬性編譯後會產生兩個存(set)取(get)用的方法和一個欄位(backing field), 昨天剛好好奇想說能不能知道這兩個方法和欄位究竟長什麼樣子.於是基於好奇, 就利用反射的方式在監看式(Watch)中去挖裡面的內容, 果然找到一些有用的東西, 整理後如下:123456789101112131415161718192021public class MyClass&#123; public string MyProperty &#123; get; set; &#125;&#125;static void Main(string[] args)&#123; var property = typeof(MyClass).GetProperty("MyProperty"); var runtimeField = typeof(MyClass).GetRuntimeFields().First(); // method name for get: get_MyProperty Console.WriteLine("method name for get: " + property.GetMethod.Name); //method name for set: set_MyProperty Console.WriteLine("method name for set: " + property.SetMethod.Name); // name for backing filed: &lt;MyProperty&gt;k__BackingField Console.WriteLine("name for backing filed: " + runtimeField.Name); Console.ReadLine();&#125; 既然編譯後會產生這樣的兩個方法, 那如果我在 class 裡面刻意加上這兩個方法的話會如何呢?12345678910111213public class MyClass&#123; public string MyProperty &#123; get; set; &#125; public string get_MyProperty() &#123; return null; &#125; public void set_MyProperty(string val) &#123; &#125;&#125; 果然, 編譯不會過, 出現這樣的錯誤 本來還想試試看能不能弄出跟 backing field 衝突的欄位, 不過失敗了. 其實這個實驗對於實作上沒什麼明顯的幫助, 不過有時候稍微追根究底一下也是有趣. 結論其實欄位, 屬性與自動實作屬性的使用時機還滿明確的, 以往使用上也沒有特別難以抉擇的情境出現, 不過真的要回答 “為什麼這樣用?” 時, 還真回答不出來, 然後這邊順便放一下網路上對於這部分的文章 C# in Depth - Why Properties Matter 使用 屬性(Property) 的好處 Difference between Auto - Implemented Properties and normal public member variables Is it bad practice to use public fields? Automated property with getter only, can be set, why?]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[簡化 if 條件式]]></title>
    <url>%2Fcontent%2F20180819-simplify-if-statement.html</url>
    <content type="text"><![CDATA[if 條件式很常用, 但在有時因為使用不當造成閱讀或維護上的困難, 尤其是巢狀的 if-else 條件式對維護上造成很大的負擔, 這其實是有一些小技巧可以簡化 if 條件式的, 當然, 這些技巧不是萬靈丹, 使用上還是有些細節要注意的. 一般 if 條件式一般的 if 條件式其實沒什麼好簡化的, 但如果之後的處理邏輯很簡單或滿足特定情境的話, 還是有簡化的空間. 三元運算子 ?:先附上官方文件. 三元運算子是基本規格也沒啥好說的, 但如果用不好反而會降低可讀性. 1234567891011121314151617181920212223// string s;// if(isTure)// &#123;// s = "Empty"// &#125;// else// &#123;// s = foo;// &#125;string s = isTrue ? "Empty" : foo;// string s2;// if(isTure)// &#123;// s2 = GetTheString();// &#125;// else// &#123;// s2 = GetAnotherString();// &#125;string s2 = isTure ? GetTheString() : GetAnotherString(); 建議: 一般只有一行文的情境下才適用. 用了他之後會比原本的 if-else 易讀就用. 上例中第二種分三行的做法要視情境斟酌一下, 不一定適合. 避免: 使用兩層(或超過)的三元運算子, 因為可讀性很差. Null 條件運算子 ?., ?[] 與 ??先附上?., ?[] 的官方文件 以及 ?? 的官方文件, 其中 ?. 和 ?[] 是 C# 6.0 之後的規格. 主要用途是減少空值判斷的程式碼, 讓維護時更能專注於商業邏輯上.12345678910111213141516171819202122232425262728293031323334353637383940414243// string s;// if(value == null)// &#123;// s = "Empty";// &#125;// else// s = value;// &#123;// &#125;string s = value ?? "Empty";// string s2;// if(obj == null)// &#123;// s2 = null;// &#125;// else// &#123;// s2 = obj.Property;// &#125;string s2 = obj?.Property;// string s3;// if(obj == null)// &#123;// s3 = "Empty";// &#125;// else// &#123;// s3 = obj.Property;// &#125;string s3 = obj?.Property ?? "Empty";// string s4;// if(objectWithIndexer == null)// &#123;// s4 = null;// &#125;// else// &#123;// s4 = objectWithIndexer["key"];// &#125;string s4 = objectWithIndexer?["key"]; 建議: 很好用, 可以盡量用. 巢狀 if 條件式相信維護過有歷史包袱的系統的工程師多少都見過巢狀的 if 條件式, 甚至是巢狀的 if, else if, else 堆疊起來的程式碼片段, 這樣的程式碼常常看到後面忘了前面, 要花很多時間甚至畫出流程圖才能理解複雜的邏輯. 合併判斷條件下面的程式碼是最單純的情境, 這類型的巢狀 if 條件式可以很輕易的合併. 123456789101112131415// if(a)// &#123;// if(b)// &#123;// if(c)// &#123;// //Do something...// &#125;// &#125;// &#125;bool isTrue = (a &amp;&amp; b &amp;&amp; c);if(isTrue)&#123; //Do something...&#125; 建議: 實際情況當然不會這麼單純, 如果參雜 else if 或 else 的時候就很容易出錯, 先寫好單元測試再來合併條件式會比較好. 提早返回(return)提早返回是一個我很喜歡用的作法, 但用不好的話可讀性還是不會太好. 1234567891011121314151617181920212223242526// if(a)// &#123;// // Do somthing...// &#125;// else if(b)// &#123;// // Do somthing...// &#125;// else// &#123;// // Do somthing// &#125;if(a)&#123; // Do somthing... return;&#125;if(b)&#123; // Do somthing... return;&#125;// Do somthing...return; 建議: 提早返回的行為盡可能集中在方法的最前面, 或只集中在同一個區塊, 這樣的思路就單純是在某些情境下提早返回, 否則往繼續執行. 提早返回前要確認條件式結束後沒有其他邏輯. 避免: 在一個方法中多次且分散的提早返回, 這樣維護時需要一直注意哪些地方有提早返回, 反而分散注意力了. 依職責拆分出不同方法如果前面的方法都做了, 也避開了誤用的情境, 但還是存在巢狀的 if 條件式時, 就要考慮這個方法是否違反了單一職責原則(Single Responsibility Principle, SRP), 並考慮將某些情境重構成獨立的方法. 結論其實這些做法也不是什麼神奇的技巧, 但沒人提醒或是沒在專案中見過的話就很難意識到, 我剛入行時也是常常弄出巢狀的 if 條件式, 覺得對後面接手的人有點抱歉XD 參考官方文件]]></content>
      <categories>
        <category>C#</category>
        <category>Clean Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[責任鏈模式(Chain of Responsibility)的變形]]></title>
    <url>%2Fcontent%2F20180618-chain-of-responsibility-like.html</url>
    <content type="text"><![CDATA[責任鏈模式在教科書上的典型範例是用在簽核流程上, 也就是一個任務/資料會依序流過各個處理節點, 每個節點會判斷任務/資料是不是在自己的權責範圍內, 決定要自己處理還是繼續往下拋. 前陣子公司專案剛好有一個類似情境, 但需求與教科書用法不同, 第一時間想到一個變形的作法, 而公司大神也提供了另一個更簡潔的做法, 趁還沒忘整理一下記下來. 完整的示範專案和文件 情境是這樣的, 有一系列的交易驗證機制, 在很多地方都會被用到, 規則是先檢查A, 若A通過再檢查B, 若B通過再檢查C…依此類推, 直覺呼叫各個檢查點的話, 程式碼會顯得有點複雜. 從層層上報變成生產線改造一下責任鏈, 把行為變成讓一個任務/資料會依序流過各個處理節點, 各節點處理自己該做的部分, 沒問題再往下拋, 如下面範例: 待驗證內容12345678public class ValidateContext&#123; public decimal Amount &#123; get; set; &#125; public string Email &#123; get; set; &#125; public string Country &#123; get; set; &#125;&#125; 各個驗證節點 : 每個驗證點都繼承自 Validator.123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Validator&#123; public Validator NextValidator &#123; get; set; &#125; public abstract bool Validate(ValidateContext context);&#125;public class AmountValidator : Validator&#123; public override bool Validate(ValidateContext context) &#123; if (context.Amount &gt; 10 &amp;&amp; context.Amount &lt; 1000) &#123; return NextValidator?.Validate(context) ?? true; &#125; return false; &#125;&#125;public class EmailValidator : Validator&#123; public override bool Validate(ValidateContext context) &#123; if (context.Email == "ron.sun@mailserver.com") &#123; return NextValidator?.Validate(context) ?? true; &#125; return false; &#125;&#125;public class CountryValidator : Validator&#123; public override bool Validate(ValidateContext context) &#123; if (context.Country == "Taiwan") &#123; return NextValidator?.Validate(context) ?? true; &#125; return false; &#125;&#125; 驗證流程管理者 : 這邊有些教學會把他直接放在呼叫端, 但如果要重用的話, 還是拉出來比較適合.1234567891011121314151617181920212223242526public class ValidatorManager&#123; public bool BasicValidation(ValidateContext context) &#123; var amountValidator = new AmountValidator(); var emailValidator = new EmailValidator(); Validator rootValidator = amountValidator; amountValidator.NextValidator = emailValidator; return rootValidator.Validate(context); &#125; public bool FullValidation(ValidateContext context) &#123; var amountValidator = new AmountValidator(); var emailValidator = new EmailValidator(); var countryValidator = new CountryValidator(); Validator rootValidator = amountValidator; amountValidator.NextValidator = emailValidator; emailValidator.NextValidator = countryValidator; return rootValidator.Validate(context); &#125;&#125; 呼叫端123456789101112static void Main(string[] args)&#123; var mng = new ValidatorManager(); var context = new ValidateContext() &#123; Amount = 100&#125;; bool isValid = mng.Validate(context); if (isValid) &#123; Console.WriteLine("pass validations."); &#125; Console.ReadLine();&#125; 視情境還是可以再變化, 例如: 驗證不通過時不中斷, 一定要跑完所有驗證才返回結果與錯誤訊息總結, 那就是把返回從 bool 改成一個物件, 讓每個驗證節點去操作返回物件. List 和 Func 搭配迴圈委派, 集合與迴圈的搭配, 可以讓一連串的方法呼叫變得更簡潔, 也有一點責任鏈的味道在裡面 , 範例如下: 驗證方法1234567891011121314151617public class Validator&#123; public bool AmountValidate(decimal amount) &#123; return amount &gt; 10 &amp;&amp; amount &lt; 1000; &#125; public bool EmailValidate(string email) &#123; return email == "ron.sun@mailserver.com"; &#125; public bool CountryValidate(string country) &#123; return country == "Taiwan"; &#125;&#125; 呼叫端12345678910111213141516171819static void Main(string[] args)&#123; var context = new ValidateContext() &#123; Amount = 100 &#125;; var validator = new Validator(); var validateList = new List&lt;Func&lt;bool&gt;&gt;() &#123; () =&gt; validator.AmountValidate(100), () =&gt; validator.EmailValidate("name@mail.com"), () =&gt; validator.CountryValidate("Taiwan") &#125;; foreach(var item in validateList) &#123; var isValid = item(); if (!isValid) break; &#125; Console.ReadLine();&#125; 這種做法讓集合內的 Func&lt;&gt;, Action&lt;&gt; 等委派方法能依序被處理, 且這些方法可以分別在不同的類別裡, 也不用像一般責任鏈必須衍生自父類別, 唯一的限制就是 Func&lt;&gt;, Action&lt;&gt; 的型別參數必須完全相同. 結論責任鏈的基本樣貌就像一條生產線, 基於這個原則下衍生的變形或簡化做法其實還不少, 我把他們稍微整理在這個專案裡.]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用 C# 處理 query string]]></title>
    <url>%2Fcontent%2F20180608-handle-querystring-in-csharp.html</url>
    <content type="text"><![CDATA[在網頁開發上, 處理 query stirng 是非常常見的情境, 要手動拆組 query string 也不難, 或是使用 .NET 本身就提供的相關功能讓這件事更輕鬆, 而兩種做法各有優缺點. 手動拆組最直覺的方法就是手動拆組字串, 例如: 1234567891011121314151617181920212223242526static void HandleQueryString()&#123; // 手動拆 query string var queryString = "?q1=v1&amp;q2=v2&amp;q3=v3"; if (queryString.StartsWith("?")) &#123; queryString = queryString.Remove(0, 1); &#125; var splitedQueryString = queryString .Split('&amp;') .ToDictionary(r =&gt; r.Split('=')[0], v =&gt; v.Split('=')[1]); // 手動組 query string var queryDic = new Dictionary&lt;string, string&gt;() &#123; ["q1"] = "v1", ["q2"] = "v2", ["q3"] = "v3" &#125;; var formatedQueryString = queryDic .Select(r =&gt; $"&#123;r.Key&#125;=&#123;r.Value&#125;") .Aggregate((left, right) =&gt; $"&#123;left&#125;&amp;&#123;right&#125;");&#125; 手動拆組 query string 常常還要考慮拿到的 query string 前面有沒有多帶問號, 常用的話還要另外抽出來當共用方法, 比較麻煩但相對的很直覺, 且比較不會遇到編碼問題. HttpUtility.ParseQueryString如果不想手動拆組字串的話, 可以用 HttpUtility.ParseQueryString() 來處理 query string, 例如: 123456789101112131415static void HandleQueryStringEasier()&#123; // 拆 query string var queryString = "?q1=v1&amp;q2=v2&amp;q3=v3"; var splitedQueryString = HttpUtility.ParseQueryString(queryString); // 組 query string var query = HttpUtility.ParseQueryString(string.Empty); query["q1"] = "v1"; query["q2"] = "v2"; query["q3"] = "v3"; var formatedQueryString = query.ToString();&#125; 這樣做輕鬆很多, 但如果 query string 裡面有中文字或特殊符號的時候容易衍生出編碼相關的問題, 類似的編碼轉換問題在 HttpRequest.QueryString 的自動 UrlDecode 問題 這篇也有提到. 結論兩種做法都各有優缺, 實務上怎麼做還是得視情況決定, 一般來說我還是會優先選擇 HttpUtility.ParseQueryString, 如果有無法解決的編碼問題再考慮手動拆組.]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[const 和 readonly 特性與使用時機]]></title>
    <url>%2Fcontent%2F20180519-const-vs-readonly.html</url>
    <content type="text"><![CDATA[在C#中 const 和 readonly 都可以被當作常數來使用, 但兩者在特性上有許多的差異, 使用上也有一些需要注意的地方. const說明const 又稱”編譯時期常數”, 實際值在編譯期間就會被取代到使用常數的各個地方, 所以相對的限制比較多, 下面只列舉一部分 const 的重要特性, 完整特性可參照 C# 規格書(5.0版 章節10.4). 常數被視為靜態成員, 呼叫方法是 MyClass.MY_CONST. 常數宣告中的型別只能是 sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, enum, 或 reference type. 很神奇的一點是, 常數的型別可以是 reference type, 但是只能賦值 null, 例如:public const MyClass MY_COSNT = null;stackoverflow上有人討論過這個特性的用法 (不過我目前大概還不會這樣用它) 使用時機常數的推薦用法與時機 這個值是不能在執行時期變動的 存取修飾子不建議用 public, 因為基於這個情境, const 不適合跨組件引用. readonly說明readonly 是用在唯讀欄位上, 限制這個欄位只能在建構子或靜態建構子中被修改, 作為常數使用時又稱為執行時期常數, 執行的時候再去參考變數取得真正的值. 使用時機唯讀欄位的推薦用法與使用時機 初始化後就不能再被變動 不適合或無法用 const 的時候 唯讀欄位的值可以在建構子中被改變也讓一些人覺得他不是那麼唯讀, 例如下面的程式碼:12345678910public static class C1&#123; public readonly static string str = &quot;a&quot;; static C1() &#123; str = &quot;b&quot;; str = &quot;c&quot;; &#125;&#125; 唯讀欄位str被賦值”a”之後又在建構子中被改變了兩次值. 偏好使用 readonly 而非 const考慮一個情境, 現在有一個類別庫 DefaultLib, 裡面有一個類別 DefaultClass 如下:12345public class DefaultClass&#123; public const int AGE = 18; public readonly string NAME = "John";&#125; 另一個專案 Execute 參考這個類別庫, 並印出 AGE 和 NAME 如下:12345678910class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(DefaultClass.AGE); Console.WriteLine(new DefaultClass().NAME); Console.Read(); &#125;&#125; 執行後沒問題, 印出了 18 和 John . 接下來, 改成 AGE = 20, NAME = &quot;Smith&quot; 後只編譯 DefaultLib 專案, 並將 DefaultLib.dll 覆蓋掉舊的 dll 後直接執行 Execute.exe. 結果印出了 18 和 Smith 這其實就是一開始說的 const 作為編譯時期常數, 實際值在編譯期間就會被取代到使用常數的地方, 但 readonly 是參考變數取得真正的值, 所以 Execute 這個專案編譯後印出 AGE 與 NAME 的那兩行, 其實是12Console.WriteLine(18);Console.WriteLine(new DefaultClass().NAME); 於是, 不管參考的 DefaultLib.dll 怎麼變化, 只要 Execute 專案不重新編譯, 第一行印的永遠是 18 ,但使用 readonly 就不會有這個問題. 結論這篇主要的重點是偏好使用 readonly 而非 const而已, 這也不是什麼鮮為人知的秘密, 相關的文章google一下就很多了, 而且都寫得更好, 會特別寫一篇只是想整理一下學習成果, 還意外發現了 const 可以是 reference type 的神奇特性. 參考C#語言規格書C# - const vs static readonlyWhy are we allowed to use const with reference types if we may only assign null to them?]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消除switch-case]]></title>
    <url>%2Fcontent%2F20180412-anti-switch-case.html</url>
    <content type="text"><![CDATA[Switch-case 是一個經常被使用到的語句, 但當條件/情境過多的時候, 他會變得很肥大, 某種程度上造成維護上的困擾, 網路上也有不少人提出針對過大的 switch-case 語句的重構技巧, 例如: 策略模式.但是策略模式會長出很多新的類別, 如果每個 case 的實作內容都很小, 這樣做似乎是有點複雜了, 所以這邊提供其他的替代方案(但會有一些限制). switch-case的問題先看一段程式碼12345678910111213141516171819202122232425public string Convert(StringConverter converter, string input)&#123; switch (converter) &#123; case StringConverter.Rule1: return DoByRule1(input); break; case StringConverter.Rule2: return DoByRule2(input); break; case StringConverter.Rule3: return DoByRule3(input); //以下省略100種 default: return string.Empty; break; &#125;&#125;public void Main()&#123; // ... string result = Convert(StringConverter.Rule1, "this is input"); // ...&#125; 上面的程式碼是經過最初步整理的樣子, 至少每個case都提取出一個方法, 但是如果情境持續增加, 這個switch-case語句仍然會繼續成長下去, 似乎還能做一些改善. 用 Dictionary 搭配 Func 或 Action 解決從原本的 switch-case 可以看出功能其實很單純, 固定傳入一個字串, 經過某種演算過程, 回傳另外一個字串, 只不過根據列舉(enum)的不同, 要做的事也不同, 這種情境就很適合用 Dictionary&lt;TKey, Func&lt;&gt;&gt; 來處理. 12345678910111213141516private Dictionary&lt;StringConverter, Func&lt;string, string&gt;&gt; allRules = new Dictionary&lt;StringConverter, Func&lt;string, string&gt;&gt;() &#123; [StringConverter.Rule1] = (input) =&gt; &#123; return DoByRule1(input); &#125;, [StringConverter.Rule2] = (input) =&gt; &#123; return DoByRule2(input); &#125;, [StringConverter.Rule3] = (input) =&gt; &#123; return DoByRule3(input); &#125; //以下省略100種 &#125;;public void Main()&#123; // ... var rule = allRules[StringConverter.Rule1]; string result = rule("this is input"); // ...&#125; 經過整理後, 我們將列舉與行為的配對抽出來成為一個 Dictionary&lt;StringConverter, Func&lt;string, string&gt;&gt;, 可讀性提高了不少(尤其 case 很多的時候會更明顯).但是這種方式是有一些限制的, 所有情境必須有相同的參數與回傳型別, 才能把他們全部放到一個 Dictionary 中, 如果不幸的所些情境參數或回傳型別不同, 那就要考慮是否另外封裝共用的物件作為參數與回傳型別, 此舉是有副作用的(共用的參數與回傳型別中的成員是所有情境的聯集, 可能會很多或很亂), 因此也應該考慮這樣做的效益是否大於副作用. 搭配 Action 概念跟上一個例子一樣, 不過是用無參數的 Action. 結論技巧跟手法有好處就有副作用, 所以不是所有 switch-case 的情境都適合這樣處理, 有些情境可能維持原本的 switch-case 會更好. 類似的技巧還有用 List&lt;Func&lt;&gt;&gt; 搭配 foreach, 可用來達成依序執行一系列的行為的目的, 也是很不錯 參考Abolishing Switch-Case Statement and Pattern Matching in C# 7.0]]></content>
      <categories>
        <category>C#</category>
        <category>Clean Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 修飾詞 - partial]]></title>
    <url>%2Fcontent%2F20180409-usage-of-partial-in-csharp.html</url>
    <content type="text"><![CDATA[C# 的 partial 修飾詞是相對少用的特性, 但在某些時候能起到很關鍵的作用, 所以還是知道一下比較好.partial不是關鍵字但是他可以放在在class, struct, interface 以及 void method(…) 的前面作為修飾詞, 並將類型宣告或方法拆分成多個, 而編譯時會將所有區段結合起來, 所以對執行時期沒有影響. 用法部分類別(partial class)以部分類別為例, 我們可以將一個類別拆成多個部分類別並且分別放在不同的多個檔案中, 如下: OrderService.cs1234public partial class OrderService&#123; // something...&#125; OrderService2.cs1234public partial class OrderService&#123; // something...&#125; 以目前所知patial的用途對於 interface, struct 都相似於 class 部分方法(partial method)方法宣告在其中一個部分類別中, 並在另外其中一個部分類別中實作已宣告的部分方法. OrderService.cs12345public partial class OrderService&#123; //宣告 partial void CreateOrder();&#125; OrderService2.cs12345678public partial class OrderService&#123; //實作 partial void CreateOrder() &#123; // ... &#125;&#125; 用途那麼, 什麼情境需要特意將相同類別拆分到不同檔案中呢? 下面依然以部分類別為出發點說明. 部分方法的情境目前還沒遇過, 暫時想不到範例 擴充由工具產生的程式碼工具產生的程式碼原則上是不允許人為去直接修改內容的, 因為當下次重新產生的時候, 會將修改的部分也覆蓋掉, 所以我們會透過 partial 將工具產生的程式碼與人為擴充的程式碼分開.這方面的應用常見的是在擴充 EF(Entify Framework) 自動產生的 Models 上, EF產生的 Models 是基於資料庫的欄位的設計的, 有時候我們需要加上一些欄位方便使用時就能派上用場, 例如: Member.cs (工具產生)123456public partial class Member&#123; public string FirstName &#123; get; set; &#125; public string LasName &#123; get; set; &#125;&#125; MemberExtend.cs (人為擴充)12345678910public partial class Member&#123; public string FullName &#123; get &#123; return $"&#123;FirstName&#125; &#123;LasName&#125;"; &#125; &#125;&#125; 上面的例子中, EF在更新Models時只會覆蓋 Member.cs, 對於擴充部分可以不用擔心被影響. 類別過大且難以分割有些類別本身包含大量的內容, 且因為種種因素難以拆分時, 就可以利用partial並將其拆分成不同檔案. 如果可以的話還是重構出更小的單元, 分成多個部分類型不是優先選項. 重構單一類別時這是運用在之前公司的專案上的, 當時因為類別中的程式碼過多且複雜, 無法一次重構完, 又擔心當下只重構一部分會讓之後要繼續時需要重新花時間再看過一遍, 就將重構後的程式碼拆成另一個檔案, 等之後全部整理完再合併成一個. 限制由於部分類型編譯後會被視為一個類型, 其限制的大原則是不能與這個特性矛盾, 這邊大致列出一些. 部分方法 回傳必須為 void, 且 partial 一定要放在 void 前面 不可明確指定存取修飾詞, 隱含為 private 一個方法最多只能在所有部分類別中宣告一次 最多只能有一個以下的實作 可以宣告後不實作, 但不能有實作沒宣告 參數不可有 out 修飾詞 無法明確實作介面方法 其餘族繁不及備載, 更多細節參閱 C# 規格書或 MSDN 其他部分類型所有部分類型的 存取修飾詞不可衝突(但可以只有一個部分類型明確指定修飾詞) 泛型參數的數量、順序與名稱必須完全一致 泛型參數的條件約束不可衝突(可以只有一個部分類型明確指定條件約束) 更多細節參閱 C# 規格書或 MSDN 完整特性關於partial修飾詞的完整特性(非常多…), 參閱C#規格書, 相關目錄如下(主要在第10章的幾個小節中, 其他章就只是簡介然後說參考第10章). 類別10.1.2 Partial 修飾詞10.2 部分類型10.6.8. 部分方法 結構11.1.2 partial 修飾詞 介面13.1.2. partial 修飾詞 參考與延伸C#語言規格書MSDNIntroduction to Partial Methods]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
      <tags>
        <tag>partial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的隨機數]]></title>
    <url>%2Fcontent%2F20180304-random-in-csharp.html</url>
    <content type="text"><![CDATA[前些日子, 收到一個小需求需要隨機產生一組帶大小寫字母和數字的亂數字串, 想說需求滿簡單的, 快速寫一下就寫完commit了, 然後過不久就爆掉了.來看看究竟寫了些什麼鬼東西~ 12345678910111213141516public class RandomUtil&#123; private string _charDic = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; public string RandomString(int length) &#123; Random rdm = new Random(); string result = string.Empty; for (int i = 0; i &lt; length; i++) &#123; int nextIndex = rdm.Next(_charDic.Length); result += _charDic[nextIndex]; &#125; return result; &#125;&#125; 程式內容很單純, 就是用System.Random隨機生出指定長度的字串, 但問題就出在需要隨機產生兩組, 於是呼叫端就呼叫了兩次, 像是這樣: 123var rdm = new RandomUtil();Console.WriteLine(rdm.RandomString(10));Console.WriteLine(rdm.RandomString(10)); 然後產生的兩個結果字串一模一樣, Why? 同時建立多個RandomRandom的產生方式是基於一個種子來產生的, 也就是public Random(int Seed)中的Seed, 也就是說如果種子一樣, 那兩個new出來的Random物件產生的隨機數是一模一樣的, 而另外一個不帶參數的建構子呢?從referencesource.microsoft.com上面可以查到原始碼是這樣的: 1234public Random() : this(Environment.TickCount) &#123;&#125; 是的,預設以Environment.TickCount做為種子, 而Environment.TickCount是衍生自系統計時器的一個值. 因為Random()的亂數是基於系統計時器產生的, 所以如果在極短時間內 (Environment.TickCount相同) 建立多個Random實例,就會導致產生的亂數是一樣的. 知道問題後, 腦中閃過兩個做法: 解一: Thread.Sleep()在new Random()之前, 先延時一毫秒, 避免拿到重複的時間, 雖然直覺但我個人不喜歡. 解二: 建立唯一的Random1234567891011121314151617public class RandomUtil&#123; private string _charDic = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; private Random _rdm = new Random(); public string RandomString(int length) &#123; string result = string.Empty; for (int i = 0; i &lt; length; i++) &#123; int nextIndex = _rdm.Next(_charDic.Length); result += _charDic[nextIndex]; &#125; return result; &#125;&#125; RandomUtil初始化的時候就建立一個唯一的Random物件, 避免短時間內重複建立, 呼叫端程式碼不變, 這次兩次產生的結果是一樣的了,問題在大部分的情境下解決了. 多執行緒環境下的Random考慮同時有兩條執行緒都建立了Random, 簡單比對一下結果: 123456789101112131415161718192021string firstThreadResult = null;var firstThread = new Thread(new ThreadStart(() =&gt;&#123; firstThreadResult = new RandomUtil().RandomString(10);&#125;));string secondThreadResult = null;var secondThread = new Thread(new ThreadStart(() =&gt;&#123; secondThreadResult = new RandomUtil().RandomString(10);&#125;)); firstThread.Start();secondThread.Start();firstThread.Join();secondThread.Join(); var rdm = new RandomUtil();Console.WriteLine(firstThreadResult);Console.WriteLine(secondThreadResult); 實驗結果顯示, 兩個產生的字串一樣, 所以在多執行緒的情境下, 還是有機會產生重複的亂數組合. 解三: RNGCryptoServiceProvider123456789101112131415161718192021public class RandomUtil&#123; private string _charDic = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; private RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider(); public string RandomString(int length) &#123; string resultArr = string.Empty; for (int i = 0; i &lt; length; i++) &#123; var nextBytes = new byte[4]; _rng.GetBytes(nextBytes); var index = BitConverter.ToInt32(nextBytes, 0) % _charDic.Length; resultArr += _charDic[index]; &#125; return resultArr; &#125;&#125; RNGCryptoServiceProvider可以避免Random在多執行緒情境下的重複問題, 但缺點就是他不像Random提供那麼多方法, 所以需要自己實作Next(),Next(max),Next(min, max)等方法. 後來我把相關方法整理重構過放在我的 Github 上了, 實作細節有不少差異, 但概念是跟上面的範例一樣的. 延伸 - 關於隨機數密碼學(隨機數筆記) 參考Random numbers - C# in depth]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>Random</tag>
        <tag>RNGCryptoServiceProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正確重拋例外]]></title>
    <url>%2Fcontent%2F20180131-correctly-re-throw-exception.html</url>
    <content type="text"><![CDATA[重拋例外有很多種方式, 包含 throw, throw ex, 使用 inner exception 以及 System.Runtime.ExceptionServices.ExceptionDispatchInfo, 或是不要重拋例外. 先總結選擇如下順序: 最好不要重拋例外 重拋優先選 System.Runtime.ExceptionServices.ExceptionDispatchInfo 沒有框架支援則用 Inner Exception throw 應該沒什麼情境需要用到了 throw ex 是具破壞性的作法, 除非是要刻意破壞堆疊追蹤 這篇會整理這幾種方法的使用與優缺, 並且另外提到 throw 和 throw ex 兩種方法對於堆疊追蹤的負面影響. throw &amp; throw exthrow vs throw ex這兩個最常見也很相似, 所以一起說, 使用 throw 或是 throw ex 都能重拋例外, 但使用 trow 時會保留較完整的堆疊追蹤(stack trace), 而 throw ex 會重置堆疊追蹤, 造成行數顯示在 throw ex 那一行。另外值得注意的是, 用 throw 來重拋例外其實也會漏掉一些堆疊追蹤, 這會在下面展示。 下面的範例程式中直接使用 throw 重拋例外, 並印出堆疊追蹤內容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Security.Cryptography;using System.IO;namespace ronsun.github.io.lab&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; ThrowException(); &#125; catch(Exception ex) &#123; Console.WriteLine("======= ThrowException() ============="); Console.WriteLine(ex); &#125; Console.ReadLine(); &#125; static void ThrowException() &#123; try &#123; ExceptionHere(); &#125; catch(Exception ex) &#123; throw; &#125; &#125; static void ExceptionHere() &#123; throw new Exception("This is exception message."); &#125; &#125;&#125; 運行後可以看到堆疊追蹤最後是停在 ExceptionHere() 裡面(41行), 也就是真正引發例外的地方 這邊有另外一個要注意的地方, 堆疊追蹤的第二行是停在 throw 的地方(35行), 本例看不出大的影響是因為有下一層呼叫可以追蹤, 下一小節會用另一段程式碼展示這個問題. 12345======= ThrowException() =============System.Exception: This is exception message. at ronsun.github.io.lab.Program.ExceptionHere() in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 41 at ronsun.github.io.lab.Program.ThrowException() in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 35 at ronsun.github.io.lab.Program.Main(String[] args) in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 17 但如果在35行使用 throw ex 的話, 堆疊追蹤最後就會停在 ThrowException() 這裡1234======= ThrowException() =============System.Exception: This is exception message. at ronsun.github.io.lab.Program.ThrowException() in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 35 at ronsun.github.io.lab.Program.Main(String[] args) in C:\Users\Ron\Desktop\MyProjects\ronsun.github.io\ronsun.github.io.lab\Program.cs:line 17 throw 也會影響堆疊追蹤的內容以下面的程式碼片段為例, 這次不另外呼叫一個引發例外的方法, 而是直接拋出一個例外12345678910111213141516171819202122232425static void Main(string[] args)&#123; try &#123; ThrowException(); &#125; catch(Exception ex) &#123; Console.WriteLine("======= ThrowException() ============="); Console.WriteLine(ex); &#125; Console.ReadLine();&#125;static void ThrowException()&#123; try &#123; throw new Exception("This is exception message."); &#125; catch(Exception ex) &#123; throw; &#125;&#125; 而此時的堆疊追蹤最後其實是停在 throw 那一行, 也就是說如果例外是發生在 ThrowException 方法中而不是下一層的呼叫, 且 try 區塊中有很多程式碼的時候, 還是會有難以除錯的困擾. Inner Exception基於前面的說明, 我們知道重拋例外會破壞堆疊追蹤, 所以另外一種做法是在重拋前將原始的例外放進 Inner Exception 中, 如下片段: 123456789try&#123; DoSomething();&#125;catch (Exception ex)&#123; // handle exception, then... throw new Exception("outer", ex);&#125; 但這樣做的缺點就是其實是重新包裝了例外, 如果呼叫端沒有往下查看 Inner Exception 的時候就會看不到完整的細節, 即使呼叫端有存取 Inner Exception 也比較麻煩, 是屬於功能正常但不夠優雅的方式. System.Runtime.ExceptionServices.ExceptionDispatchInfo靠框架解決, 是目前知道的方法中最漂亮的 123456789try&#123; DoSomething();&#125;catch (Exception ex)&#123; // handle exception, then... ExceptionDispatchInfo.Capture(ex).Throw();&#125; 使用容易, 看輸出也沒什麼副作用, 唯一的限制就是要依賴框架. 不要重拋例外這個方法寫在寫在這裡有點奇怪, 但個人來說是非常不喜歡重拋例外的, 比較傾向把所有不需要特殊處理的例外都讓全域例外處理機制去處理, 例如: Exception filters. 結論雖然理想上是不要重拋例外, 但如果真的不得已需要, 則使用 System.Runtime.ExceptionServices.ExceptionDispatchInfo, 萬一使用的框架不支援的話, 那至少要使用 Inner Exception 去處理. 參考資料Is there a difference between “throw” and “throw ex”? debuggability problems associated with catch / rethrow ‘throw e;’ vs. ‘throw;’ How to rethrow exception correctly in .Net]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何避免大量參數 - 以HttpHelper為例]]></title>
    <url>%2Fcontent%2F20171202-httpHelper-with-builder-like.html</url>
    <content type="text"><![CDATA[在設計 API 的時候, 常常會被參數過多所困擾著, 因為當方法有著過多參數時, 使用的時候容易眼花, 而需要增減參數時也很不方便, 這邊以常見的 HttpHelper 為例來說明。 一般來說, 如果專案只需要跟內部的 API 溝通的話, 其實用 HttpClient 來實作既方便又快速, 但是大量外部廠商對接溝通的時候可能就不太適合, 因為每家廠商對接的方式都不一樣, 所以目前的專案是用 WebRequest 來實作。 擁有大量參數的方法1234567891011121314public string Post(string url, string content, Encoding encoding, int contentType, string proxyAddress, string proxyUserName, string proxyPassword)&#123; var request = WebRequest.CreateHttp(url); request.ContentType = contentType; request.Method = WebRequestMethods.Http.Post; var contentBytes = encoding.GetBytes(content); request.ContentLength = contentBytes.Count(); //設定proxy //發送request, 取得並回傳response&#125; 需求的一開始, 參數可能只有 url 跟 content, 但是當對接廠商越來越多的時候, 有人要求只能用特定編碼(UTF8, GBK…), 資料格式不同時 content type 也要不同, 因為網路環境限制有時候要走 proxy 等等的, 這時候就會出現大量參數, 引發一些問題: 增加參數, 那所有呼叫端的程式都要改, 不難, 但是麻煩 呼叫端改好了, 為了避免帶錯值, 所以要測試一輪, 也不難, 但是很花時間 那就有改善的空間了 選擇性引數(Optional Arguments) 註: 口語上大多稱選擇性參數(Optional Parameters), 不過MSDN是用選擇性引數(Optional Arguments) 註: 參數和引數意義上是不同的 123456789101112131415161718public string Post(string url, string content = "", Encoding encoding = null, int contentType = "application/x-www-form-urlencoded", string proxyAddress = "", string proxyUserName = "", string proxyPassword = "")&#123; if(encoding == null) &#123; encoding == Encoding.UTF8; &#125; var request = WebRequest.CreateHttp(url); request.ContentType = contentType; request.Method = WebRequestMethods.Http.Post; var contentBytes = encoding.GetBytes(content); request.ContentLength = contentBytes.Count(); //設定proxy //發送request, 取得並回傳response&#125; 這樣用的好處是, 當需要增加非必要參數的時候, 可以直接加在參數列最後面, 並給他一個預設值, 那至少加參數的時候不用像尋寶一樣到處去找呼叫端修改了, 降低了手誤產生bug的風險, 也可以把測試專注在這個方法內就好。 但是, 還是有缺點: 參數列還是超長 參數預設值只能是編譯時期就決定好的常數, 所以Encoding這類參數, 必須預設為null, 然後另外在方法內判斷賦予預設值 新的參數如果不是加在最後面, 在某些情境下會有問題 註:基於以下方法, 呼叫 foo(0, &quot;B&quot;); 時代表的是 foo(0, b = &quot;B&quot;)但是如果插了一個參數在b之前, 而型別和b一樣, 方法簽章變成public void foo(int a, string c = &quot;&quot;, string b = &quot;&quot;)這時候呼叫 foo(0, &quot;B&quot;);代表的就會是foo(0, c = &quot;B&quot;)因此這邊會建議在呼叫帶有選擇性引數的方法時, 採用具名方式呼叫, 避免上面範例中的誤用 所以還是有改善的空間 把所有參數包成一個condition物件123456789101112131415161718public class Condition&#123; public string Url &#123; get; set; &#125; public string Content &#123; get; set; &#125; public Encoding Cncoding &#123; get; set; &#125; = Encoding.UTF8; public string ContentType &#123; get; set; &#125; = "application/x-www-form-urlencoded"; //其他省略&#125;public string Post(Condition condition)&#123; //基於condition準備request相關物件 //設定proxy //發送request, 取得並回傳response&#125; 好多了, 這次的改善避免了之前參數過長, 預設值也不受限於常數, 同時當需要增加非必填的參數時, 只需要修改 condition 物件並設好預設值, 呼叫端基本上不用有任何修改。 但是真要在吹毛求疵的話, 還是有一個缺點: API使用者無法一眼看出那些參數是必填. 我個人的習慣是, 如果不想讓使用者誤用, 那就從技術層面阻止他, 誘導使用者正確使用, 所以接下來接下來 condition 物件的變形直接先上完整版, 下面會細說 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Condition&#123; public string Url &#123; get; private set; &#125; public string Content &#123; get; private set; &#125; public Encoding Encoding &#123; get; private set; &#125; = Encoding.UTF8; public string ContentType &#123; get; private set; &#125; = "application/x-www-form-urlencoded"; public IWebProxy Proxy &#123; get; private set; &#125; = null; private Condition() &#123; &#125; public static Condition Create(string url) &#123; var reqParams = new Condition() &#123; Url = url &#125;; return reqParams; &#125; public Condition WithContentType(string contentType) &#123; ContentType = contentType; return this; &#125; public Condition WithContent(string content) &#123; Content = content; return this; &#125; public Condition WithEncoding(Encoding encoding) &#123; Encoding = encoding; return this; &#125; public Condition WithProxy() &#123; //default proxy IWebProxy defaultProxy = WebRequest.GetSystemWebProxy(); defaultProxy.Credentials = CredentialCache.DefaultCredentials; Proxy = defaultProxy; return this; &#125; public Condition WithProxy(string address, string userName, string password) &#123; IWebProxy webProxy = new WebProxy(address); webProxy.Credentials = new NetworkCredential(userName, password); Proxy = webProxy; return this; &#125;&#125; 這樣做有幾個重點與目的 private Condition() { } 把預設的建構子設成私有, 然後透過有著必填參數的靜態方法 Create(string url) 來建立物件, 目的是讓使用者沒有機會漏填必填的參數 使用者建立物件後可以直接呼叫 WithXXXX(...) 方法設定非必填的參數, 具體呼叫範例: Condition.Create(&quot;http://sample.com&quot;).WithContent(&quot;&lt;xml&gt;balalala&lt;/xml&gt;&quot;).WithProxy();, 這樣的方法鏈非常方便, 是來自於 Fluent Interface 的概念 這樣 condition 組好直接作為 Post(Condition conditon) 的參數就可以了 這種方式是從建構者模式和 Fluent Interface 變形而來的, 建構者模式是把建構者 和 被建構者 分成兩個物件, 只不過對於一個只是要整合大量參數的需求來說, 要特別建立 Condition 和 ConditionBuilder 兩個物件是有點太多了, 所以稍微變化一下簡化他的複雜度, 網路上也有結合建構者模式和 Fluent Interface 做成 Fluent Builder 的例子.但是!!但是!!但是!! 如果不是非常複雜的情境的話, 這樣是有點過度設計了, 雖然呼叫起來很方便, 但會使得 Condition 變得比較複雜, 如果系統中到處都是這種東西的話其實會提高後續的維護門檻的. (推薦)只將選填參數包成 Condition 物件123456789101112131415161718192021public class RequestOptions&#123; public Encoding Cncoding &#123; get; set; &#125; = Encoding.UTF8; public string ContentType &#123; get; set; &#125; = "application/x-www-form-urlencoded"; //其他省略&#125;public string Post(string url, string content, RequestOptions options = null)&#123; if(options == null) &#123; options = new RequestOptions(); &#125; //基於options準備request相關物件 //設定proxy //發送request, 取得並回傳response&#125; 這個版本是我目前最推薦的, 一方面他減少了參數的數量, 另一方面把必填與選填參數分開, 避免使用者誤用, 也夠簡單好懂. 後記其實自己在寫東西常常弄到過度設計的窘境, 最近在練習怎麼樣才能把程式寫得剛好, 又能在易用, 好維護與好擴充中間找到平衡點(但好難XDD). 參考資料how-to-avoid-too-many-parameters-problem-in-api-designBuilder Design Pattern and Fluent Builder]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[將上游未合併的PR合併到自己的fork]]></title>
    <url>%2Fcontent%2F20171014-unmerged-pull-request-to-my-fork.html</url>
    <content type="text"><![CDATA[情境是這樣的, 我在github上fork了一個專案過來, 並且做了一些修改, 後來發現我的上游專案有幾個pull request剛好解決的我一直解決不了的問題, 該怎麼把那些變更同步到我的fork呢? 先說一下這故事的人事時地物: 情境如上 JohnDao 他是pull request的作者 issue-fix-branch-1是這個變更所在的branch AwesomeProject 是這個專案的名字 實作部分 先新增遠端儲存庫到要merge的來源專案1git remote add JohnDao-Repo https://github.com/JohnDao/AwesomeProject.git 然後把變更fetch下來1git fetch JohnDao-Repo 最後把變更merge進來, 然後push1git merge JohnDao-Repo/issue-fix-branch-1 結論這樣就能將別人(JohnDao)提交但是還沒被原作者合併回去的pull request先合併到自己這裡了。 參考資料How to apply unmerged upstream pull requests from other forks into my fork?git: how to merge a pull request into a fork?What is “git remote add …” and “git push origin master”?]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Visual studio 2017上使用AxoCover顯示測試程式碼涵蓋範圍]]></title>
    <url>%2Fcontent%2F20171009-test-code-coverage-AxoCover.html</url>
    <content type="text"><![CDATA[當我們想知道目前產品的測試程式涵蓋率的時候, 可以使用Visual Studio 2017內建的功能來分析, 但只有企業版支援這個功能, 所以另外找了AxoCover來用看看。 AxoCover安裝打開 Tools &gt; Extensions and Updates, 並找到AxoCover後直接安裝(安裝時需要關閉Visual Studio才能繼續)。 使用安裝完成開啟Visual Studio後, 可在Tool &gt; AxoCover打開功能視窗。 一開始的功能視窗看起來什麼都沒有, 照著上面的提示編譯一下專案後, 可以看到完整的功能頁面。 接著就幾個主要功能說明一下 Tests Tests &gt; Run執行所有單元測試。 Tests &gt; Cover分析測試涵蓋率, 結果可在Report頁籤看到。 Tests &gt; Build編譯。 Reposrt這邊可以看到涵蓋率的分析。 Reposrt &gt; Export將執行與涵蓋率分析結果分別輸出到~/.axoCover/runs 以及~/.axoCover/reports, 其中~/.axoCover/reports下是用一個精美的靜態網頁來顯示測試涵蓋率報表。 SettingsAxoCover的相關設定全在這。 操作上大致是這樣子的, 接著可以打開程式碼並且清楚的看到有被測試碼涵蓋到的部分是綠色, 沒涵蓋到的部分是紅色, 而部分涵蓋的那一行會有一個很小的黃色圖標。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C# 的 explicit 與 implicit 關鍵字]]></title>
    <url>%2Fcontent%2F20170924-explicit-implicit-keywords.html</url>
    <content type="text"><![CDATA[來紀錄一下 C# 的兩個關鍵字 , explicit 以及 implicit。 定義與使用時機implicit隱含轉換, 不需要明確指定轉換類型, 例如 int 轉換成 float 時, 只需要直接指定變數, 如下: 12int i = 10;float f = i; 隱含轉換使用於轉換不會造成資料誤差或例外的情境, 以本例來說, int 轉換成 float 值不會有誤差, 但反過來就會, 所以 float 轉換成 int 時需要明確轉換。 explicit明確轉換, 必須明確指定轉換類型, 同樣的例子, 當 float 要轉換成 int 的時候, 就會變成: 12float f = 10.12f;int i = (int)f; 明確轉換使用於轉換可能會造成資料誤差或例外時, 以本例來說, 10.12 轉成 int 後, 結果是會不同的, 所以應該用明確轉換比較恰當。 自訂物件的隱含與明確轉換範例情境首先我們先來考慮一個情境, 現在有兩個類別, 椅子 (Chair) 以及板凳 (Bench) 。 椅子只能坐一個人, 板凳則沒有限制, 所以椅子轉換成板凳時可以是隱含轉換, 但反過來就應該用明確轉換。 先來個椅子, 有個 HeadCount 屬性, 當指定給他的值大於 1 的時候, 代表人數超載了, 會拋出一個例外, 且有一個隱含轉換的方法 public static implicit operator Bench(Chair chair) 如下: 1234567891011121314151617181920212223242526272829public class Chair&#123; private int _headCount; public int HeadCount &#123; get &#123; return _headCount; &#125; set &#123; if (value &gt; 1) &#123; throw new ArgumentException("椅子座位只能容納一個人"); &#125; _headCount = value; &#125; &#125; // Chair 轉 Bench 可以是隱含轉換 // 這個方法也可以放在 Bench 中, 但不能兩邊都寫, 編譯不會過 public static implicit operator Bench(Chair chair) &#123; return new Bench() &#123; HeadCount = chair.HeadCount &#125;; &#125;&#125; 再來是板凳, 板凳沒有人數限制, 有一個明確轉換的方法 public static explicit operator Chair(Bench bench) 如下: 1234567891011121314public class Bench&#123; public int HeadCount &#123; get; set; &#125; // Bench 轉 Chair 需要明確轉換 // 這個方法也可以放在 Chair 中, 但不能兩邊都寫, 編譯不會過 public static explicit operator Chair(Bench bench) &#123; return new Chair() &#123; HeadCount = bench.HeadCount &#125;; &#125;&#125; 用戶程式:12345678910111213141516static void Main(string[] args)&#123; Chair chair = new Chair() &#123; HeadCount = 1 &#125;; Bench bench = new Bench() &#123; HeadCount = 1 &#125;; //當 bench 的 HeadCount 值大於1時, 這邊會拋 Exception 出來 Chair chairFromBench = (Chair)bench; Bench benchFromChair = chair;&#125; 使用說明接著說明一下轉換的部分, 實作轉換方法有幾個限制 存取修飾詞必須是 public 必須是靜態方法(static) 必須有 implicit 或 explicit 關鍵字 必須有 operator 關鍵字 總括來說方法必須長這樣12345public static implicit operator Destination(Source src)public static explicit operator Destination(Source src)public static implicit operator Source(Destination dest)public static explicit operator Source(Destination dest) 結論implicit / explicit operator 可以寫在來源或目標中, 但是沒規範又容易亂, 目前看起來寫在來源中比較好, 設計類別 A 的時候由類別 A 決定自己可以隱含或是明確轉換成何種類別, 相較於寫在目標類別中來說比較合理. 參考MS]]></content>
      <categories>
        <category>C#</category>
        <category>Language Spec</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo 與 hexo-theme-next 的零碎片段]]></title>
    <url>%2Fcontent%2F20170902-hexo-and-next-fragments.html</url>
    <content type="text"><![CDATA[Hexo以及hexo-theme-next樣板在使用上有滿多細節跟小地方是需要一直找資料解決的, 但是每個小東西都寫一篇覺得太零散了, 所以把相關的片段都放在這裡。 Hexoskip_renderhexo可以透過skip_render參數讓特定檔案不被渲染, 就以資產資料夾為例吧。 首先直接建立一個新的Post, 然後將sample.html檔案放到render_sample資料夾下, 這時候資料夾結構看起來是這樣的1234|-- _posts/2017-09/| |-- render_sample.md| |-- render-sample| | |-- sample.html 接著hexo g 一下, 這時候靜態文章的目錄會變成這樣12345|-- render-sample| |-- sample.html| |-- index.html| |-- sample| |-- index.html 這就是問題點, sample.html應該純粹作為資產使用才對, sample資料夾不應該存在的。 所以我們必須找出hexo的_config.yml檔, 並且設定skip_render參數, 指定資產資料夾不被渲染 skip_render: _posts/*/*/** 接著再重新hexo g一下, 目錄就可以正確的產出了123|-- render-sample| |-- sample.html| |-- index.html 這邊引述一下hexo官方文件的說明: skip_render: 跳過指定檔案的渲染，您可使用 glob 表達式 來配對路徑。 hexo-theme-next]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用xs3p將xsd轉換成文件]]></title>
    <url>%2Fcontent%2F20170902-xsd-to-document-by-xs3p.html</url>
    <content type="text"><![CDATA[有時候專案中會需要使用xml做為設定文件去定義程式的行為與參數, 而config有可能會非常複雜, 所以為了開發上的方便會用xsd來定義, 並且需要產出一份文件來讓新手快速了解config應該如何編寫, 所以我們需要一些工具來幫來製作文件。 目前這個專案, 需要文件化的xsd只有一個, 所以並沒有使用大砲級的 Liquid Studio 以及 DocFlex, 而是用了比較輕量簡單的 xs3p , 但是 官方的xs3p 排版太陽春, 所以這邊推薦使用 Github上的美化版, 或是我後來 fork 出來改過的版本. 接著會用 bitfehler 版本的 xs3p 介紹這個小工具的使用. 下載工具與依賴元件 xs3p美化版 Command Line Transformation Utility (msxsl.exe) MSXML 4.0 Service Pack 3: 可以不裝, 但轉換時Annotation中如果有CDATA區段會轉不出來。 xs3p資料夾結構與使用主要文件 /examples: 範例資料夾。 /examples/test_*.bat : 執行各種轉換工具的批次檔。 /examples/*.xsd: 範例XSD檔。 /xs3p.xsl: 轉換時需要使用的樣式定義。 使用(以msxml為例) 將 msxsl.exe 放到 /examples 資料夾中。 點擊 /examples/test_msxsl.bat 直接執行。 會在 /examples/msxsl-results 中產出 /examples 目錄下所有XSD檔轉換後的html文件。 範例XSD 與 範例HTML。 各種問題編碼問題轉出來的html檔所需要的css, js等資源都是連到cdn上拿, 如果在chrome上面樣式無法套用, 可能是編碼問題, 要在 xs3p.xsl 中的 &lt;link&gt; 元素中加上 charset=&quot;UTF-8&quot;。 1&lt;link href=&quot;&#123;$bootstrapURL&#125;/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; charset=&quot;UTF-8&quot;/&gt; 命名空間問題用xs3p搭配msxml.exe去產生xsd文件時, 需要特別當一個命名空間設定多個前綴, 只認第一個。 舉例, 下面的範例中, xmlns:first以及 xmlns:me是同樣的命名空間, 轉換時只認第一個, 所以如果xsd中以me為前綴的type轉換出來的超連結都會是失效的, 如附圖12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;xs:schema id="ComponentDefinition" targetNamespace="http://www.ronsun.com/ComponentDefinition/Guide.md" elementFormDefault="qualified" xmlns:first="http://www.ronsun.com/ComponentDefinition/Guide.md" xmlns:me="http://www.ronsun.com/ComponentDefinition/Guide.md" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;&lt;/xs:schema&gt; 列舉類型的Annotation無法轉換如下範例將註解加在enumeration中, 轉換後的文件會遺漏掉註解。123456789101112131415161718&lt;xs:simpleType name="componentTypeEnum"&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:enumeration value="Typ1"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;![CDATA[This is type1]]&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:enumeration&gt; &lt;xs:enumeration value="Typ2"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;![CDATA[This is type1]]&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:enumeration&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt; 因應方式是把註解加在simpleType下, 如:1234567891011121314&lt;xs:simpleType name="componentTypeEnum"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;![CDATA[ `Type1`: this is type1 `Type2`: this is type2 ]]&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:enumeration value="Typ1" /&gt; &lt;xs:enumeration value="Typ2" /&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt; 後記這個工具用起來很不錯, 不過如上面所說, 有一些細節不符合目前專案需求, 所以只好自己另外 fork 出來改成 ronsun/xs3p.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新增一個使用者定義函數提供亂數字串]]></title>
    <url>%2Fcontent%2F20170820-mssql-random-string.html</url>
    <content type="text"><![CDATA[首先, 需求上是這樣的:要在資料庫中建立一個UDF(User-defined function), 它的功能是要能產生一組格式像這樣 zAc-jVu-euO-nQ7 的亂數字串。 參考許多網路文章並實作後, 發現在Function裡面並不能使用RAND()這類的函數, 所以只能先建立一個檢視表(View), 接著才能在函數中撈出產生在檢視表中的亂數來做動作。 建立檢視表1234CREATE VIEW Get_RANDASSELECT RAND() AS RandomNumberGO 建立函數 123456789101112131415161718192021222324252627282930313233343536373839404142434445CREATE FUNCTION [dbo].[fu_CZ_NewID]()RETURNS VARCHAR(100)ASBEGIN --需求: -- 產生一個格式為 6ev-zS5-lMN-pwg 的亂數字串 -- * 長度為15個字元 -- * 每三個字元以'-'符號作為分隔符號 --@id: 要產生的字串 DECLARE @id VARCHAR(100) = ''; --@length: 要產生的字串長度 DECLARE @length INT = 15; --@group: 每隔幾個字要加上分隔字元 DECLARE @group INT = 3; ---@chars: 亂數資料來源 DECLARE @chars VARCHAR(100) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'; --@count: 迴圈起始值 DECLARE @count INT = 0; WHILE (@count &lt; @length) BEGIN DECLARE @current INT = (SELECT RandomNumber FROM dbo.Get_RAND) * 100 IF(@current &lt;= LEN(@chars)) BEGIN --判斷是否加分隔字元 IF((LEN(@id) + 1) % (@group + 1) = 0) BEGIN SET @id += '-'; SET @count += 1; END SET @id += SUBSTRING(@chars, @current, 1); SET @count += 1; END END -- Return the result of the function RETURN @idEND]]></content>
      <categories>
        <category>MSSQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HttpRequest.QueryString 的自動 UrlDecode 問題]]></title>
    <url>%2Fcontent%2F20170813-HhttpRequest.QueryString-auto-urlDecode.html</url>
    <content type="text"><![CDATA[HttpRequest.QueryString[“q”] 在用來取得query string的值是很方便, 但是會自動將query string先做過UrlDecode, 這在query string 有某些特殊字元的時候產生問題 直接上Demo 123456789101112131415161718192021public ActionResult Index()&#123; //sample query string (plain text): q=aaa$bbb+ccc //q = "aaa$bbb ccc" string q = this.Request.QueryString["q"]; // solution 1: encode after get query string // useful if query string not contain other characters can be encode //q = "aaa%24bbb+ccc" in this case string q2 = HttpUtility.UrlEncode(this.Request.QueryString["q"]); // solution 2: split string to get value // if query string contain charactors can be encode, this is safety way List&lt;string&gt; queryStrings = this.Request.Url.Query.Replace("?", "").Split('&amp;').ToList(); //q3 = "aaa$bbb+ccc" string q3 = queryStrings.Where(r =&gt; r.Split('=')[0] == "q").Select(r =&gt; r.Split('=')[1]).FirstOrDefault(); return View();&#125;]]></content>
      <categories>
        <category>C#</category>
        <category>.NET</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[置底 - 工具箱與優質傳送門]]></title>
    <url>%2Fcontent%2F19000101-tools-and-references.html</url>
    <content type="text"><![CDATA[總有一些小工具一個不小心就會忘, 還有一些好文章要查的時候找不到. 工具箱線上工具 Regex Regex 101: 線上regex檢查附速查表與解析. Debuggex: 線上regex檢查附速查表與圖像化解析. Regulex: 線上regex圖像化解析, 沒有檢查功能但比較好看. Markdown Editor StackEdit: 好用好看. C# 線上IDE dotnetfiddle .net source browser .net framework .net core 其他 archive.org: 網頁下架/消失後可以從這裡找到備份, 備份比 google cache 還要久. 傳送門C# / .NETWebClient vs HttpClient vs HttpWebRequest API 設計REST &amp; RESTful (1)REST &amp; RESTful (2) 官方文件微軟 Framework 設計方針Visual Studio 中的預設鍵盤快速鍵 其他Visual Studio 2017 keyboard shortcutsAirbnb 資深工程師分享：怎樣才是正確、有效的 code reviewC# 温故而知新：Stream篇（—）C# 温故而知新：Stream篇（二）C# 温故而知新：Stream篇（三）C# 温故而知新：Stream篇（四）C# 温故而知新：Stream篇（五）C# 温故而知新：Stream篇（六）C# 温故而知新：Stream篇（七）]]></content>
      <categories>
        <category>Top</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
